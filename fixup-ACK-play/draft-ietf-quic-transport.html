<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Notational Conventions">
<link href="#rfc.section.3" rel="Chapter" title="3 A QUIC Overview">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Low-Latency Connection Establishment">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Stream Multiplexing">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Rich Signaling for Congestion Control and Loss Recovery">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Stream and Connection Flow Control">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Authenticated and Encrypted Header and Payload">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Connection Migration and Resilience to NAT Rebinding">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Version Negotiation">
<link href="#rfc.section.4" rel="Chapter" title="4 Versions">
<link href="#rfc.section.5" rel="Chapter" title="5 Packet Types and Formats">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Long Header">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Short Header">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Version Negotiation Packet">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Cryptographic Handshake Packets">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Initial Packet">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Retry Packet">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 Handshake Packet">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Protected Packets">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Connection ID">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Packet Numbers">
<link href="#rfc.section.5.7.1" rel="Chapter" title="5.7.1 Initial Packet Number">
<link href="#rfc.section.6" rel="Chapter" title="6 Frames and Frame Types">
<link href="#rfc.section.7" rel="Chapter" title="7 Life of a Connection">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Matching Packets to Connections">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Client Packet Handling">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Server Packet Handling">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Version Negotiation">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Sending Version Negotiation Packets">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Handling Version Negotiation Packets">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 Using Reserved Versions">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Cryptographic and Transport Handshake">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Transport Parameters">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Transport Parameter Definitions">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 Values of Transport Parameters for 0-RTT">
<link href="#rfc.section.7.4.3" rel="Chapter" title="7.4.3 New Transport Parameters">
<link href="#rfc.section.7.4.4" rel="Chapter" title="7.4.4 Version Negotiation Validation">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Stateless Retries">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Proof of Source Address Ownership">
<link href="#rfc.section.7.6.1" rel="Chapter" title="7.6.1 Client Address Validation Procedure">
<link href="#rfc.section.7.6.2" rel="Chapter" title="7.6.2 Address Validation on Session Resumption">
<link href="#rfc.section.7.6.3" rel="Chapter" title="7.6.3 Address Validation Token Integrity">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Connection Migration">
<link href="#rfc.section.7.7.1" rel="Chapter" title="7.7.1 Privacy Implications of Connection Migration">
<link href="#rfc.section.7.7.2" rel="Chapter" title="7.7.2 Address Validation for Migrated Connections">
<link href="#rfc.section.7.8" rel="Chapter" title="7.8 Spurious Connection Migrations">
<link href="#rfc.section.7.9" rel="Chapter" title="7.9 Connection Termination">
<link href="#rfc.section.7.9.1" rel="Chapter" title="7.9.1 Closing and Draining Connection States">
<link href="#rfc.section.7.9.2" rel="Chapter" title="7.9.2 Idle Timeout">
<link href="#rfc.section.7.9.3" rel="Chapter" title="7.9.3 Immediate Close">
<link href="#rfc.section.7.9.4" rel="Chapter" title="7.9.4 Stateless Reset">
<link href="#rfc.section.8" rel="Chapter" title="8 Frame Types and Formats">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Variable-Length Integer Encoding">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 PADDING Frame">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 RST_STREAM Frame">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 CONNECTION_CLOSE frame">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 APPLICATION_CLOSE frame">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 MAX_DATA Frame">
<link href="#rfc.section.8.7" rel="Chapter" title="8.7 MAX_STREAM_DATA Frame">
<link href="#rfc.section.8.8" rel="Chapter" title="8.8 MAX_STREAM_ID Frame">
<link href="#rfc.section.8.9" rel="Chapter" title="8.9 PING Frame">
<link href="#rfc.section.8.10" rel="Chapter" title="8.10 BLOCKED Frame">
<link href="#rfc.section.8.11" rel="Chapter" title="8.11 STREAM_BLOCKED Frame">
<link href="#rfc.section.8.12" rel="Chapter" title="8.12 STREAM_ID_BLOCKED Frame">
<link href="#rfc.section.8.13" rel="Chapter" title="8.13 NEW_CONNECTION_ID Frame">
<link href="#rfc.section.8.14" rel="Chapter" title="8.14 STOP_SENDING Frame">
<link href="#rfc.section.8.15" rel="Chapter" title="8.15 ACK Frame">
<link href="#rfc.section.8.15.1" rel="Chapter" title="8.15.1 ACK Block Section">
<link href="#rfc.section.8.15.2" rel="Chapter" title="8.15.2 Sending ACK Frames">
<link href="#rfc.section.8.15.3" rel="Chapter" title="8.15.3 ACK Frames and Packet Protection">
<link href="#rfc.section.8.16" rel="Chapter" title="8.16 PATH_CHALLENGE Frame">
<link href="#rfc.section.8.17" rel="Chapter" title="8.17 PATH_RESPONSE Frame">
<link href="#rfc.section.8.18" rel="Chapter" title="8.18 STREAM Frames">
<link href="#rfc.section.9" rel="Chapter" title="9 Packetization and Reliability">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Packet Processing and Acknowledgment">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Retransmission of Information">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Packet Size">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Path Maximum Transmission Unit">
<link href="#rfc.section.9.4.1" rel="Chapter" title="9.4.1 Special Considerations for PMTU Discovery">
<link href="#rfc.section.9.4.2" rel="Chapter" title="9.4.2 Special Considerations for Packetization Layer PMTU Discovery">
<link href="#rfc.section.10" rel="Chapter" title="10 Streams: QUIC&#8217;s Data Structuring Abstraction">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Stream Identifiers">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Stream States">
<link href="#rfc.section.10.2.1" rel="Chapter" title="10.2.1 Send Stream States">
<link href="#rfc.section.10.2.2" rel="Chapter" title="10.2.2 Receive Stream States">
<link href="#rfc.section.10.2.3" rel="Chapter" title="10.2.3 Permitted Frame Types">
<link href="#rfc.section.10.2.4" rel="Chapter" title="10.2.4 Bidirectional Stream States">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Solicited State Transitions">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Stream Concurrency">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Sending and Receiving Data">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Stream Prioritization">
<link href="#rfc.section.11" rel="Chapter" title="11 Flow Control">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 Edge Cases and Other Considerations">
<link href="#rfc.section.11.1.1" rel="Chapter" title="11.1.1 Response to a RST_STREAM">
<link href="#rfc.section.11.1.2" rel="Chapter" title="11.1.2 Data Limit Increments">
<link href="#rfc.section.11.1.3" rel="Chapter" title="11.1.3 Handshake Exemption">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 Stream Limit Increment">
<link href="#rfc.section.11.2.1" rel="Chapter" title="11.2.1 Blocking on Flow Control">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 Stream Final Offset">
<link href="#rfc.section.12" rel="Chapter" title="12 Error Handling">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Connection Errors">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Stream Errors">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Transport Error Codes">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Application Protocol Error Codes">
<link href="#rfc.section.13" rel="Chapter" title="13 Security and Privacy Considerations">
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 Spoofed ACK Attack">
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 Slowloris Attacks">
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 Stream Fragmentation and Reassembly Attacks">
<link href="#rfc.section.13.4" rel="Chapter" title="13.4 Stream Commitment Attack">
<link href="#rfc.section.14" rel="Chapter" title="14 IANA Considerations">
<link href="#rfc.section.14.1" rel="Chapter" title="14.1 QUIC Transport Parameter Registry">
<link href="#rfc.section.14.2" rel="Chapter" title="14.2 QUIC Transport Error Codes Registry">
<link href="#rfc.references" rel="Chapter" title="15 References">
<link href="#rfc.references.1" rel="Chapter" title="15.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="15.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Contributors">
<link href="#rfc.appendix.B" rel="Chapter" title="B Acknowledgments">
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Since draft-ietf-quic-transport-09">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Since draft-ietf-quic-transport-08">
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Since draft-ietf-quic-transport-07">
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Since draft-ietf-quic-transport-06">
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Since draft-ietf-quic-transport-05">
<link href="#rfc.appendix.C.6" rel="Chapter" title="C.6 Since draft-ietf-quic-transport-04">
<link href="#rfc.appendix.C.7" rel="Chapter" title="C.7 Since draft-ietf-quic-transport-03">
<link href="#rfc.appendix.C.8" rel="Chapter" title="C.8 Since draft-ietf-quic-transport-02">
<link href="#rfc.appendix.C.9" rel="Chapter" title="C.9 Since draft-ietf-quic-transport-01">
<link href="#rfc.appendix.C.10" rel="Chapter" title="C.10 Since draft-ietf-quic-transport-00">
<link href="#rfc.appendix.C.11" rel="Chapter" title="C.11 Since draft-hamilton-quic-transport-protocol-01">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and M. Thomson, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-transport-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-03-04" />
  <meta name="dct.abstract" content="This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection." />
  <meta name="description" content="This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. Thomson, Ed.</td>
</tr>
<tr>
<td class="left">Expires: September 5, 2018</td>
<td class="right">Mozilla</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">March 04, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC: A UDP-Based Multiplexed and Secure Transport<br />
  <span class="filename">draft-ietf-quic-transport-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-transport">https://github.com/quicwg/base-drafts/labels/-transport</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 5, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Conventions and Definitions</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Notational Conventions</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">A QUIC Overview</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Low-Latency Connection Establishment</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Stream Multiplexing</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Rich Signaling for Congestion Control and Loss Recovery</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Stream and Connection Flow Control</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">Authenticated and Encrypted Header and Payload</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">Connection Migration and Resilience to NAT Rebinding</a>
</li>
<li>3.7.   <a href="#rfc.section.3.7">Version Negotiation</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Versions</a>
</li>
<li>5.   <a href="#rfc.section.5">Packet Types and Formats</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Long Header</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Short Header</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Version Negotiation Packet</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Cryptographic Handshake Packets</a>
</li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">Initial Packet</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Retry Packet</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">Handshake Packet</a>
</li>
</ul><li>5.5.   <a href="#rfc.section.5.5">Protected Packets</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Connection ID</a>
</li>
<li>5.7.   <a href="#rfc.section.5.7">Packet Numbers</a>
</li>
<ul><li>5.7.1.   <a href="#rfc.section.5.7.1">Initial Packet Number</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Frames and Frame Types</a>
</li>
<li>7.   <a href="#rfc.section.7">Life of a Connection</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Matching Packets to Connections</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Client Packet Handling</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Server Packet Handling</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Version Negotiation</a>
</li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Sending Version Negotiation Packets</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Handling Version Negotiation Packets</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">Using Reserved Versions</a>
</li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Cryptographic and Transport Handshake</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Transport Parameters</a>
</li>
<ul><li>7.4.1.   <a href="#rfc.section.7.4.1">Transport Parameter Definitions</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">Values of Transport Parameters for 0-RTT</a>
</li>
<li>7.4.3.   <a href="#rfc.section.7.4.3">New Transport Parameters</a>
</li>
<li>7.4.4.   <a href="#rfc.section.7.4.4">Version Negotiation Validation</a>
</li>
</ul><li>7.5.   <a href="#rfc.section.7.5">Stateless Retries</a>
</li>
<li>7.6.   <a href="#rfc.section.7.6">Proof of Source Address Ownership</a>
</li>
<ul><li>7.6.1.   <a href="#rfc.section.7.6.1">Client Address Validation Procedure</a>
</li>
<li>7.6.2.   <a href="#rfc.section.7.6.2">Address Validation on Session Resumption</a>
</li>
<li>7.6.3.   <a href="#rfc.section.7.6.3">Address Validation Token Integrity</a>
</li>
</ul><li>7.7.   <a href="#rfc.section.7.7">Connection Migration</a>
</li>
<ul><li>7.7.1.   <a href="#rfc.section.7.7.1">Privacy Implications of Connection Migration</a>
</li>
<li>7.7.2.   <a href="#rfc.section.7.7.2">Address Validation for Migrated Connections</a>
</li>
</ul><li>7.8.   <a href="#rfc.section.7.8">Spurious Connection Migrations</a>
</li>
<li>7.9.   <a href="#rfc.section.7.9">Connection Termination</a>
</li>
<ul><li>7.9.1.   <a href="#rfc.section.7.9.1">Closing and Draining Connection States</a>
</li>
<li>7.9.2.   <a href="#rfc.section.7.9.2">Idle Timeout</a>
</li>
<li>7.9.3.   <a href="#rfc.section.7.9.3">Immediate Close</a>
</li>
<li>7.9.4.   <a href="#rfc.section.7.9.4">Stateless Reset</a>
</li>
</ul></ul><li>8.   <a href="#rfc.section.8">Frame Types and Formats</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Variable-Length Integer Encoding</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">PADDING Frame</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">RST_STREAM Frame</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">CONNECTION_CLOSE frame</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">APPLICATION_CLOSE frame</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">MAX_DATA Frame</a>
</li>
<li>8.7.   <a href="#rfc.section.8.7">MAX_STREAM_DATA Frame</a>
</li>
<li>8.8.   <a href="#rfc.section.8.8">MAX_STREAM_ID Frame</a>
</li>
<li>8.9.   <a href="#rfc.section.8.9">PING Frame</a>
</li>
<li>8.10.   <a href="#rfc.section.8.10">BLOCKED Frame</a>
</li>
<li>8.11.   <a href="#rfc.section.8.11">STREAM_BLOCKED Frame</a>
</li>
<li>8.12.   <a href="#rfc.section.8.12">STREAM_ID_BLOCKED Frame</a>
</li>
<li>8.13.   <a href="#rfc.section.8.13">NEW_CONNECTION_ID Frame</a>
</li>
<li>8.14.   <a href="#rfc.section.8.14">STOP_SENDING Frame</a>
</li>
<li>8.15.   <a href="#rfc.section.8.15">ACK Frame</a>
</li>
<ul><li>8.15.1.   <a href="#rfc.section.8.15.1">ACK Block Section</a>
</li>
<li>8.15.2.   <a href="#rfc.section.8.15.2">Sending ACK Frames</a>
</li>
<li>8.15.3.   <a href="#rfc.section.8.15.3">ACK Frames and Packet Protection</a>
</li>
</ul><li>8.16.   <a href="#rfc.section.8.16">PATH_CHALLENGE Frame</a>
</li>
<li>8.17.   <a href="#rfc.section.8.17">PATH_RESPONSE Frame</a>
</li>
<li>8.18.   <a href="#rfc.section.8.18">STREAM Frames</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Packetization and Reliability</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Packet Processing and Acknowledgment</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Retransmission of Information</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Packet Size</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Path Maximum Transmission Unit</a>
</li>
<ul><li>9.4.1.   <a href="#rfc.section.9.4.1">Special Considerations for PMTU Discovery</a>
</li>
<li>9.4.2.   <a href="#rfc.section.9.4.2">Special Considerations for Packetization Layer PMTU Discovery</a>
</li>
</ul></ul><li>10.   <a href="#rfc.section.10">Streams: QUIC&#8217;s Data Structuring Abstraction</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Stream Identifiers</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Stream States</a>
</li>
<ul><li>10.2.1.   <a href="#rfc.section.10.2.1">Send Stream States</a>
</li>
<li>10.2.2.   <a href="#rfc.section.10.2.2">Receive Stream States</a>
</li>
<li>10.2.3.   <a href="#rfc.section.10.2.3">Permitted Frame Types</a>
</li>
<li>10.2.4.   <a href="#rfc.section.10.2.4">Bidirectional Stream States</a>
</li>
</ul><li>10.3.   <a href="#rfc.section.10.3">Solicited State Transitions</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Stream Concurrency</a>
</li>
<li>10.5.   <a href="#rfc.section.10.5">Sending and Receiving Data</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Stream Prioritization</a>
</li>
</ul><li>11.   <a href="#rfc.section.11">Flow Control</a>
</li>
<ul><li>11.1.   <a href="#rfc.section.11.1">Edge Cases and Other Considerations</a>
</li>
<ul><li>11.1.1.   <a href="#rfc.section.11.1.1">Response to a RST_STREAM</a>
</li>
<li>11.1.2.   <a href="#rfc.section.11.1.2">Data Limit Increments</a>
</li>
<li>11.1.3.   <a href="#rfc.section.11.1.3">Handshake Exemption</a>
</li>
</ul><li>11.2.   <a href="#rfc.section.11.2">Stream Limit Increment</a>
</li>
<ul><li>11.2.1.   <a href="#rfc.section.11.2.1">Blocking on Flow Control</a>
</li>
</ul><li>11.3.   <a href="#rfc.section.11.3">Stream Final Offset</a>
</li>
</ul><li>12.   <a href="#rfc.section.12">Error Handling</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Connection Errors</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Stream Errors</a>
</li>
<li>12.3.   <a href="#rfc.section.12.3">Transport Error Codes</a>
</li>
<li>12.4.   <a href="#rfc.section.12.4">Application Protocol Error Codes</a>
</li>
</ul><li>13.   <a href="#rfc.section.13">Security and Privacy Considerations</a>
</li>
<ul><li>13.1.   <a href="#rfc.section.13.1">Spoofed ACK Attack</a>
</li>
<li>13.2.   <a href="#rfc.section.13.2">Slowloris Attacks</a>
</li>
<li>13.3.   <a href="#rfc.section.13.3">Stream Fragmentation and Reassembly Attacks</a>
</li>
<li>13.4.   <a href="#rfc.section.13.4">Stream Commitment Attack</a>
</li>
</ul><li>14.   <a href="#rfc.section.14">IANA Considerations</a>
</li>
<ul><li>14.1.   <a href="#rfc.section.14.1">QUIC Transport Parameter Registry</a>
</li>
<li>14.2.   <a href="#rfc.section.14.2">QUIC Transport Error Codes Registry</a>
</li>
</ul><li>15.   <a href="#rfc.references">References</a>
</li>
<ul><li>15.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>15.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Contributors</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Acknowledgments</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Since draft-ietf-quic-transport-09</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Since draft-ietf-quic-transport-08</a>
</li>
<li>C.3.   <a href="#rfc.appendix.C.3">Since draft-ietf-quic-transport-07</a>
</li>
<li>C.4.   <a href="#rfc.appendix.C.4">Since draft-ietf-quic-transport-06</a>
</li>
<li>C.5.   <a href="#rfc.appendix.C.5">Since draft-ietf-quic-transport-05</a>
</li>
<li>C.6.   <a href="#rfc.appendix.C.6">Since draft-ietf-quic-transport-04</a>
</li>
<li>C.7.   <a href="#rfc.appendix.C.7">Since draft-ietf-quic-transport-03</a>
</li>
<li>C.8.   <a href="#rfc.appendix.C.8">Since draft-ietf-quic-transport-02</a>
</li>
<li>C.9.   <a href="#rfc.appendix.C.9">Since draft-ietf-quic-transport-01</a>
</li>
<li>C.10.   <a href="#rfc.appendix.C.10">Since draft-ietf-quic-transport-00</a>
</li>
<li>C.11.   <a href="#rfc.appendix.C.11">Since draft-hamilton-quic-transport-protocol-01</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC aims to provide a flexible set of features that allow it to be a general-purpose transport for multiple applications.</p>
<p id="rfc.section.1.p.2">QUIC implements techniques learned from experience with TCP, SCTP and other transport protocols.  QUIC uses UDP as substrate so as to not require changes to legacy client operating systems and middleboxes to be deployable.  QUIC authenticates all of its headers and encrypts most of the data it exchanges, including its signaling.  This allows the protocol to evolve without incurring a dependency on upgrades to middleboxes.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.</p>
<p id="rfc.section.1.p.3">Accompanying documents describe QUIC&#8217;s loss detection and congestion control <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>, and the use of TLS 1.3 for key negotiation <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<p id="rfc.section.1.p.4">QUIC version 1 conforms to the protocol invariants in <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a>
</h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.2.p.2">Definitions of terms that are used in this document:</p>
<p></p>

<dl>
<dt>Client:</dt>
<dd style="margin-left: 8">The endpoint initiating a QUIC connection.</dd>
<dt>Server:</dt>
<dd style="margin-left: 8">The endpoint accepting incoming QUIC connections.</dd>
<dt>Endpoint:</dt>
<dd style="margin-left: 8">The client or server end of a connection.</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">A logical, bi-directional channel of ordered bytes within a QUIC connection.</dd>
<dt>Connection:</dt>
<dd style="margin-left: 8">A conversation between two QUIC endpoints with a single encryption context that multiplexes streams within it.</dd>
<dt>Connection ID:</dt>
<dd style="margin-left: 8">The 64-bit unsigned number used as an identifier for a QUIC connection.</dd>
<dt>QUIC packet:</dt>
<dd style="margin-left: 8">A well-formed UDP payload that can be parsed by a QUIC receiver.</dd>
</dl>
<h2 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h2>
<p id="rfc.section.2.1.p.1">Packet and frame diagrams use the format described in Section 3.1 of <a href="#RFC2360" class="xref">[RFC2360]</a>, with the following additional conventions:</p>
<p></p>

<dl>
<dt>[x]</dt>
<dd style="margin-left: 8">Indicates that x is optional</dd>
<dt>x (A)</dt>
<dd style="margin-left: 8">Indicates that x is A bits long</dd>
<dt>x (A/B/C) &#8230;</dt>
<dd style="margin-left: 8">Indicates that x is one of A, B, or C bits long</dd>
<dt>x (i) &#8230;</dt>
<dd style="margin-left: 8">Indicates that x uses the variable-length encoding in <a href="#integer-encoding" class="xref">Section 8.1</a>
</dd>
<dt>x (*) &#8230;</dt>
<dd style="margin-left: 8">Indicates that x is variable-length</dd>
</dl>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#a-quic-overview" id="a-quic-overview">A QUIC Overview</a>
</h1>
<p id="rfc.section.3.p.1">This section briefly describes QUIC&#8217;s key mechanisms and benefits.  Key strengths of QUIC include:</p>
<p></p>

<ul>
<li>Low-latency connection establishment</li>
<li>Multiplexing without head-of-line blocking</li>
<li>Authenticated and encrypted header and payload</li>
<li>Rich signaling for congestion control and loss recovery</li>
<li>Stream and connection flow control</li>
<li>Connection migration and resilience to NAT rebinding</li>
<li>Version negotiation</li>
</ul>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#low-latency-connection-establishment" id="low-latency-connection-establishment">Low-Latency Connection Establishment</a>
</h2>
<p id="rfc.section.3.1.p.1">QUIC relies on a combined cryptographic and transport handshake for setting up a secure transport connection.  QUIC connections are expected to commonly use 0-RTT handshakes, meaning that for most QUIC connections, data can be sent immediately following the client handshake packet, without waiting for a reply from the server.  QUIC provides a dedicated stream (Stream ID 0) to be used for performing the cryptographic handshake and QUIC options negotiation.  The format of the QUIC options and parameters used during negotiation are described in this document, but the handshake protocol that runs on Stream ID 0 is described in the accompanying cryptographic handshake draft <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<h2 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#stream-multiplexing" id="stream-multiplexing">Stream Multiplexing</a>
</h2>
<p id="rfc.section.3.2.p.1">When application messages are transported over TCP, independent application messages can suffer from head-of-line blocking.  When an application multiplexes many streams atop TCP&#8217;s single-bytestream abstraction, a loss of a TCP segment results in blocking of all subsequent segments until a retransmission arrives, irrespective of the application streams that are encapsulated in subsequent segments.  QUIC ensures that lost packets carrying data for an individual stream only impact that specific stream.  Data received on other streams can continue to be reassembled and delivered to the application.</p>
<h2 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#rich-signaling-for-congestion-control-and-loss-recovery" id="rich-signaling-for-congestion-control-and-loss-recovery">Rich Signaling for Congestion Control and Loss Recovery</a>
</h2>
<p id="rfc.section.3.3.p.1">QUIC&#8217;s packet framing and acknowledgments carry rich information that help both congestion control and loss recovery in fundamental ways.  Each QUIC packet carries a new packet number, including those carrying retransmitted data.  This obviates the need for a separate mechanism to distinguish acknowledgments for retransmissions from those for original transmissions, avoiding TCP&#8217;s retransmission ambiguity problem.  QUIC acknowledgments also explicitly encode the delay between the receipt of a packet and its acknowledgment being sent, and together with the monotonically-increasing packet numbers, this allows for precise network roundtrip-time (RTT) calculation.  QUIC&#8217;s ACK frames support multiple ACK blocks, so QUIC is more resilient to reordering than TCP with SACK support, as well as able to keep more bytes on the wire when there is reordering or loss.</p>
<h2 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#stream-and-connection-flow-control" id="stream-and-connection-flow-control">Stream and Connection Flow Control</a>
</h2>
<p id="rfc.section.3.4.p.1">QUIC implements stream- and connection-level flow control.  At a high level, a QUIC receiver advertises the maximum amount of data that it is willing to receive on each stream.  As data is sent, received, and delivered on a particular stream, the receiver sends MAX_STREAM_DATA frames that increase the advertised limit for that stream, allowing the peer to send more data on that stream.</p>
<p id="rfc.section.3.4.p.2">In addition to this stream-level flow control, QUIC implements connection-level flow control to limit the aggregate buffer that a QUIC receiver is willing to allocate to all streams on a connection.  Connection-level flow control works in the same way as stream-level flow control, but the bytes delivered and the limits are aggregated across all streams.</p>
<h2 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#authenticated-and-encrypted-header-and-payload" id="authenticated-and-encrypted-header-and-payload">Authenticated and Encrypted Header and Payload</a>
</h2>
<p id="rfc.section.3.5.p.1">TCP headers appear in plaintext on the wire and are not authenticated, causing a plethora of injection and header manipulation issues for TCP, such as receive-window manipulation and sequence-number overwriting.  While some of these are mechanisms used by middleboxes to improve TCP performance, others are active attacks.  Even &#8220;performance-enhancing&#8221; middleboxes that routinely interpose on the transport state machine end up limiting the evolvability of the transport protocol, as has been observed in the design of MPTCP <a href="#RFC6824" class="xref">[RFC6824]</a> and in its subsequent deployability issues.</p>
<p id="rfc.section.3.5.p.2">Generally, QUIC packets are always authenticated and the payload is typically fully encrypted.  The parts of the packet header which are not encrypted are still authenticated by the receiver, so as to thwart any packet injection or manipulation by third parties.  Some early handshake packets, such as the Version Negotiation packet, are not encrypted, but information sent in these unencrypted handshake packets is later verified as part of cryptographic processing.</p>
<h2 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#connection-migration-and-resilience-to-nat-rebinding" id="connection-migration-and-resilience-to-nat-rebinding">Connection Migration and Resilience to NAT Rebinding</a>
</h2>
<p id="rfc.section.3.6.p.1">QUIC connections are identified by a Connection ID, a 64-bit unsigned number randomly generated by the server.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and port, such as those caused by NAT rebindings or by the client changing network connectivity to a new address. QUIC provides automatic cryptographic verification of a rebound client, since the client continues to use the same session key for encrypting and decrypting packets. The consistent connection ID can be used to allow migration of the connection to a new server IP address as well, since the Connection ID remains consistent across changes in the client&#8217;s and the server&#8217;s network addresses.</p>
<h2 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> <a href="#benefit-version-negotiation" id="benefit-version-negotiation">Version Negotiation</a>
</h2>
<p id="rfc.section.3.7.p.1">QUIC version negotiation allows for multiple versions of the protocol to be deployed and used concurrently. Version negotiation is described in <a href="#version-negotiation" class="xref">Section 7.2</a>.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#versions" id="versions">Versions</a>
</h1>
<p id="rfc.section.4.p.1">QUIC versions are identified using a 32-bit unsigned number.</p>
<p id="rfc.section.4.p.2">The version 0x00000000 is reserved to represent version negotiation.  This version of the specification is identified by the number 0x00000001.</p>
<p id="rfc.section.4.p.3">Other versions of QUIC might have different properties to this version.  The properties of QUIC that are guaranteed to be consistent across all versions of the protocol are described in <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a>.</p>
<p id="rfc.section.4.p.4">Version 0x00000001 of QUIC uses TLS as a cryptographic handshake protocol, as described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<p id="rfc.section.4.p.5">Versions with the most significant 16 bits of the version number cleared are reserved for use in future IETF consensus documents.</p>
<p id="rfc.section.4.p.6">Versions that follow the pattern 0x?a?a?a?a are reserved for use in forcing version negotiation to be exercised.  That is, any version number where the low four bits of all octets is 1010 (in binary).  A client or server MAY advertise support for any of these reserved versions.</p>
<p id="rfc.section.4.p.7">Reserved version numbers will probably never represent a real protocol; a client MAY use one of these version numbers with the expectation that the server will initiate version negotiation; a server MAY advertise support for one of these versions and can expect that clients ignore the value.</p>
<p id="rfc.section.4.p.8">[[RFC editor: please remove the remainder of this section before publication.]]</p>
<p id="rfc.section.4.p.9">The version number for the final version of this specification (0x00000001), is reserved for the version of the protocol that is published as an RFC.</p>
<p id="rfc.section.4.p.10">Version numbers used to identify IETF drafts are created by adding the draft number to 0xff000000.  For example, draft-ietf-quic-transport-13 would be identified as 0xff00000D.</p>
<p id="rfc.section.4.p.11">Implementors are encouraged to register version numbers of QUIC that they are using for private experimentation on the <a href="https://github.com/quicwg/base-drafts/wiki/QUIC-Versions">github wiki</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#packet-types-and-formats" id="packet-types-and-formats">Packet Types and Formats</a>
</h1>
<p id="rfc.section.5.p.1">We first describe QUIC&#8217;s packet types and their formats, since some are referenced in subsequent mechanisms.</p>
<p id="rfc.section.5.p.2">All numeric values are encoded in network byte order (that is, big-endian) and all field sizes are in bits.  When discussing individual bits of fields, the least significant bit is referred to as bit 0.  Hexadecimal notation is used for describing the value of fields.</p>
<p id="rfc.section.5.p.3">Any QUIC packet has either a long or a short header, as indicated by the Header Form bit. Long headers are expected to be used early in the connection before version negotiation and establishment of 1-RTT keys.  Short headers are minimal version-specific headers, which are used after version negotiation and 1-RTT keys are established.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#long-header" id="long-header">Long Header</a>
</h2>
<div id="rfc.figure.1"></div>
<div id="fig-long-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|   Type (7)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Connection ID (64)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Packet Number (32)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 1: Long Header Format</p>
<p id="rfc.section.5.1.p.1">Long headers are used for packets that are sent prior to the completion of version negotiation and establishment of 1-RTT keys. Once both conditions are met, a sender switches to sending packets using the short header (<a href="#short-header" class="xref">Section 5.2</a>).  The long form allows for special packets - such as the Version Negotiation packet - to be represented in this uniform fixed-length packet format. A long header contains the following fields:</p>
<p></p>

<dl>
<dt>Header Form:</dt>
<dd style="margin-left: 8">The most significant bit (0x80) of octet 0 (the first octet) is set to 1 for long headers.</dd>
<dt>Long Packet Type:</dt>
<dd style="margin-left: 8">The remaining seven bits of octet 0 contain the packet type.  This field can indicate one of 128 packet types.  The types specified for this version are listed in <a href="#long-packet-types" class="xref">Table 1</a>.</dd>
<dt>Connection ID:</dt>
<dd style="margin-left: 8">Octets 1 through 8 contain the connection ID. <a href="#connection-id" class="xref">Section 5.6</a> describes the use of this field in more detail.</dd>
<dt>Version:</dt>
<dd style="margin-left: 8">Octets 9 to 12 contain the selected protocol version.  This field indicates which version of QUIC is in use and determines how the rest of the protocol fields are interpreted.</dd>
<dt>Packet Number:</dt>
<dd style="margin-left: 8">Octets 13 to 16 contain the packet number.  <a href="#packet-numbers" class="xref">Section 5.7</a> describes the use of packet numbers.</dd>
<dt>Payload:</dt>
<dd style="margin-left: 8">Octets from 17 onwards (the rest of QUIC packet) are the payload of the packet.</dd>
</dl>
<p id="rfc.section.5.1.p.3">The following packet types are defined:</p>
<div id="rfc.table.1"></div>
<div id="long-packet-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Long Header Packet Types</caption>
<thead><tr>
<th class="left">Type</th>
<th class="left">Name</th>
<th class="left">Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x7F</td>
<td class="left">Initial</td>
<td class="left"><a href="#packet-initial" class="xref">Section 5.4.1</a></td>
</tr>
<tr>
<td class="left">0x7E</td>
<td class="left">Retry</td>
<td class="left"><a href="#packet-retry" class="xref">Section 5.4.2</a></td>
</tr>
<tr>
<td class="left">0x7D</td>
<td class="left">Handshake</td>
<td class="left"><a href="#packet-handshake" class="xref">Section 5.4.3</a></td>
</tr>
<tr>
<td class="left">0x7C</td>
<td class="left">0-RTT Protected</td>
<td class="left"><a href="#packet-protected" class="xref">Section 5.5</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.1.p.4">The header form, packet type, connection ID, packet number and version fields of a long header packet are version-independent. The types of packets defined in <a href="#long-packet-types" class="xref">Table 1</a> are version-specific.  See <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a> for details on how packets from different versions of QUIC are interpreted.</p>
<p id="rfc.section.5.1.p.5">The interpretation of the fields and the payload are specific to a version and packet type.  Type-specific semantics for this version are described in the following sections.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#short-header" id="short-header">Short Header</a>
</h2>
<div id="rfc.figure.2"></div>
<div id="fig-short-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|0|C|K| Type (5)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                     [Connection ID (64)]                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Packet Number (8/16/32)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Protected Payload (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 2: Short Header Format</p>
<p id="rfc.section.5.2.p.1">The short header can be used after the version and 1-RTT keys are negotiated.  This header form has the following fields:</p>
<p></p>

<dl>
<dt>Header Form:</dt>
<dd style="margin-left: 8">The most significant bit (0x80) of octet 0 is set to 0 for the short header.</dd>
<dt>Omit Connection ID Flag:</dt>
<dd style="margin-left: 8">The second bit (0x40) of octet 0 indicates whether the Connection ID field is omitted.  If set to 0, then the Connection ID field is present; if set to 1, the Connection ID field is omitted.  The Connection ID field can only be omitted if the omit_connection_id transport parameter (<a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a>) is specified by the intended recipient of the packet.</dd>
<dt>Key Phase Bit:</dt>
<dd style="margin-left: 8">The third bit (0x20) of octet 0 indicates the key phase, which allows a recipient of a packet to identify the packet protection keys that are used to protect the packet.  See <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> for details.</dd>
<dt>Short Packet Type:</dt>
<dd style="margin-left: 8">The remaining 5 bits of octet 0 include one of 32 packet types.  <a href="#short-packet-types" class="xref">Table 2</a> lists the types that are defined for short packets.</dd>
<dt>Connection ID:</dt>
<dd style="margin-left: 8">If the Omit Connection ID Flag is not set, a connection ID occupies octets 1 through 8 of the packet.  See <a href="#connection-id" class="xref">Section 5.6</a> for more details.</dd>
<dt>Packet Number:</dt>
<dd style="margin-left: 8">The length of the packet number field depends on the packet type.  This field can be 1, 2 or 4 octets long depending on the short packet type.</dd>
<dt>Protected Payload:</dt>
<dd style="margin-left: 8">Packets with a short header always include a 1-RTT protected payload.</dd>
</dl>
<p id="rfc.section.5.2.p.3">The packet type in a short header currently determines only the size of the packet number field.  Additional types can be used to signal the presence of other fields.</p>
<div id="rfc.table.2"></div>
<div id="short-packet-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Short Header Packet Types</caption>
<thead><tr>
<th class="left">Type</th>
<th class="left">Packet Number Size</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x1F</td>
<td class="left">1 octet</td>
</tr>
<tr>
<td class="left">0x1E</td>
<td class="left">2 octets</td>
</tr>
<tr>
<td class="left">0x1D</td>
<td class="left">4 octets</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.2.p.4">The header form, omit connection ID flag, and connection ID of a short header packet are version-independent.  The remaining fields are specific to the selected QUIC version.  See <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a> for details on how packets from different versions of QUIC are interpreted.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#packet-version" id="packet-version">Version Negotiation Packet</a>
</h2>
<p id="rfc.section.5.3.p.1">A Version Negotiation packet is inherently not version-specific, and does not use the packet headers defined above. Upon receipt by a client, it will appear to be a packet using the long header, but will be identified as a Version Negotiation packet based on the Version field.</p>
<p id="rfc.section.5.3.p.2">The Version Negotiation packet is a response to a client packet that contains a version that is not supported by the server, and is only sent by servers.</p>
<p id="rfc.section.5.3.p.3">The layout of a Version Negotiation packet is:</p>
<div id="rfc.figure.3"></div>
<div id="version-negotiation-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|  Unused (7) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Connection ID (64)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Version (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version 1 (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version 2 (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version N (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 3: Version Negotiation Packet</p>
<p id="rfc.section.5.3.p.4">The value in the Unused field is selected randomly by the server. The Connection ID field echoes the corresponding value from the triggering client packet.  This allows clients some assurance that the server received the packet and that the Version Negotiation packet is in fact from the server.  The Version field MUST be set to 0x00000000.  The remainder of the Version Negotiation packet is a list of 32-bit versions which the server supports.</p>
<p id="rfc.section.5.3.p.5">A Version Negotiation packet cannot be explicitly acknowledged in an ACK frame by a client.  Receiving another Initial packet implicitly acknowledges a Version Negotiation packet.</p>
<p id="rfc.section.5.3.p.6">See <a href="#version-negotiation" class="xref">Section 7.2</a> for a description of the version negotiation process.</p>
<h2 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#handshake-packets" id="handshake-packets">Cryptographic Handshake Packets</a>
</h2>
<p id="rfc.section.5.4.p.1">Once version negotiation is complete, the cryptographic handshake is used to agree on cryptographic keys.  The cryptographic handshake is carried in Initial (<a href="#packet-initial" class="xref">Section 5.4.1</a>), Retry (<a href="#packet-retry" class="xref">Section 5.4.2</a>) and Handshake (<a href="#packet-handshake" class="xref">Section 5.4.3</a>) packets.</p>
<p id="rfc.section.5.4.p.2">All these packets use the long header and contain the current QUIC version in the version field.</p>
<p id="rfc.section.5.4.p.3">In order to prevent tampering by version-unaware middleboxes, handshake packets are protected with a connection- and version-specific key, as described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>. This protection does not provide confidentiality or integrity against on-path attackers, but provides some level of protection against off-path attackers.</p>
<h3 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#packet-initial" id="packet-initial">Initial Packet</a>
</h3>
<p id="rfc.section.5.4.1.p.1">The Initial packet uses long headers with a type value of 0x7F.  It carries the first cryptographic handshake message sent by the client.</p>
<p id="rfc.section.5.4.1.p.2">The client populates the connection ID field with randomly selected values, unless it has received a packet from the server.  If the client has received a packet from the server, the connection ID field uses the value provided by the server.</p>
<p id="rfc.section.5.4.1.p.3">The first Initial packet that is sent by a client contains a randomized packet number.  All subsequent packets contain a packet number that is incremented by one, see (<a href="#packet-numbers" class="xref">Section 5.7</a>).</p>
<p id="rfc.section.5.4.1.p.4">The payload of a Initial packet consists of a STREAM frame (or frames) for stream 0 containing a cryptographic handshake message, with enough PADDING frames that the packet is at least 1200 octets (see <a href="#packetization" class="xref">Section 9</a>).  The stream in this packet always starts at an offset of 0 (see <a href="#stateless-retry" class="xref">Section 7.5</a>) and the complete cryptographic handshake message MUST fit in a single packet (see <a href="#handshake" class="xref">Section 7.3</a>).</p>
<p id="rfc.section.5.4.1.p.5">The client uses the Initial packet type for any packet that contains an initial cryptographic handshake message.  This includes all cases where a new packet containing the initial cryptographic message needs to be created, this includes the packets sent after receiving a Version Negotiation (<a href="#packet-version" class="xref">Section 5.3</a>) or Retry packet (<a href="#packet-retry" class="xref">Section 5.4.2</a>).</p>
<h3 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#packet-retry" id="packet-retry">Retry Packet</a>
</h3>
<p id="rfc.section.5.4.2.p.1">A Retry packet uses long headers with a type value of 0x7E.  It carries cryptographic handshake messages and acknowledgments.  It is used by a server that wishes to perform a stateless retry (see <a href="#stateless-retry" class="xref">Section 7.5</a>).</p>
<p id="rfc.section.5.4.2.p.2">The server includes a connection ID of its choice in the connection ID field.  The client MUST use this connection ID for any subsequent packets that it sends.</p>
<p id="rfc.section.5.4.2.p.3">The packet number field echoes the packet number field from the triggering client packet.</p>
<p id="rfc.section.5.4.2.p.4">A Retry packet is never explicitly acknowledged in an ACK frame by a client.  Receiving another Initial packet implicitly acknowledges a Retry packet.</p>
<p id="rfc.section.5.4.2.p.5">After receiving a Retry packet, the client uses a new Initial packet containing the next cryptographic handshake message.  The client retains the state of its cryptographic handshake, but discards all transport state.  The Initial packet that is generated in response to a Retry packet includes STREAM frames on stream 0 that start again at an offset of 0.</p>
<p id="rfc.section.5.4.2.p.6">Continuing the cryptographic handshake is necessary to ensure that an attacker cannot force a downgrade of any cryptographic parameters.  In addition to continuing the cryptographic handshake, the client MUST remember the results of any version negotiation that occurred (see <a href="#version-negotiation" class="xref">Section 7.2</a>).  The client MAY also retain any observed RTT or congestion state that it has accumulated for the flow, but other transport state MUST be discarded.</p>
<p id="rfc.section.5.4.2.p.7">The payload of the Retry packet contains a single STREAM frame on stream 0 with offset 0 containing the server&#8217;s cryptographic stateless retry material. It MUST NOT contain any other frames. The next STREAM frame sent by the server will also start at stream offset 0.</p>
<h3 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> <a href="#packet-handshake" id="packet-handshake">Handshake Packet</a>
</h3>
<p id="rfc.section.5.4.3.p.1">A Handshake packet uses long headers with a type value of 0x7D.  It is used to carry acknowledgments and cryptographic handshake messages from the server and client.</p>
<p id="rfc.section.5.4.3.p.2">The connection ID field in a Handshake packet contains a connection ID that is chosen by the server (see <a href="#connection-id" class="xref">Section 5.6</a>).</p>
<p id="rfc.section.5.4.3.p.3">The first Handshake packet sent by a server contains a randomized packet number.  This value is increased for each subsequent packet sent by the server as described in <a href="#packet-numbers" class="xref">Section 5.7</a>.  The client increments the packet number from its previous packet by one for each Handshake packet that it sends (which might be an Initial, 0-RTT Protected, or Handshake packet).</p>
<p id="rfc.section.5.4.3.p.4">Servers MUST NOT send more than three Handshake packets without receiving a packet from a verified source address.  Source addresses can be verified through an address validation token, receipt of the final cryptographic message from the client, or by receiving a valid PATH_RESPONSE frame from the client.</p>
<p id="rfc.section.5.4.3.p.5">If the server expects to generate more than three Handshake packets in response to an Initial packet, it SHOULD include a PATH_CHALLENGE frame in each Handshake packet that it sends.  After receiving at least one valid PATH_RESPONSE frame, the server can send its remaining Handshake packets. Servers can instead perform address validation using a Retry packet; this requires less state on the server, but could involve additional computational effort depending on implementation choices.</p>
<p id="rfc.section.5.4.3.p.6">The payload of this packet contains STREAM frames and could contain PADDING, ACK, PATH_CHALLENGE, or PATH_RESPONSE frames.</p>
<h2 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#packet-protected" id="packet-protected">Protected Packets</a>
</h2>
<p id="rfc.section.5.5.p.1">Packets that are protected with 0-RTT keys are sent with long headers; all packets protected with 1-RTT keys are sent with short headers.  The different packet types explicitly indicate the encryption level and therefore the keys that are used to remove packet protection.</p>
<p id="rfc.section.5.5.p.2">Packets protected with 0-RTT keys use a type value of 0x7C.  The connection ID field for a 0-RTT packet is selected by the client.</p>
<p id="rfc.section.5.5.p.3">The client can send 0-RTT packets after receiving a Handshake packet (<a href="#packet-handshake" class="xref">Section 5.4.3</a>), if that packet does not complete the handshake.  Even if the client receives a different connection ID in the Handshake packet, it MUST continue to use the connection ID selected by the client for 0-RTT packets, see <a href="#connection-id" class="xref">Section 5.6</a>.</p>
<p id="rfc.section.5.5.p.4">The version field for protected packets is the current QUIC version.</p>
<p id="rfc.section.5.5.p.5">The packet number field contains a packet number, which increases with each packet sent, see <a href="#packet-numbers" class="xref">Section 5.7</a> for details.</p>
<p id="rfc.section.5.5.p.6">The payload is protected using authenticated encryption.  <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> describes packet protection in detail.  After decryption, the plaintext consists of a sequence of frames, as described in <a href="#frames" class="xref">Section 6</a>.</p>
<h2 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#connection-id" id="connection-id">Connection ID</a>
</h2>
<p id="rfc.section.5.6.p.1">QUIC connections are identified by their 64-bit Connection ID.  All long headers contain a Connection ID.  Short headers indicate the presence of a Connection ID using the Omit Connection ID flag.  When present, the Connection ID is in the same location in all packet headers, making it straightforward for middleboxes, such as load balancers, to locate and use it.</p>
<p id="rfc.section.5.6.p.2">The client MUST choose a random connection ID and use it in Initial packets (<a href="#packet-initial" class="xref">Section 5.4.1</a>) and 0-RTT packets (<a href="#packet-protected" class="xref">Section 5.5</a>).</p>
<p id="rfc.section.5.6.p.3">When the server receives a Initial packet and decides to proceed with the handshake, it chooses a new value for the connection ID and sends that in a Retry (<a href="#packet-retry" class="xref">Section 5.4.2</a>) or Handshake (<a href="#packet-handshake" class="xref">Section 5.4.3</a>) packet.  The server MAY choose to use the value that the client initially selects.</p>
<p id="rfc.section.5.6.p.4">Once the client receives the connection ID that the server has chosen, it MUST use it for all subsequent Handshake (<a href="#packet-handshake" class="xref">Section 5.4.3</a>) and 1-RTT (<a href="#packet-protected" class="xref">Section 5.5</a>) packets but not for 0-RTT packets (<a href="#packet-protected" class="xref">Section 5.5</a>).</p>
<p id="rfc.section.5.6.p.5">Server&#8217;s Version Negotiation (<a href="#packet-version" class="xref">Section 5.3</a>) and Retry (<a href="#packet-retry" class="xref">Section 5.4.2</a>) packets MUST use connection ID selected by the client.</p>
<h2 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> <a href="#packet-numbers" id="packet-numbers">Packet Numbers</a>
</h2>
<p id="rfc.section.5.7.p.1">The packet number is an integer in the range 0 to 2^62-1. The value is used in determining the cryptographic nonce for packet encryption.  Each endpoint maintains a separate packet number for sending and receiving.  The packet number for sending MUST increase by at least one after sending any packet, unless otherwise specified (see <a href="#initial-packet-number" class="xref">Section 5.7.1</a>).</p>
<p id="rfc.section.5.7.p.2">A QUIC endpoint MUST NOT reuse a packet number within the same connection (that is, under the same cryptographic keys).  If the packet number for sending reaches 2^62 - 1, the sender MUST close the connection without sending a CONNECTION_CLOSE frame or any further packets; a server MAY send a Stateless Reset (<a href="#stateless-reset" class="xref">Section 7.9.4</a>) in response to further packets that it receives.</p>
<p id="rfc.section.5.7.p.3">For the packet header, the number of bits required to represent the packet number are reduced by including only the least significant bits of the packet number.  The actual packet number for each packet is reconstructed at the receiver based on the largest packet number received on a successfully authenticated packet.</p>
<p id="rfc.section.5.7.p.4">A packet number is decoded by finding the packet number value that is closest to the next expected packet.  The next expected packet is the highest received packet number plus one.  For example, if the highest successfully authenticated packet had a packet number of 0xaa82f30e, then a packet containing a 16-bit value of 0x1f94 will be decoded as 0xaa831f94.</p>
<p id="rfc.section.5.7.p.5">The sender MUST use a packet number size able to represent more than twice as large a range than the difference between the largest acknowledged packet and packet number being sent.  A peer receiving the packet will then correctly decode the packet number, unless the packet is delayed in transit such that it arrives after many higher-numbered packets have been received.  An endpoint SHOULD use a large enough packet number encoding to allow the packet number to be recovered even if the packet arrives after packets that are sent afterwards.</p>
<p id="rfc.section.5.7.p.6">As a result, the size of the packet number encoding is at least one more than the base 2 logarithm of the number of contiguous unacknowledged packet numbers, including the new packet.</p>
<p id="rfc.section.5.7.p.7">For example, if an endpoint has received an acknowledgment for packet 0x6afa2f, sending a packet with a number of 0x6b4264 requires a 16-bit or larger packet number encoding; whereas a 32-bit packet number is needed to send a packet with a number of 0x6bc107.</p>
<p id="rfc.section.5.7.p.8">A Version Negotiation packet (<a href="#packet-version" class="xref">Section 5.3</a>) does not include a packet number.  The Retry packet (<a href="#packet-retry" class="xref">Section 5.4.2</a>) has special rules for populating the packet number field.</p>
<h3 id="rfc.section.5.7.1">
<a href="#rfc.section.5.7.1">5.7.1.</a> <a href="#initial-packet-number" id="initial-packet-number">Initial Packet Number</a>
</h3>
<p id="rfc.section.5.7.1.p.1">The initial value for packet number MUST be selected randomly from a range between 0 and 2^32 - 1025 (inclusive).  This value is selected so that Initial and Handshake packets exercise as many possible values for the Packet Number field as possible.</p>
<p id="rfc.section.5.7.1.p.2">Limiting the range allows both for loss of packets and for any stateless exchanges.  Packet numbers are incremented for subsequent packets, but packet loss and stateless handling can both mean that the first packet sent by an endpoint isn&#8217;t necessarily the first packet received by its peer.  The first packet received by a peer cannot be 2^32 or greater or the recipient will incorrectly assume a packet number that is 2^32 values lower and discard the packet.</p>
<p id="rfc.section.5.7.1.p.3">Use of a secure random number generator <a href="#RFC4086" class="xref">[RFC4086]</a> is not necessary for generating the initial packet number, nor is it necessary that the value be uniformly distributed.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#frames" id="frames">Frames and Frame Types</a>
</h1>
<p id="rfc.section.6.p.1">The payload of all packets, after removing packet protection, consists of a sequence of frames, as shown in <a href="#packet-frames" class="xref">Figure 4</a>.  Version Negotiation and Stateless Reset do not contain frames.</p>
<div id="rfc.figure.4"></div>
<div id="packet-frames"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 1 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 2 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame N (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 4: Contents of Protected Payload</p>
<p id="rfc.section.6.p.2">Protected payloads MUST contain at least one frame, and MAY contain multiple frames and multiple frame types.</p>
<p id="rfc.section.6.p.3">Frames MUST fit within a single QUIC packet and MUST NOT span a QUIC packet boundary. Each frame begins with a Frame Type byte, indicating its type, followed by additional type-dependent fields:</p>
<div id="rfc.figure.5"></div>
<div id="frame-layout"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type (8)    |           Type-Dependent Fields (*)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 5: Generic Frame Layout</p>
<p id="rfc.section.6.p.4">Frame types are listed in <a href="#frame-types" class="xref">Table 3</a>. Note that the Frame Type byte in STREAM and ACK frames is used to carry other frame-specific flags.  For all other frames, the Frame Type byte simply identifies the frame.  These frames are explained in more detail as they are referenced later in the document.</p>
<div id="rfc.table.3"></div>
<div id="frame-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Frame Types</caption>
<thead><tr>
<th class="left">Type Value</th>
<th class="left">Frame Type Name</th>
<th class="left">Definition</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x00</td>
<td class="left">PADDING</td>
<td class="left"><a href="#frame-padding" class="xref">Section 8.2</a></td>
</tr>
<tr>
<td class="left">0x01</td>
<td class="left">RST_STREAM</td>
<td class="left"><a href="#frame-rst-stream" class="xref">Section 8.3</a></td>
</tr>
<tr>
<td class="left">0x02</td>
<td class="left">CONNECTION_CLOSE</td>
<td class="left"><a href="#frame-connection-close" class="xref">Section 8.4</a></td>
</tr>
<tr>
<td class="left">0x03</td>
<td class="left">APPLICATION_CLOSE</td>
<td class="left"><a href="#frame-application-close" class="xref">Section 8.5</a></td>
</tr>
<tr>
<td class="left">0x04</td>
<td class="left">MAX_DATA</td>
<td class="left"><a href="#frame-max-data" class="xref">Section 8.6</a></td>
</tr>
<tr>
<td class="left">0x05</td>
<td class="left">MAX_STREAM_DATA</td>
<td class="left"><a href="#frame-max-stream-data" class="xref">Section 8.7</a></td>
</tr>
<tr>
<td class="left">0x06</td>
<td class="left">MAX_STREAM_ID</td>
<td class="left"><a href="#frame-max-stream-id" class="xref">Section 8.8</a></td>
</tr>
<tr>
<td class="left">0x07</td>
<td class="left">PING</td>
<td class="left"><a href="#frame-ping" class="xref">Section 8.9</a></td>
</tr>
<tr>
<td class="left">0x08</td>
<td class="left">BLOCKED</td>
<td class="left"><a href="#frame-blocked" class="xref">Section 8.10</a></td>
</tr>
<tr>
<td class="left">0x09</td>
<td class="left">STREAM_BLOCKED</td>
<td class="left"><a href="#frame-stream-blocked" class="xref">Section 8.11</a></td>
</tr>
<tr>
<td class="left">0x0a</td>
<td class="left">STREAM_ID_BLOCKED</td>
<td class="left"><a href="#frame-stream-id-blocked" class="xref">Section 8.12</a></td>
</tr>
<tr>
<td class="left">0x0b</td>
<td class="left">NEW_CONNECTION_ID</td>
<td class="left"><a href="#frame-new-connection-id" class="xref">Section 8.13</a></td>
</tr>
<tr>
<td class="left">0x0c</td>
<td class="left">STOP_SENDING</td>
<td class="left"><a href="#frame-stop-sending" class="xref">Section 8.14</a></td>
</tr>
<tr>
<td class="left">0x0d</td>
<td class="left">ACK</td>
<td class="left"><a href="#frame-ack" class="xref">Section 8.15</a></td>
</tr>
<tr>
<td class="left">0x0e</td>
<td class="left">PATH_CHALLENGE</td>
<td class="left"><a href="#frame-path-challenge" class="xref">Section 8.16</a></td>
</tr>
<tr>
<td class="left">0x0f</td>
<td class="left">PATH_RESPONSE</td>
<td class="left"><a href="#frame-path-response" class="xref">Section 8.17</a></td>
</tr>
<tr>
<td class="left">0x10 - 0x17</td>
<td class="left">STREAM</td>
<td class="left"><a href="#frame-stream" class="xref">Section 8.18</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#life-of-a-connection" id="life-of-a-connection">Life of a Connection</a>
</h1>
<p id="rfc.section.7.p.1">A QUIC connection is a single conversation between two QUIC endpoints.  QUIC&#8217;s connection establishment intertwines version negotiation with the cryptographic and transport handshakes to reduce connection establishment latency, as described in <a href="#handshake" class="xref">Section 7.3</a>.  Once established, a connection may migrate to a different IP or port at either endpoint, due to NAT rebinding or mobility, as described in <a href="#migration" class="xref">Section 7.7</a>.  Finally a connection may be terminated by either endpoint, as described in <a href="#termination" class="xref">Section 7.9</a>.</p>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#packet-handling" id="packet-handling">Matching Packets to Connections</a>
</h2>
<p id="rfc.section.7.1.p.1">Incoming packets are classified on receipt.  Packets can either be associated with an existing connection, or - for servers - potentially create a new connection.</p>
<p id="rfc.section.7.1.p.2">Hosts try to associate the packet with an existing connection. If the packet has a connection ID corresponding to an existing connection, QUIC processes that packet accordingly. Note that a NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 8.13</a>) would associate more than one connection ID with a connection.</p>
<p id="rfc.section.7.1.p.3">If there is no connection ID, but the packet matches the address/port tuple of a connection where the host did not require connection IDs, QUIC processes the packet as part of that connection. Endpoints MUST drop packets that omit connection IDs if they do not meet both of these criteria.</p>
<h3 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#client-pkt-handling" id="client-pkt-handling">Client Packet Handling</a>
</h3>
<p id="rfc.section.7.1.1.p.1">If a client receives a packet with an unknown connection ID, and it matches the tuple of a connection with no received packets, it is a reply to an Initial packet with a server-generated connection ID and will be processed accordingly. Clients SHOULD discard any packets with new connection IDs that do not meet these criteria.</p>
<p id="rfc.section.7.1.1.p.2">Note that a successfully associated packet may be a Version Negotiation packet, which is handled in accordance with <a href="#handle-vn" class="xref">Section 7.2.2</a>.</p>
<p id="rfc.section.7.1.1.p.3">Due to packet reordering or loss, clients might receive packets for a connection encrypted with a key it has not yet computed. Clients MAY drop these packets, or MAY buffer them in anticipation of later packets that allow it to compute the key.</p>
<h3 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#server-pkt-handling" id="server-pkt-handling">Server Packet Handling</a>
</h3>
<p id="rfc.section.7.1.2.p.1">If a server receives a packet that has an unsupported version and sufficient length to be an Initial packet for some version supported by the server, it SHOULD send a Version Negotiation packet as described in <a href="#send-vn" class="xref">Section 7.2.1</a>. Servers MAY rate control these packets to avoid storms of Version Negotiation packets.</p>
<p id="rfc.section.7.1.2.p.2">Servers MUST drop other packets that contain unsupported versions.</p>
<p id="rfc.section.7.1.2.p.3">Packets with a supported version, or no version field, are matched to a connection as described in <a href="#packet-handling" class="xref">Section 7.1</a>. If not matched, the server continues below.</p>
<p id="rfc.section.7.1.2.p.4">If the packet is an Initial packet fully conforming with the specification, the server proceeds with the handshake (<a href="#handshake" class="xref">Section 7.3</a>).  This commits the server to the version that the client selected.</p>
<p id="rfc.section.7.1.2.p.5">If the packet is a 0-RTT packet, the server MAY buffer a limited number of these packets in anticipation of a late-arriving Initial Packet. Clients are forbidden from sending Handshake packets prior to receiving a server response, so servers SHOULD ignore any such packets.</p>
<p id="rfc.section.7.1.2.p.6">Servers MUST drop incoming packets under all other circumstances.</p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#version-negotiation" id="version-negotiation">Version Negotiation</a>
</h2>
<p id="rfc.section.7.2.p.1">Version negotiation ensures that client and server agree to a QUIC version that is mutually supported. A server sends a Version Negotiation packet in response to each packet that might initiate a new connection, see <a href="#packet-handling" class="xref">Section 7.1</a> for details.</p>
<p id="rfc.section.7.2.p.2">The size of the first packet sent by a client will determine whether a server sends a Version Negotiation packet. Clients that support multiple QUIC versions SHOULD pad their Initial packets to reflect the largest minimum Initial packet size of all their versions. This ensures that that the server responds if there are any mutually supported versions.</p>
<h3 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#send-vn" id="send-vn">Sending Version Negotiation Packets</a>
</h3>
<p id="rfc.section.7.2.1.p.1">If the version selected by the client is not acceptable to the server, the server responds with a Version Negotiation packet (<a href="#packet-version" class="xref">Section 5.3</a>).  This includes a list of versions that the server will accept.</p>
<p id="rfc.section.7.2.1.p.2">This system allows a server to process packets with unsupported versions without retaining state.  Though either the Initial packet or the Version Negotiation packet that is sent in response could be lost, the client will send new packets until it successfully receives a response or it abandons the connection attempt.</p>
<h3 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#handle-vn" id="handle-vn">Handling Version Negotiation Packets</a>
</h3>
<p id="rfc.section.7.2.2.p.1">When the client receives a Version Negotiation packet, it first checks that the connection ID matches the connection ID the client sent.  If this check fails, the packet MUST be discarded.</p>
<p id="rfc.section.7.2.2.p.2">Once the Version Negotiation packet is determined to be valid, the client then selects an acceptable protocol version from the list provided by the server.  The client then attempts to create a connection using that version.  Though the contents of the Client Initial packet the client sends might not change in response to version negotiation, a client MUST increase the packet number it uses on every packet it sends.  Packets MUST continue to use long headers and MUST include the new negotiated protocol version.</p>
<p id="rfc.section.7.2.2.p.3">The client MUST use the long header format and include its selected version on all packets until it has 1-RTT keys and it has received a packet from the server which is not a Version Negotiation packet.</p>
<p id="rfc.section.7.2.2.p.4">A client MUST NOT change the version it uses unless it is in response to a Version Negotiation packet from the server.  Once a client receives a packet from the server which is not a Version Negotiation packet, it MUST discard other Version Negotiation packets on the same connection.  Similarly, a client MUST ignore a Version Negotiation packet if it has already received and acted on a Version Negotiation packet.</p>
<p id="rfc.section.7.2.2.p.5">A client MUST ignore a Version Negotiation packet that lists the client&#8217;s chosen version.</p>
<p id="rfc.section.7.2.2.p.6">Version negotiation packets have no cryptographic protection. The result of the negotiation MUST be revalidated as part of the cryptographic handshake (see <a href="#version-validation" class="xref">Section 7.4.4</a>).</p>
<h3 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> <a href="#using-reserved-versions" id="using-reserved-versions">Using Reserved Versions</a>
</h3>
<p id="rfc.section.7.2.3.p.1">For a server to use a new version in the future, clients must correctly handle unsupported versions. To help ensure this, a server SHOULD include a reserved version (see <a href="#versions" class="xref">Section 4</a>) while generating a Version Negotiation packet.</p>
<p id="rfc.section.7.2.3.p.2">The design of version negotiation permits a server to avoid maintaining state for packets that it rejects in this fashion. The validation of version negotiation (see <a href="#version-validation" class="xref">Section 7.4.4</a>) only validates the result of version negotiation, which is the same no matter which reserved version was sent.  A server MAY therefore send different reserved version numbers in the Version Negotiation Packet and in its transport parameters.</p>
<p id="rfc.section.7.2.3.p.3">A client MAY send a packet using a reserved version number.  This can be used to solicit a list of supported versions from a server.</p>
<h2 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#handshake" id="handshake">Cryptographic and Transport Handshake</a>
</h2>
<p id="rfc.section.7.3.p.1">QUIC relies on a combined cryptographic and transport handshake to minimize connection establishment latency.  QUIC allocates stream 0 for the cryptographic handshake.  Version 0x00000001 of QUIC uses TLS 1.3 as described in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>; a different QUIC version number could indicate that a different cryptographic handshake protocol is in use.</p>
<p id="rfc.section.7.3.p.2">QUIC provides this stream with reliable, ordered delivery of data.  In return, the cryptographic handshake provides QUIC with:</p>
<p></p>

<ul>
<li>authenticated key exchange, where  <ul>
<li>a server is always authenticated,</li>
<li>a client is optionally authenticated,</li>
<li>every connection produces distinct and unrelated keys,</li>
<li>keying material is usable for packet protection for both 0-RTT and 1-RTT packets, and</li>
<li>1-RTT keys have forward secrecy</li>
</ul>
</li>
<li>authenticated values for the transport parameters of the peer (see <a href="#transport-parameters" class="xref">Section 7.4</a>)</li>
<li>authenticated confirmation of version negotiation (see <a href="#version-validation" class="xref">Section 7.4.4</a>)</li>
<li>authenticated negotiation of an application protocol (TLS uses ALPN <a href="#RFC7301" class="xref">[RFC7301]</a> for this purpose)</li>
<li>for the server, the ability to carry data that provides assurance that the client can receive packets that are addressed with the transport address that is claimed by the client (see <a href="#address-validation" class="xref">Section 7.6</a>)</li>
</ul>
<p id="rfc.section.7.3.p.4">The initial cryptographic handshake message MUST be sent in a single packet.  Any second attempt that is triggered by address validation MUST also be sent within a single packet.  This avoids having to reassemble a message from multiple packets.  Reassembling messages requires that a server maintain state prior to establishing a connection, exposing the server to a denial of service risk.</p>
<p id="rfc.section.7.3.p.5">The first client packet of the cryptographic handshake protocol MUST fit within a 1232 octet QUIC packet payload.  This includes overheads that reduce the space available to the cryptographic handshake protocol.</p>
<p id="rfc.section.7.3.p.6">Details of how TLS is integrated with QUIC is provided in more detail in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<h2 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#transport-parameters" id="transport-parameters">Transport Parameters</a>
</h2>
<p id="rfc.section.7.4.p.1">During connection establishment, both endpoints make authenticated declarations of their transport parameters.  These declarations are made unilaterally by each endpoint.  Endpoints are required to comply with the restrictions implied by these parameters; the description of each parameter includes rules for its handling.</p>
<p id="rfc.section.7.4.p.2">The format of the transport parameters is the TransportParameters struct from <a href="#figure-transport-parameters" class="xref">Figure 6</a>.  This is described using the presentation language from Section 3 of <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>.</p>
<div id="rfc.figure.6"></div>
<div id="figure-transport-parameters"></div>
<pre>
   uint32 QuicVersion;

   enum {
      initial_max_stream_data(0),
      initial_max_data(1),
      initial_max_stream_id_bidi(2),
      idle_timeout(3),
      omit_connection_id(4),
      max_packet_size(5),
      stateless_reset_token(6),
      ack_delay_exponent(7),
      initial_max_stream_id_uni(8),
      (65535)
   } TransportParameterId;

   struct {
      TransportParameterId parameter;
      opaque value&lt;0..2^16-1&gt;;
   } TransportParameter;

   struct {
      select (Handshake.msg_type) {
         case client_hello:
            QuicVersion initial_version;

         case encrypted_extensions:
            QuicVersion negotiated_version;
            QuicVersion supported_versions&lt;4..2^8-4&gt;;
      };
      TransportParameter parameters&lt;22..2^16-1&gt;;
   } TransportParameters;
</pre>
<p class="figure">Figure 6: Definition of TransportParameters</p>
<p id="rfc.section.7.4.p.3">The <samp>extension_data</samp> field of the quic_transport_parameters extension defined in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a> contains a TransportParameters value.  TLS encoding rules are therefore used to encode the transport parameters.</p>
<p id="rfc.section.7.4.p.4">QUIC encodes transport parameters into a sequence of octets, which are then included in the cryptographic handshake.  Once the handshake completes, the transport parameters declared by the peer are available.  Each endpoint validates the value provided by its peer.  In particular, version negotiation MUST be validated (see <a href="#version-validation" class="xref">Section 7.4.4</a>) before the connection establishment is considered properly complete.</p>
<p id="rfc.section.7.4.p.5">Definitions for each of the defined transport parameters are included in <a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a>.  Any given parameter MUST appear at most once in a given transport parameters extension.  An endpoint MUST treat receipt of duplicate transport parameters as a connection error of type TRANSPORT_PARAMETER_ERROR.</p>
<h3 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#transport-parameter-definitions" id="transport-parameter-definitions">Transport Parameter Definitions</a>
</h3>
<p id="rfc.section.7.4.1.p.1">An endpoint MUST include the following parameters in its encoded TransportParameters:</p>
<p></p>

<dl>
<dt>initial_max_stream_data (0x0000):</dt>
<dd style="margin-left: 8">The initial stream maximum data parameter contains the initial value for the maximum data that can be sent on any newly created stream.  This parameter is encoded as an unsigned 32-bit integer in units of octets.  This is equivalent to an implicit MAX_STREAM_DATA frame (<a href="#frame-max-stream-data" class="xref">Section 8.7</a>) being sent on all streams immediately after opening.</dd>
<dt>initial_max_data (0x0001):</dt>
<dd style="margin-left: 8">The initial maximum data parameter contains the initial value for the maximum amount of data that can be sent on the connection.  This parameter is encoded as an unsigned 32-bit integer in units of octets.  This is equivalent to sending a MAX_DATA (<a href="#frame-max-data" class="xref">Section 8.6</a>) for the connection immediately after completing the handshake.</dd>
<dt>idle_timeout (0x0003):</dt>
<dd style="margin-left: 8">The idle timeout is a value in seconds that is encoded as an unsigned 16-bit integer.  The maximum value is 600 seconds (10 minutes).</dd>
</dl>
<p id="rfc.section.7.4.1.p.3">A server MUST include the following transport parameters:</p>
<p></p>

<dl>
<dt>stateless_reset_token (0x0006):</dt>
<dd style="margin-left: 8">The Stateless Reset Token is used in verifying a stateless reset, see <a href="#stateless-reset" class="xref">Section 7.9.4</a>.  This parameter is a sequence of 16 octets.</dd>
</dl>
<p id="rfc.section.7.4.1.p.5">A client MUST NOT include a stateless reset token.  A server MUST treat receipt of a stateless_reset_token transport parameter as a connection error of type TRANSPORT_PARAMETER_ERROR.</p>
<p id="rfc.section.7.4.1.p.6">An endpoint MAY use the following transport parameters:</p>
<p></p>

<dl>
<dt>initial_max_stream_id_bidi (0x0002):</dt>
<dd style="margin-left: 8">The initial maximum stream ID parameter contains the initial maximum stream number the peer may initiate for bidirectional streams, encoded as an unsigned 32-bit integer.  This value MUST be a valid bidirectional stream ID for a peer-initiated stream (that is, the two least significant bits are set to 0 by a server and to 1 by a client).  If an invalid value is provided, the recipient MUST generate a connection error of type TRANSPORT_PARAMETER_ERROR.  Setting this parameter is equivalent to sending a MAX_STREAM_ID (<a href="#frame-max-stream-id" class="xref">Section 8.8</a>) immediately after completing the handshake.  The maximum bidirectional stream ID is set to 0 if this parameter is absent, preventing the creation of new bidirectional streams until a MAX_STREAM_ID frame is sent.  Note that a default value of 0 does not prevent the cryptographic handshake stream (that is, stream 0) from being used.</dd>
<dt>initial_max_stream_id_uni (0x0008):</dt>
<dd style="margin-left: 8">The initial maximum stream ID parameter contains the initial maximum stream number the peer may initiate for unidirectional streams, encoded as an unsigned 32-bit integer.  The value MUST be a valid unidirectional ID for the recipient (that is, the two least significant bits are set to 2 by a server and to 3 by a client).  If an invalid value is provided, the recipient MUST generate a connection error of type TRANSPORT_PARAMETER_ERROR.  Setting this parameter is equivalent to sending a MAX_STREAM_ID (<a href="#frame-max-stream-id" class="xref">Section 8.8</a>) immediately after completing the handshake.  The maximum unidirectional stream ID is set to 0 if this parameter is absent, preventing the creation of new unidirectional streams until a MAX_STREAM_ID frame is sent.</dd>
<dt>omit_connection_id (0x0004):</dt>
<dd style="margin-left: 8">The omit connection identifier parameter indicates that packets sent to the endpoint that advertises this parameter MAY omit the connection ID in packets using short header format.  This can be used by an endpoint where it knows that source and destination IP address and port are sufficient for it to identify a connection.  This parameter is zero length.  Absence of this parameter means that the connection ID MUST be present in every packet sent to this endpoint.</dd>
<dt>max_packet_size (0x0005):</dt>
<dd style="margin-left: 8">The maximum packet size parameter places a limit on the size of packets that the endpoint is willing to receive, encoded as an unsigned 16-bit integer.  This indicates that packets larger than this limit will be dropped.  The default for this parameter is the maximum permitted UDP payload of 65527.  Values below 1200 are invalid.  This limit only applies to protected packets (<a href="#packet-protected" class="xref">Section 5.5</a>).</dd>
<dt>ack_delay_exponent (0x0007):</dt>
<dd style="margin-left: 8">An 8-bit unsigned integer value indicating an exponent used to decode the ACK Delay field in the ACK frame, see <a href="#frame-ack" class="xref">Section 8.15</a>.  If this value is absent, a default value of 3 is assumed (indicating a multiplier of 8).  The default value is also used for ACK frames that are sent in Initial, Handshake, and Retry packets.  Values above 20 are invalid.</dd>
</dl>
<h3 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> <a href="#zerortt-parameters" id="zerortt-parameters">Values of Transport Parameters for 0-RTT</a>
</h3>
<p id="rfc.section.7.4.2.p.1">A client that attempts to send 0-RTT data MUST remember the transport parameters used by the server.  The transport parameters that the server advertises during connection establishment apply to all connections that are resumed using the keying material established during that handshake.  Remembered transport parameters apply to the new connection until the handshake completes and new transport parameters from the server can be provided.</p>
<p id="rfc.section.7.4.2.p.2">A server can remember the transport parameters that it advertised, or store an integrity-protected copy of the values in the ticket and recover the information when accepting 0-RTT data.  A server uses the transport parameters in determining whether to accept 0-RTT data.</p>
<p id="rfc.section.7.4.2.p.3">A server MAY accept 0-RTT and subsequently provide different values for transport parameters for use in the new connection.  If 0-RTT data is accepted by the server, the server MUST NOT reduce any limits or alter any values that might be violated by the client with its 0-RTT data.  In particular, a server that accepts 0-RTT data MUST NOT set values for initial_max_data or initial_max_stream_data that are smaller than the remembered value of those parameters.  Similarly, a server MUST NOT reduce the value of initial_max_stream_id_bidi or initial_max_stream_id_uni.</p>
<p id="rfc.section.7.4.2.p.4">Omitting or setting a zero value for certain transport parameters can result in 0-RTT data being enabled, but not usable.  The following transport parameters SHOULD be set to non-zero values for 0-RTT: initial_max_stream_id_bidi, initial_max_stream_id_uni, initial_max_data, initial_max_stream_data.</p>
<p id="rfc.section.7.4.2.p.5">A server MUST reject 0-RTT data or even abort a handshake if the implied values for transport parameters cannot be supported.</p>
<h3 id="rfc.section.7.4.3">
<a href="#rfc.section.7.4.3">7.4.3.</a> <a href="#new-transport-parameters" id="new-transport-parameters">New Transport Parameters</a>
</h3>
<p id="rfc.section.7.4.3.p.1">New transport parameters can be used to negotiate new protocol behavior.  An endpoint MUST ignore transport parameters that it does not support.  Absence of a transport parameter therefore disables any optional protocol feature that is negotiated using the parameter.</p>
<p id="rfc.section.7.4.3.p.2">New transport parameters can be registered according to the rules in <a href="#iana-transport-parameters" class="xref">Section 14.1</a>.</p>
<h3 id="rfc.section.7.4.4">
<a href="#rfc.section.7.4.4">7.4.4.</a> <a href="#version-validation" id="version-validation">Version Negotiation Validation</a>
</h3>
<p id="rfc.section.7.4.4.p.1">Though the cryptographic handshake has integrity protection, two forms of QUIC version downgrade are possible.  In the first, an attacker replaces the QUIC version in the Initial packet.  In the second, a fake Version Negotiation packet is sent by an attacker.  To protect against these attacks, the transport parameters include three fields that encode version information.  These parameters are used to retroactively authenticate the choice of version (see <a href="#version-negotiation" class="xref">Section 7.2</a>).</p>
<p id="rfc.section.7.4.4.p.2">The cryptographic handshake provides integrity protection for the negotiated version as part of the transport parameters (see <a href="#transport-parameters" class="xref">Section 7.4</a>).  As a result, attacks on version negotiation by an attacker can be detected.</p>
<p id="rfc.section.7.4.4.p.3">The client includes the initial_version field in its transport parameters.  The initial_version is the version that the client initially attempted to use.  If the server did not send a version negotiation packet <a href="#packet-version" class="xref">Section 5.3</a>, this will be identical to the negotiated_version field in the server transport parameters.</p>
<p id="rfc.section.7.4.4.p.4">A server that processes all packets in a stateful fashion can remember how version negotiation was performed and validate the initial_version value.</p>
<p id="rfc.section.7.4.4.p.5">A server that does not maintain state for every packet it receives (i.e., a stateless server) uses a different process. If the initial_version matches the version of QUIC that is in use, a stateless server can accept the value.</p>
<p id="rfc.section.7.4.4.p.6">If the initial_version is different from the version of QUIC that is in use, a stateless server MUST check that it would have sent a version negotiation packet if it had received a packet with the indicated initial_version.  If a server would have accepted the version included in the initial_version and the value differs from the QUIC version that is in use, the server MUST terminate the connection with a VERSION_NEGOTIATION_ERROR error.</p>
<p id="rfc.section.7.4.4.p.7">The server includes both the version of QUIC that is in use and a list of the QUIC versions that the server supports.</p>
<p id="rfc.section.7.4.4.p.8">The negotiated_version field is the version that is in use.  This MUST be set by the server to the value that is on the Initial packet that it accepts (not an Initial packet that triggers a Retry or Version Negotiation packet).  A client that receives a negotiated_version that does not match the version of QUIC that is in use MUST terminate the connection with a VERSION_NEGOTIATION_ERROR error code.</p>
<p id="rfc.section.7.4.4.p.9">The server includes a list of versions that it would send in any version negotiation packet (<a href="#packet-version" class="xref">Section 5.3</a>) in the supported_versions field.  The server populates this field even if it did not send a version negotiation packet.</p>
<p id="rfc.section.7.4.4.p.10">The client validates that the negotiated_version is included in the supported_versions list and - if version negotiation was performed - that it would have selected the negotiated version.  A client MUST terminate the connection with a VERSION_NEGOTIATION_ERROR error code if the current QUIC version is not listed in the supported_versions list.  A client MUST terminate with a VERSION_NEGOTIATION_ERROR error code if version negotiation occurred but it would have selected a different version based on the value of the supported_versions list.</p>
<p id="rfc.section.7.4.4.p.11">When an endpoint accepts multiple QUIC versions, it can potentially interpret transport parameters as they are defined by any of the QUIC versions it supports.  The version field in the QUIC packet header is authenticated using transport parameters.  The position and the format of the version fields in transport parameters MUST either be identical across different QUIC versions, or be unambiguously different to ensure no confusion about their interpretation.  One way that a new format could be introduced is to define a TLS extension with a different codepoint.</p>
<h2 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#stateless-retry" id="stateless-retry">Stateless Retries</a>
</h2>
<p id="rfc.section.7.5.p.1">A server can process an initial cryptographic handshake messages from a client without committing any state. This allows a server to perform address validation (<a href="#address-validation" class="xref">Section 7.6</a>, or to defer connection establishment costs.</p>
<p id="rfc.section.7.5.p.2">A server that generates a response to an initial packet without retaining connection state MUST use the Retry packet (<a href="#packet-retry" class="xref">Section 5.4.2</a>).  This packet causes a client to reset its transport state and to continue the connection attempt with new connection state while maintaining the state of the cryptographic handshake.</p>
<p id="rfc.section.7.5.p.3">A server MUST NOT send multiple Retry packets in response to a client handshake packet.  Thus, any cryptographic handshake message that is sent MUST fit within a single packet.</p>
<p id="rfc.section.7.5.p.4">In TLS, the Retry packet type is used to carry the HelloRetryRequest message.</p>
<h2 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#address-validation" id="address-validation">Proof of Source Address Ownership</a>
</h2>
<p id="rfc.section.7.6.p.1">Transport protocols commonly spend a round trip checking that a client owns the transport address (IP and port) that it claims.  Verifying that a client can receive packets sent to its claimed transport address protects against spoofing of this information by malicious clients.</p>
<p id="rfc.section.7.6.p.2">This technique is used primarily to avoid QUIC from being used for traffic amplification attack.  In such an attack, a packet is sent to a server with spoofed source address information that identifies a victim.  If a server generates more or larger packets in response to that packet, the attacker can use the server to send more data toward the victim than it would be able to send on its own.</p>
<p id="rfc.section.7.6.p.3">Several methods are used in QUIC to mitigate this attack.  Firstly, the initial handshake packet is padded to at least 1200 octets.  This allows a server to send a similar amount of data without risking causing an amplification attack toward an unproven remote address.</p>
<p id="rfc.section.7.6.p.4">A server eventually confirms that a client has received its messages when the cryptographic handshake successfully completes.  This might be insufficient, either because the server wishes to avoid the computational cost of completing the handshake, or it might be that the size of the packets that are sent during the handshake is too large.  This is especially important for 0-RTT, where the server might wish to provide application data traffic - such as a response to a request - in response to the data carried in the early data from the client.</p>
<p id="rfc.section.7.6.p.5">To send additional data prior to completing the cryptographic handshake, the server then needs to validate that the client owns the address that it claims.</p>
<p id="rfc.section.7.6.p.6">Source address validation is therefore performed during the establishment of a connection.  TLS provides the tools that support the feature, but basic validation is performed by the core transport protocol.</p>
<p id="rfc.section.7.6.p.7">A different type of source address validation is performed after a connection migration, see <a href="#migrate-validate" class="xref">Section 7.7.2</a>.</p>
<h3 id="rfc.section.7.6.1">
<a href="#rfc.section.7.6.1">7.6.1.</a> <a href="#client-address-validation-procedure" id="client-address-validation-procedure">Client Address Validation Procedure</a>
</h3>
<p id="rfc.section.7.6.1.p.1">QUIC uses token-based address validation.  Any time the server wishes to validate a client address, it provides the client with a token.  As long as the token cannot be easily guessed (see <a href="#token-integrity" class="xref">Section 7.6.3</a>), if the client is able to return that token, it proves to the server that it received the token.</p>
<p id="rfc.section.7.6.1.p.2">During the processing of the cryptographic handshake messages from a client, TLS will request that QUIC make a decision about whether to proceed based on the information it has.  TLS will provide QUIC with any token that was provided by the client.  For an initial packet, QUIC can decide to abort the connection, allow it to proceed, or request address validation.</p>
<p id="rfc.section.7.6.1.p.3">If QUIC decides to request address validation, it provides the cryptographic handshake with a token.  The contents of this token are consumed by the server that generates the token, so there is no need for a single well-defined format.  A token could include information about the claimed client address (IP and port), a timestamp, and any other supplementary information the server will need to validate the token in the future.</p>
<p id="rfc.section.7.6.1.p.4">The cryptographic handshake is responsible for enacting validation by sending the address validation token to the client.  A legitimate client will include a copy of the token when it attempts to continue the handshake.  The cryptographic handshake extracts the token then asks QUIC a second time whether the token is acceptable.  In response, QUIC can either abort the connection or permit it to proceed.</p>
<p id="rfc.section.7.6.1.p.5">A connection MAY be accepted without address validation - or with only limited validation - but a server SHOULD limit the data it sends toward an unvalidated address.  Successful completion of the cryptographic handshake implicitly provides proof that the client has received packets from the server.</p>
<h3 id="rfc.section.7.6.2">
<a href="#rfc.section.7.6.2">7.6.2.</a> <a href="#address-validation-on-session-resumption" id="address-validation-on-session-resumption">Address Validation on Session Resumption</a>
</h3>
<p id="rfc.section.7.6.2.p.1">A server MAY provide clients with an address validation token during one connection that can be used on a subsequent connection.  Address validation is especially important with 0-RTT because a server potentially sends a significant amount of data to a client in response to 0-RTT data.</p>
<p id="rfc.section.7.6.2.p.2">A different type of token is needed when resuming.  Unlike the token that is created during a handshake, there might be some time between when the token is created and when the token is subsequently used.  Thus, a resumption token SHOULD include an expiration time.  It is also unlikely that the client port number is the same on two different connections; validating the port is therefore unlikely to be successful.</p>
<p id="rfc.section.7.6.2.p.3">This token can be provided to the cryptographic handshake immediately after establishing a connection.  QUIC might also generate an updated token if significant time passes or the client address changes for any reason (see <a href="#migration" class="xref">Section 7.7</a>).  The cryptographic handshake is responsible for providing the client with the token.  In TLS the token is included in the ticket that is used for resumption and 0-RTT, which is carried in a NewSessionTicket message.</p>
<h3 id="rfc.section.7.6.3">
<a href="#rfc.section.7.6.3">7.6.3.</a> <a href="#token-integrity" id="token-integrity">Address Validation Token Integrity</a>
</h3>
<p id="rfc.section.7.6.3.p.1">An address validation token MUST be difficult to guess.  Including a large enough random value in the token would be sufficient, but this depends on the server remembering the value it sends to clients.</p>
<p id="rfc.section.7.6.3.p.2">A token-based scheme allows the server to offload any state associated with validation to the client.  For this design to work, the token MUST be covered by integrity protection against modification or falsification by clients.  Without integrity protection, malicious clients could generate or guess values for tokens that would be accepted by the server.  Only the server requires access to the integrity protection key for tokens.</p>
<p id="rfc.section.7.6.3.p.3">In TLS the address validation token is often bundled with the information that TLS requires, such as the resumption secret.  In this case, adding integrity protection can be delegated to the cryptographic handshake protocol, avoiding redundant protection.  If integrity protection is delegated to the cryptographic handshake, an integrity failure will result in immediate cryptographic handshake failure.  If integrity protection is performed by QUIC, QUIC MUST abort the connection if the integrity check fails with a PROTOCOL_VIOLATION error code.</p>
<h2 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> <a href="#migration" id="migration">Connection Migration</a>
</h2>
<p id="rfc.section.7.7.p.1">QUIC connections are identified by their 64-bit Connection ID.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and/or port, such as those caused by client or server migrating to a new network.  Connection migration allows a client to retain any shared state with a connection when they move networks.  This includes state that can be hard to recover such as outstanding requests, which might otherwise be lost with no easy way to retry them.</p>
<p id="rfc.section.7.7.p.2">An endpoint that receives packets that contain a source IP address and port that has not yet been used can start sending new packets with those as a destination IP address and port.  Packets exchanged between endpoints can then follow the new path.</p>
<p id="rfc.section.7.7.p.3">Due to variations in path latency or packet reordering, packets from different source addresses might be reordered.  The packet with the highest packet number MUST be used to determine which path to use.  Endpoints also need to be prepared to receive packets from an older source address.</p>
<p id="rfc.section.7.7.p.4">An endpoint MUST validate that its peer can receive packets at the new address before sending any significant quantity of data to that address, or it risks being used for denial of service.  See <a href="#migrate-validate" class="xref">Section 7.7.2</a> for details.</p>
<h3 id="rfc.section.7.7.1">
<a href="#rfc.section.7.7.1">7.7.1.</a> <a href="#migration-linkability" id="migration-linkability">Privacy Implications of Connection Migration</a>
</h3>
<p id="rfc.section.7.7.1.p.1">Using a stable connection ID on multiple network paths allows a passive observer to correlate activity between those paths.  A client that moves between networks might not wish to have their activity correlated by any entity other than a server. The NEW_CONNECTION_ID message can be sent by a server to provide an unlinkable connection ID for use in case the client wishes to explicitly break linkability between two points of network attachment.</p>
<p id="rfc.section.7.7.1.p.2">A client might need to send packets on multiple networks without receiving any response from the server.  To ensure that the client is not linkable across each of these changes, a new connection ID and packet number gap are needed for each network.  To support this, a server sends multiple NEW_CONNECTION_ID messages.  Each NEW_CONNECTION_ID is marked with a sequence number.  Connection IDs MUST be used in the order in which they are numbered.</p>
<p id="rfc.section.7.7.1.p.3">A client which wishes to break linkability upon changing networks MUST use the connection ID provided by the server as well as incrementing the packet sequence number by an externally unpredictable value computed as described in <a href="#packet-number-gap" class="xref">Section 7.7.1.1</a>. Packet number gaps are cumulative.  A client might skip connection IDs, but it MUST ensure that it applies the associated packet number gaps for connection IDs that it skips in addition to the packet number gap associated with the connection ID that it does use.</p>
<p id="rfc.section.7.7.1.p.4">A server that receives a packet that is marked with a new connection ID recovers the packet number by adding the cumulative packet number gap to its expected packet number.  A server SHOULD discard packets that contain a smaller gap than it advertised.</p>
<p id="rfc.section.7.7.1.p.5">For instance, a server might provide a packet number gap of 7 associated with a new connection ID.  If the server received packet 10 using the previous connection ID, it should expect packets on the new connection ID to start at 18.  A packet with the new connection ID and a packet number of 17 is discarded as being in error.</p>
<h4 id="rfc.section.7.7.1.1">
<a href="#rfc.section.7.7.1.1">7.7.1.1.</a> <a href="#packet-number-gap" id="packet-number-gap">Packet Number Gap</a>
</h4>
<p id="rfc.section.7.7.1.1.p.1">In order to avoid linkage, the packet number gap MUST be externally indistinguishable from random. The packet number gap for a connection ID with sequence number is computed by encoding the sequence number as a 32-bit integer in big-endian format, and then computing:</p>
<pre>
Gap = HKDF-Expand-Label(packet_number_secret,
                        "QUIC packet sequence gap", sequence, 4)
</pre>
<p id="rfc.section.7.7.1.1.p.2">The output of HKDF-Expand-Label is interpreted as a big-endian number. &#8220;packet_number_secret&#8221; is derived from the TLS key exchange, as described in Section 5.6 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.</p>
<h3 id="rfc.section.7.7.2">
<a href="#rfc.section.7.7.2">7.7.2.</a> <a href="#migrate-validate" id="migrate-validate">Address Validation for Migrated Connections</a>
</h3>
<p id="rfc.section.7.7.2.p.1">An endpoint that receives a packet from a new remote IP address and port (or just a new remote port) on packets from its peer is likely seeing a connection migration at the peer.</p>
<p id="rfc.section.7.7.2.p.2">However, it is also possible that the peer is spoofing its source address in order to cause the endpoint to send excessive amounts of data to an unwilling host.  If the endpoint sends significantly more data than the peer, connection migration might be used to amplify the volume of data that an attacker can generate toward a victim.</p>
<p id="rfc.section.7.7.2.p.3">Thus, when seeing a new remote transport address, an endpoint MUST verify that its peer can receive and respond to packets at that new address.  By providing copies of the data that it receives, the peer proves that it is receiving packets at the new address and consents to receive data.</p>
<p id="rfc.section.7.7.2.p.4">Prior to validating the new remote address, and endpoint MUST limit the amount of data and packets that it sends to its peer.  At a minimum, this needs to consider the possibility that packets are sent without congestion feedback.</p>
<p id="rfc.section.7.7.2.p.5">Once a connection is established, address validation is relatively simple (see <a href="#address-validation" class="xref">Section 7.6</a> for the process that is used during the handshake).  An endpoint validates a remote address by sending a PATH_CHALLENGE frame containing a payload that is hard to guess.  This frame MUST be sent in a packet that is sent to the new address.  Once a PATH_RESPONSE frame containing the same payload is received, the address is considered to be valid.</p>
<p id="rfc.section.7.7.2.p.6">The new address is not considered valid until a PATH_RESPONSE frame containing the same payload is received, even if the packet containing the PATH_CHALLENGE frame is acknowledged.</p>
<p id="rfc.section.7.7.2.p.7">The PATH_RESPONSE frame can use any path on its return.</p>
<p id="rfc.section.7.7.2.p.8">An endpoint MAY send multiple PATH_CHALLENGE frames to handle packet loss or to make additional measurements on a new network path.</p>
<p id="rfc.section.7.7.2.p.9">An endpoint MUST use fresh random data in every PATH_CHALLENGE frame so that it can associate the peer&#8217;s response with the causative PATH_CHALLENGE.</p>
<p id="rfc.section.7.7.2.p.10">If the PATH_CHALLENGE frame is determined to be lost, a new PATH_CHALLENGE frame SHOULD be generated.  This PATH_CHALLENGE frame MUST include new data that is similarly difficult to guess.</p>
<p id="rfc.section.7.7.2.p.11">If validation of the new remote address fails, after allowing enough time for recovering from possible loss of packets carrying PATH_CHALLENGE and PATH_RESPONSE frames, the endpoint MUST terminate the connection.  When setting this timer, implementations are cautioned that the new path could have a longer round trip time than the original.  The endpoint MUST NOT send a CONNECTION_CLOSE frame in this case; it has to assume that the remote peer cannot want to receive any more packets.</p>
<p id="rfc.section.7.7.2.p.12">If the remote address is validated successfully, the endpoint MAY increase the rate that it sends on the new path using the state from the previous path.  The capacity available on the new path might not be the same as the old path.  An endpoint MUST NOT restore its send rate unless it is reasonably sure that the path is the same as the previous path.  For instance, a change in only port number is likely indicative of a rebinding in a middlebox and not a complete change in path.  This determination likely depends on heuristics, which could be imperfect; if the new path capacity is significantly reduced, ultimately this relies on the congestion controller responding to congestion signals and reduce send rates appropriately.</p>
<p id="rfc.section.7.7.2.p.13">After verifying an address, the endpoint SHOULD update any address validation tokens (<a href="#address-validation" class="xref">Section 7.6</a>) that it has issued to its peer if those are no longer valid based on the changed address.</p>
<p id="rfc.section.7.7.2.p.14">Address validation using the PATH_CHALLENGE frame MAY be used at any time by either peer.  For instance, an endpoint might check that a peer is still in possession of its address after a period of quiescence.</p>
<p id="rfc.section.7.7.2.p.15">Upon seeing a connection migration, an endpoint that sees a new address MUST abandon any address validation it is performing with other addresses on the expectation that the validation is likely to fail.  Abandoning address validation primarily means not closing the connection when a PATH_RESPONSE frame is not received, but it could also mean ceasing subsequent transmissions of the PATH_CHALLENGE frame.  An endpoint MUST ignore any subsequently received PATH_RESPONSE frames from that address.</p>
<h2 id="rfc.section.7.8">
<a href="#rfc.section.7.8">7.8.</a> <a href="#spurious-connection-migrations" id="spurious-connection-migrations">Spurious Connection Migrations</a>
</h2>
<p id="rfc.section.7.8.p.1">A connection migration could be triggered by an attacker that is able to capture and forward a packet such that it arrives before the legitimate copy of that packet.  Such a packet will appear to be a legitimate connection migration and the legitimate copy will be dropped as a duplicate.</p>
<p id="rfc.section.7.8.p.2">After a spurious migration, validation of the source address will fail because the entity at the source address does not have the necessary cryptographic keys to read or respond to the PATH_CHALLENGE frame that is sent to it, even if it wanted to.  Such a spurious connection migration could result in the connection being dropped when the source address validation fails.  This grants an attacker the ability to terminate the connection.</p>
<p id="rfc.section.7.8.p.3">Receipt of packets with higher packet numbers from the legitimate address will trigger another connection migration.  This will cause the validation of the address of the spurious migration to be abandoned.</p>
<p id="rfc.section.7.8.p.4">To ensure that a peer sends packets from the legitimate address before the validation of the new address can fail, an endpoint SHOULD attempt to validate the old remote address before attempting to validate the new address.  If the connection migration is spurious, then the legitimate address will be used to respond and the connection will migrate back to the old address.</p>
<p id="rfc.section.7.8.p.5">As with any address validation, packets containing a PATH_CHALLENGE frame validating an address MUST be sent to the address being validated.  Consequently, during a migration of a peer, an endpoint could be sending to multiple remote addresses.</p>
<p id="rfc.section.7.8.p.6">An endpoint MAY abandon address validation for an address that it considers to be already valid.  That is, if successive connection migrations occur in quick succession with the final remote address being identical to the initial remote address, the endpoint MAY abandon address validation for that address.</p>
<h2 id="rfc.section.7.9">
<a href="#rfc.section.7.9">7.9.</a> <a href="#termination" id="termination">Connection Termination</a>
</h2>
<p id="rfc.section.7.9.p.1">Connections should remain open until they become idle for a pre-negotiated period of time.  A QUIC connection, once established, can be terminated in one of three ways:</p>
<p></p>

<ul>
<li>idle timeout (<a href="#idle-timeout" class="xref">Section 7.9.2</a>)</li>
<li>immediate close (<a href="#immediate-close" class="xref">Section 7.9.3</a>)</li>
<li>stateless reset (<a href="#stateless-reset" class="xref">Section 7.9.4</a>)</li>
</ul>
<h3 id="rfc.section.7.9.1">
<a href="#rfc.section.7.9.1">7.9.1.</a> <a href="#draining" id="draining">Closing and Draining Connection States</a>
</h3>
<p id="rfc.section.7.9.1.p.1">The closing and draining connection states exist to ensure that connections close cleanly and that delayed or reordered packets are properly discarded.  These states SHOULD persist for three times the current Retransmission Timeout (RTO) interval as defined in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<p id="rfc.section.7.9.1.p.2">An endpoint enters a closing period after initiating an immediate close (<a href="#immediate-close" class="xref">Section 7.9.3</a>) and optionally after an idle timeout (<a href="#idle-timeout" class="xref">Section 7.9.2</a>).  While closing, an endpoint MUST NOT send packets unless they contain a CONNECTION_CLOSE or APPLICATION_CLOSE frame (see <a href="#immediate-close" class="xref">Section 7.9.3</a> for details).</p>
<p id="rfc.section.7.9.1.p.3">In the closing state, only a packet containing a closing frame can be sent.  An endpoint retains only enough information to generate a packet containing a closing frame and to identify packets as belonging to the connection.  The connection ID and QUIC version is sufficient information to identify packets for a closing connection; an endpoint can discard all other connection state.  An endpoint MAY retain packet protection keys for incoming packets to allow it to read and process a closing frame.</p>
<p id="rfc.section.7.9.1.p.4">The draining state is entered once an endpoint receives a signal that its peer is closing or draining.  While otherwise identical to the closing state, an endpoint in the draining state MUST NOT send any packets.  Retaining packet protection keys is unnecessary once a connection is in the draining state.</p>
<p id="rfc.section.7.9.1.p.5">An endpoint MAY transition from the closing period to the draining period if it can confirm that its peer is also closing or draining.  Receiving a closing frame is sufficient confirmation, as is receiving a stateless reset.  The draining period SHOULD end when the closing period would have ended.  In other words, the endpoint can use the same end time, but cease retransmission of the closing packet.</p>
<p id="rfc.section.7.9.1.p.6">Disposing of connection state prior to the end of the closing or draining period could cause delayed or reordered packets to be handled poorly.  Endpoints that have some alternative means to ensure that late-arriving packets on the connection do not create QUIC state, such as those that are able to close the UDP socket, MAY use an abbreviated draining period which can allow for faster resource recovery.  Servers that retain an open socket for accepting new connections SHOULD NOT exit the closing or draining period early.</p>
<p id="rfc.section.7.9.1.p.7">Once the closing or draining period has ended, an endpoint SHOULD discard all connection state.  This results in new packets on the connection being handled generically.  For instance, an endpoint MAY send a stateless reset in response to any further incoming packets.</p>
<p id="rfc.section.7.9.1.p.8">The draining and closing periods do not apply when a stateless reset (<a href="#stateless-reset" class="xref">Section 7.9.4</a>) is sent.</p>
<p id="rfc.section.7.9.1.p.9">An endpoint is not expected to handle key updates when it is closing or draining.  A key update might prevent the endpoint from moving from the closing state to draining, but it otherwise has no impact.</p>
<p id="rfc.section.7.9.1.p.10">An endpoint could receive packets from a new source address, indicating a connection migration (<a href="#migration" class="xref">Section 7.7</a>), while in the closing period. An endpoint in the closing state MUST strictly limit the number of packets it sends to this new address as though the address were not validated (see <a href="#migrate-validate" class="xref">Section 7.7.2</a>).  A server in the closing state MAY instead choose to discard packets received from a new source address.</p>
<h3 id="rfc.section.7.9.2">
<a href="#rfc.section.7.9.2">7.9.2.</a> <a href="#idle-timeout" id="idle-timeout">Idle Timeout</a>
</h3>
<p id="rfc.section.7.9.2.p.1">A connection that remains idle for longer than the idle timeout (see <a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a>) is closed.  A connection enters the draining state when the idle timeout expires.</p>
<p id="rfc.section.7.9.2.p.2">The time at which an idle timeout takes effect won&#8217;t be perfectly synchronized on both endpoints.  An endpoint that sends packets near the end of an idle period could have those packets discarded if its peer enters the draining state before the packet is received.</p>
<h3 id="rfc.section.7.9.3">
<a href="#rfc.section.7.9.3">7.9.3.</a> <a href="#immediate-close" id="immediate-close">Immediate Close</a>
</h3>
<p id="rfc.section.7.9.3.p.1">An endpoint sends a closing frame, either CONNECTION_CLOSE or APPLICATION_CLOSE, to terminate the connection immediately.  Either closing frame causes all streams to immediately become closed; open streams can be assumed to be implicitly reset.</p>
<p id="rfc.section.7.9.3.p.2">After sending a closing frame, endpoints immediately enter the closing state.  During the closing period, an endpoint that sends a closing frame SHOULD respond to any packet that it receives with another packet containing a closing frame.  To minimize the state that an endpoint maintains for a closing connection, endpoints MAY send the exact same packet.  However, endpoints SHOULD limit the number of packets they generate containing a closing frame.  For instance, an endpoint could progressively increase the number of packets that it receives before sending additional packets or increase the time between packets.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">Allowing retransmission of a packet contradicts other advice in this document that recommends the creation of new packet numbers for every packet.  Sending new packet numbers is primarily of advantage to loss recovery and congestion control, which are not expected to be relevant for a closed connection.  Retransmitting the final packet requires less state.</dd>
</dl>
<p id="rfc.section.7.9.3.p.4">After receiving a closing frame, endpoints enter the draining state.  An endpoint that receives a closing frame MAY send a single packet containing a closing frame before entering the draining state, using a CONNECTION_CLOSE frame and a NO_ERROR code if appropriate.  An endpoint MUST NOT send further packets, which could result in a constant exchange of closing frames until the closing period on either peer ended.</p>
<p id="rfc.section.7.9.3.p.5">An immediate close can be used after an application protocol has arranged to close a connection.  This might be after the application protocols negotiates a graceful shutdown.  The application protocol exchanges whatever messages that are needed to cause both endpoints to agree to close the connection, after which the application requests that the connection be closed.  The application protocol can use an APPLICATION_CLOSE message with an appropriate error code to signal closure.</p>
<h3 id="rfc.section.7.9.4">
<a href="#rfc.section.7.9.4">7.9.4.</a> <a href="#stateless-reset" id="stateless-reset">Stateless Reset</a>
</h3>
<p id="rfc.section.7.9.4.p.1">A stateless reset is provided as an option of last resort for a server that does not have access to the state of a connection.  A server crash or outage might result in clients continuing to send data to a server that is unable to properly continue the connection.  A server that wishes to communicate a fatal connection error MUST use a closing frame if it has sufficient state to do so.</p>
<p id="rfc.section.7.9.4.p.2">To support this process, the server sends a stateless_reset_token value during the handshake in the transport parameters.  This value is protected by encryption, so only client and server know this value.</p>
<p id="rfc.section.7.9.4.p.3">A server that receives packets that it cannot process sends a packet in the following layout:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|0|C|K|Type (5) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                     [Connection ID (64)]                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Packet Number (8/16/32)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Random Octets (*)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                   Stateless Reset Token (128)                 +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.7.9.4.p.4">A server copies the connection ID field from the packet that triggers the stateless reset.  A server omits the connection ID if explicitly configured to do so, or if the client packet did not include a connection ID.</p>
<p id="rfc.section.7.9.4.p.5">The Packet Number field is set to a randomized value.  The server SHOULD send a packet with a short header and a type of 0x1F.  This produces the shortest possible packet number encoding, which minimizes the perceived gap between the last packet that the server sent and this packet.  A server MAY use a different short header type, indicating a different packet number length, but a longer packet number encoding might allow this message to be identified as a stateless reset more easily using heuristics.</p>
<p id="rfc.section.7.9.4.p.6">After the Packet Number, the server pads the message with an arbitrary number of octets containing random values.</p>
<p id="rfc.section.7.9.4.p.7">Finally, the last 16 octets of the packet are set to the value of the Stateless Reset Token.</p>
<p id="rfc.section.7.9.4.p.8">This design ensures that a stateless reset packet is - to the extent possible - indistinguishable from a regular packet.</p>
<p id="rfc.section.7.9.4.p.9">A stateless reset is not appropriate for signaling error conditions.  An endpoint that wishes to communicate a fatal connection error MUST use a CONNECTION_CLOSE or APPLICATION_CLOSE frame if it has sufficient state to do so.</p>
<p id="rfc.section.7.9.4.p.10">This stateless reset design is specific to QUIC version 1.  A server that supports multiple versions of QUIC needs to generate a stateless reset that will be accepted by clients that support any version that the server might support (or might have supported prior to losing state).  Designers of new versions of QUIC need to be aware of this and either reuse this design, or use a portion of the packet other than the last 16 octets for carrying data.</p>
<h4 id="rfc.section.7.9.4.1">
<a href="#rfc.section.7.9.4.1">7.9.4.1.</a> <a href="#detecting-a-stateless-reset" id="detecting-a-stateless-reset">Detecting a Stateless Reset</a>
</h4>
<p id="rfc.section.7.9.4.1.p.1">A client detects a potential stateless reset when a packet with a short header either cannot be decrypted or is marked as a duplicate packet.  The client then compares the last 16 octets of the packet with the Stateless Reset Token provided by the server in its transport parameters.  If these values are identical, the client MUST enter the draining period and not send any further packets on this connection.  If the comparison fails, the packet can be discarded.</p>
<h4 id="rfc.section.7.9.4.2">
<a href="#rfc.section.7.9.4.2">7.9.4.2.</a> <a href="#calculating-a-stateless-reset-token" id="calculating-a-stateless-reset-token">Calculating a Stateless Reset Token</a>
</h4>
<p id="rfc.section.7.9.4.2.p.1">The stateless reset token MUST be difficult to guess.  In order to create a Stateless Reset Token, a server could randomly generate <a href="#RFC4086" class="xref">[RFC4086]</a> a secret for every connection that it creates.  However, this presents a coordination problem when there are multiple servers in a cluster or a storage problem for a server that might lose state.  Stateless reset specifically exists to handle the case where state is lost, so this approach is suboptimal.</p>
<p id="rfc.section.7.9.4.2.p.2">A single static key can be used across all connections to the same endpoint by generating the proof using a second iteration of a preimage-resistant function that takes three inputs: the static key, a the connection ID for the connection (see <a href="#connection-id" class="xref">Section 5.6</a>), and an identifier for the server instance.  A server could use HMAC <a href="#RFC2104" class="xref">[RFC2104]</a> (for example, HMAC(static_key, server_id || connection_id)) or HKDF <a href="#RFC5869" class="xref">[RFC5869]</a> (for example, using the static key as input keying material, with server and connection identifiers as salt).  The output of this function is truncated to 16 octets to produce the Stateless Reset Token for that connection.</p>
<p id="rfc.section.7.9.4.2.p.3">A server that loses state can use the same method to generate a valid Stateless Reset Secret.  The connection ID comes from the packet that the server receives.</p>
<p id="rfc.section.7.9.4.2.p.4">This design relies on the client always sending a connection ID in its packets so that the server can use the connection ID from a packet to reset the connection.  A server that uses this design cannot allow clients to omit a connection ID (that is, it cannot use the truncate_connection_id transport parameter <a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a>).</p>
<p id="rfc.section.7.9.4.2.p.5">Revealing the Stateless Reset Token allows any entity to terminate the connection, so a value can only be used once.  This method for choosing the Stateless Reset Token means that the combination of server instance, connection ID, and static key cannot occur for another connection.  A connection ID from a connection that is reset by revealing the Stateless Reset Token cannot be reused for new connections at the same server without first changing to use a different static key or server identifier.</p>
<p id="rfc.section.7.9.4.2.p.6">Note that Stateless Reset messages do not have any cryptographic protection.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#frame-types-and-formats" id="frame-types-and-formats">Frame Types and Formats</a>
</h1>
<p id="rfc.section.8.p.1">As described in <a href="#frames" class="xref">Section 6</a>, packets contain one or more frames. This section describes the format and semantics of the core QUIC frame types.</p>
<h2 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#integer-encoding" id="integer-encoding">Variable-Length Integer Encoding</a>
</h2>
<p id="rfc.section.8.1.p.1">QUIC frames use a common variable-length encoding for all non-negative integer values.  This encoding ensures that smaller integer values need fewer octets to encode.</p>
<p id="rfc.section.8.1.p.2">The QUIC variable-length integer encoding reserves the two most significant bits of the first octet to encode the base 2 logarithm of the integer encoding length in octets.  The integer value is encoded on the remaining bits, in network byte order.</p>
<p id="rfc.section.8.1.p.3">This means that integers are encoded on 1, 2, 4, or 8 octets and can encode 6, 14, 30, or 62 bit values respectively.  <a href="#integer-summary" class="xref">Table 4</a> summarizes the encoding properties.</p>
<div id="rfc.table.4"></div>
<div id="integer-summary"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Summary of Integer Encodings</caption>
<thead><tr>
<th class="left">2Bit</th>
<th class="left">Length</th>
<th class="left">Usable Bits</th>
<th class="left">Range</th>
</tr></thead>
<tbody>
<tr>
<td class="left">00</td>
<td class="left">1</td>
<td class="left">6</td>
<td class="left">0-63</td>
</tr>
<tr>
<td class="left">01</td>
<td class="left">2</td>
<td class="left">14</td>
<td class="left">0-16383</td>
</tr>
<tr>
<td class="left">10</td>
<td class="left">4</td>
<td class="left">30</td>
<td class="left">0-1073741823</td>
</tr>
<tr>
<td class="left">11</td>
<td class="left">8</td>
<td class="left">62</td>
<td class="left">0-4611686018427387903</td>
</tr>
</tbody>
</table>
<p id="rfc.section.8.1.p.4">For example, the eight octet sequence c2 19 7c 5e ff 14 e8 8c (in hexadecimal) decodes to the decimal value 151288809941952652; the four octet sequence 9d 7f 3e 7d decodes to 494878333; the two octet sequence 7b bd decodes to 15293; and the single octet 25 decodes to 37 (as does the two octet sequence 40 25).</p>
<p id="rfc.section.8.1.p.5">Error codes (<a href="#error-codes" class="xref">Section 12.3</a>) are described using integers, but do not use this encoding.</p>
<h2 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#frame-padding" id="frame-padding">PADDING Frame</a>
</h2>
<p id="rfc.section.8.2.p.1">The PADDING frame (type=0x00) has no semantic value.  PADDING frames can be used to increase the size of a packet.  Padding can be used to increase an initial client packet to the minimum required size, or to provide protection against traffic analysis for protected packets.</p>
<p id="rfc.section.8.2.p.2">A PADDING frame has no content.  That is, a PADDING frame consists of the single octet that identifies the frame as a PADDING frame.</p>
<h2 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#frame-rst-stream" id="frame-rst-stream">RST_STREAM Frame</a>
</h2>
<p id="rfc.section.8.3.p.1">An endpoint may use a RST_STREAM frame (type=0x01) to abruptly terminate a stream.</p>
<p id="rfc.section.8.3.p.2">After sending a RST_STREAM, an endpoint ceases transmission and retransmission of STREAM frames on the identified stream.  A receiver of RST_STREAM can discard any data that it already received on that stream.</p>
<p id="rfc.section.8.3.p.3">An endpoint that receives a RST_STREAM frame for a send-only stream MUST terminate the connection with error PROTOCOL_VIOLATION.</p>
<p id="rfc.section.8.3.p.4">The RST_STREAM frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Application Error Code (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Final Offset (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.3.p.5">The fields are:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer encoding of the Stream ID of the stream being terminated.</dd>
<dt>Application Protocol Error Code:</dt>
<dd style="margin-left: 8">A 16-bit application protocol error code (see <a href="#app-error-codes" class="xref">Section 12.4</a>) which indicates why the stream is being closed.</dd>
<dt>Final Offset:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the absolute byte offset of the end of data written on this stream by the RST_STREAM sender.</dd>
</dl>
<h2 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#frame-connection-close" id="frame-connection-close">CONNECTION_CLOSE frame</a>
</h2>
<p id="rfc.section.8.4.p.1">An endpoint sends a CONNECTION_CLOSE frame (type=0x02) to notify its peer that the connection is being closed.  CONNECTION_CLOSE is used to signal errors at the QUIC layer, or the absence of errors (with the NO_ERROR code).</p>
<p id="rfc.section.8.4.p.2">If there are open streams that haven&#8217;t been explicitly closed, they are implicitly closed when the connection is closed.</p>
<p id="rfc.section.8.4.p.3">The CONNECTION_CLOSE frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Error Code (16)     |   Reason Phrase Length (i)  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Reason Phrase (*)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.4.p.4">The fields of a CONNECTION_CLOSE frame are as follows:</p>
<p></p>

<dl>
<dt>Error Code:</dt>
<dd style="margin-left: 8">A 16-bit error code which indicates the reason for closing this connection.  CONNECTION_CLOSE uses codes from the space defined in <a href="#error-codes" class="xref">Section 12.3</a> (APPLICATION_CLOSE uses codes from the application protocol error code space, see <a href="#app-error-codes" class="xref">Section 12.4</a>).</dd>
<dt>Reason Phrase Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the reason phrase in bytes.  Note that a CONNECTION_CLOSE frame cannot be split between packets, so in practice any limits on packet size will also limit the space available for a reason phrase.</dd>
<dt>Reason Phrase:</dt>
<dd style="margin-left: 8">A human-readable explanation for why the connection was closed.  This can be zero length if the sender chooses to not give details beyond the Error Code.  This SHOULD be a UTF-8 encoded string <a href="#RFC3629" class="xref">[RFC3629]</a>.</dd>
</dl>
<h2 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#frame-application-close" id="frame-application-close">APPLICATION_CLOSE frame</a>
</h2>
<p id="rfc.section.8.5.p.1">An APPLICATION_CLOSE frame (type=0x03) uses the same format as the CONNECTION_CLOSE frame (<a href="#frame-connection-close" class="xref">Section 8.4</a>), except that it uses error codes from the application protocol error code space (<a href="#app-error-codes" class="xref">Section 12.4</a>) instead of the transport error code space.</p>
<p id="rfc.section.8.5.p.2">Other than the error code space, the format and semantics of the APPLICATION_CLOSE frame are identical to the CONNECTION_CLOSE frame.</p>
<h2 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> <a href="#frame-max-data" id="frame-max-data">MAX_DATA Frame</a>
</h2>
<p id="rfc.section.8.6.p.1">The MAX_DATA frame (type=0x04) is used in flow control to inform the peer of the maximum amount of data that can be sent on the connection as a whole.</p>
<p id="rfc.section.8.6.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Maximum Data (i)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.6.p.3">The fields in the MAX_DATA frame are as follows:</p>
<p></p>

<dl>
<dt>Maximum Data:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the maximum amount of data that can be sent on the entire connection, in units of octets.</dd>
</dl>
<p id="rfc.section.8.6.p.5">All data sent in STREAM frames counts toward this limit, with the exception of data on stream 0.  The sum of the largest received offsets on all streams - including streams in terminal states, but excluding stream 0 - MUST NOT exceed the value advertised by a receiver.  An endpoint MUST terminate a connection with a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error if it receives more data than the maximum data value that it has sent, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters" class="xref">Section 7.4.2</a>).</p>
<h2 id="rfc.section.8.7">
<a href="#rfc.section.8.7">8.7.</a> <a href="#frame-max-stream-data" id="frame-max-stream-data">MAX_STREAM_DATA Frame</a>
</h2>
<p id="rfc.section.8.7.p.1">The MAX_STREAM_DATA frame (type=0x05) is used in flow control to inform a peer of the maximum amount of data that can be sent on a stream.</p>
<p id="rfc.section.8.7.p.2">An endpoint that receives a MAX_STREAM_DATA frame for a receive-only stream MUST terminate the connection with error PROTOCOL_VIOLATION.</p>
<p id="rfc.section.8.7.p.3">An endpoint that receives a MAX_STREAM_DATA frame for a send-only stream it has not opened MUST terminate the connection with error PROTOCOL_VIOLATION.</p>
<p id="rfc.section.8.7.p.4">Note that an endpoint may legally receive a MAX_STREAM_DATA frame on a bidirectional stream it has not opened.</p>
<p id="rfc.section.8.7.p.5">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Maximum Stream Data (i)                  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.7.p.6">The fields in the MAX_STREAM_DATA frame are as follows:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">The stream ID of the stream that is affected encoded as a variable-length integer.</dd>
<dt>Maximum Stream Data:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the maximum amount of data that can be sent on the identified stream, in units of octets.</dd>
</dl>
<p id="rfc.section.8.7.p.8">When counting data toward this limit, an endpoint accounts for the largest received offset of data that is sent or received on the stream.  Loss or reordering can mean that the largest received offset on a stream can be greater than the total size of data received on that stream.  Receiving STREAM frames might not increase the largest received offset.</p>
<p id="rfc.section.8.7.p.9">The data sent on a stream MUST NOT exceed the largest maximum stream data value advertised by the receiver.  An endpoint MUST terminate a connection with a FLOW_CONTROL_ERROR error if it receives more data than the largest maximum stream data that it has sent for the affected stream, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters" class="xref">Section 7.4.2</a>).</p>
<h2 id="rfc.section.8.8">
<a href="#rfc.section.8.8">8.8.</a> <a href="#frame-max-stream-id" id="frame-max-stream-id">MAX_STREAM_ID Frame</a>
</h2>
<p id="rfc.section.8.8.p.1">The MAX_STREAM_ID frame (type=0x06) informs the peer of the maximum stream ID that they are permitted to open.</p>
<p id="rfc.section.8.8.p.2">The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Maximum Stream ID (i)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.8.p.3">The fields in the MAX_STREAM_ID frame are as follows:</p>
<p></p>

<dl>
<dt>Maximum Stream ID:</dt>
<dd style="margin-left: 8">ID of the maximum unidirectional or bidirectional peer-initiated stream ID for the connection encoded as a variable-length integer. The limit applies to unidirectional steams if the second least signification bit of the stream ID is 1, and applies to bidirectional streams if it is 0.</dd>
</dl>
<p id="rfc.section.8.8.p.5">Loss or reordering can mean that a MAX_STREAM_ID frame can be received which states a lower stream limit than the client has previously received.  MAX_STREAM_ID frames which do not increase the maximum stream ID MUST be ignored.</p>
<p id="rfc.section.8.8.p.6">A peer MUST NOT initiate a stream with a higher stream ID than the greatest maximum stream ID it has received.  An endpoint MUST terminate a connection with a STREAM_ID_ERROR error if a peer initiates a stream with a higher stream ID than it has sent, unless this is a result of a change in the initial limits (see <a href="#zerortt-parameters" class="xref">Section 7.4.2</a>).</p>
<h2 id="rfc.section.8.9">
<a href="#rfc.section.8.9">8.9.</a> <a href="#frame-ping" id="frame-ping">PING Frame</a>
</h2>
<p id="rfc.section.8.9.p.1">Endpoints can use PING frames (type=0x07) to verify that their peers are still alive or to check reachability to the peer. The PING frame contains no additional fields.</p>
<p id="rfc.section.8.9.p.2">The receiver of a PING frame simply needs to acknowledge the packet containing this frame.</p>
<p id="rfc.section.8.9.p.3">The PING frame can be used to keep a connection alive when an application or application protocol wishes to prevent the connection from timing out. An application protocol SHOULD provide guidance about the conditions under which generating a PING is recommended.  This guidance SHOULD indicate whether it is the client or the server that is expected to send the PING.  Having both endpoints send PING frames without coordination can produce an excessive number of packets and poor performance.</p>
<p id="rfc.section.8.9.p.4">A connection will time out if no packets are sent or received for a period longer than the time specified in the idle_timeout transport parameter (see <a href="#termination" class="xref">Section 7.9</a>).  However, state in middleboxes might time out earlier than that.  Though REQ-5 in <a href="#RFC4787" class="xref">[RFC4787]</a> recommends a 2 minute timeout interval, experience shows that sending packets every 15 to 30 seconds is necessary to prevent the majority of middleboxes from losing state for UDP flows.</p>
<h2 id="rfc.section.8.10">
<a href="#rfc.section.8.10">8.10.</a> <a href="#frame-blocked" id="frame-blocked">BLOCKED Frame</a>
</h2>
<p id="rfc.section.8.10.p.1">A sender SHOULD send a BLOCKED frame (type=0x08) when it wishes to send data, but is unable to due to connection-level flow control (see <a href="#blocking" class="xref">Section 11.2.1</a>).  BLOCKED frames can be used as input to tuning of flow control algorithms (see <a href="#fc-credit" class="xref">Section 11.1.2</a>).</p>
<p id="rfc.section.8.10.p.2">The BLOCKED frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Offset (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.10.p.3">The BLOCKED frame contains a single field.</p>
<p></p>

<dl>
<dt>Offset:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the connection-level offset at which the blocking occurred.</dd>
</dl>
<h2 id="rfc.section.8.11">
<a href="#rfc.section.8.11">8.11.</a> <a href="#frame-stream-blocked" id="frame-stream-blocked">STREAM_BLOCKED Frame</a>
</h2>
<p id="rfc.section.8.11.p.1">A sender SHOULD send a STREAM_BLOCKED frame (type=0x09) when it wishes to send data, but is unable to due to stream-level flow control.  This frame is analogous to BLOCKED (<a href="#frame-blocked" class="xref">Section 8.10</a>).</p>
<p id="rfc.section.8.11.p.2">An endpoint that receives a STREAM_BLOCKED frame for a send-only stream MUST terminate the connection with error PROTOCOL_VIOLATION.</p>
<p id="rfc.section.8.11.p.3">The STREAM_BLOCKED frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Offset (i)                          ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.11.p.4">The STREAM_BLOCKED frame contains two fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the stream which is flow control blocked.</dd>
<dt>Offset:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the offset of the stream at which the blocking occurred.</dd>
</dl>
<h2 id="rfc.section.8.12">
<a href="#rfc.section.8.12">8.12.</a> <a href="#frame-stream-id-blocked" id="frame-stream-id-blocked">STREAM_ID_BLOCKED Frame</a>
</h2>
<p id="rfc.section.8.12.p.1">A sender MAY send a STREAM_ID_BLOCKED frame (type=0x0a) when it wishes to open a stream, but is unable to due to the maximum stream ID limit set by its peer (see <a href="#frame-max-stream-id" class="xref">Section 8.8</a>).  This does not open the stream, but informs the peer that a new stream was needed, but the stream limit prevented the creation of the stream.</p>
<p id="rfc.section.8.12.p.2">The STREAM_ID_BLOCKED frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.12.p.3">The STREAM_ID_BLOCKED frame contains a single field.</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the highest stream ID that the sender was permitted to open.</dd>
</dl>
<h2 id="rfc.section.8.13">
<a href="#rfc.section.8.13">8.13.</a> <a href="#frame-new-connection-id" id="frame-new-connection-id">NEW_CONNECTION_ID Frame</a>
</h2>
<p id="rfc.section.8.13.p.1">A server sends a NEW_CONNECTION_ID frame (type=0x0b) to provide the client with alternative connection IDs that can be used to break linkability when migrating connections (see <a href="#migration-linkability" class="xref">Section 7.7.1</a>).</p>
<p id="rfc.section.8.13.p.2">The NEW_CONNECTION_ID is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Sequence (i)                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        Connection ID (64)                     +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                   Stateless Reset Token (128)                 +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.13.p.3">The fields are:</p>
<p></p>

<dl>
<dt>Sequence:</dt>
<dd style="margin-left: 8">A variable-length integer.  This value starts at 0 and increases by 1 for each connection ID that is provided by the server.  The connection ID that is assigned during the handshake is assumed to have a sequence of -1.  That is, the value selected during the handshake comes immediately before the first value that a server can send.</dd>
<dt>Connection ID:</dt>
<dd style="margin-left: 8">A 64-bit connection ID.</dd>
<dt>Stateless Reset Token:</dt>
<dd style="margin-left: 8">A 128-bit value that will be used to for a stateless reset when the associated connection ID is used (see <a href="#stateless-reset" class="xref">Section 7.9.4</a>).</dd>
</dl>
<h2 id="rfc.section.8.14">
<a href="#rfc.section.8.14">8.14.</a> <a href="#frame-stop-sending" id="frame-stop-sending">STOP_SENDING Frame</a>
</h2>
<p id="rfc.section.8.14.p.1">An endpoint may use a STOP_SENDING frame (type=0x0c) to communicate that incoming data is being discarded on receipt at application request.  This signals a peer to abruptly terminate transmission on a stream.</p>
<p id="rfc.section.8.14.p.2">An endpoint that receives a STOP_SENDING frame for a receive-only stream MUST terminate the connection with error PROTOCOL_VIOLATION.</p>
<p id="rfc.section.8.14.p.3">The STOP_SENDING frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Application Error Code (16)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.8.14.p.4">The fields are:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer carrying the Stream ID of the stream being ignored.</dd>
<dt>Application Error Code:</dt>
<dd style="margin-left: 8">A 16-bit, application-specified reason the sender is ignoring the stream (see <a href="#app-error-codes" class="xref">Section 12.4</a>).</dd>
</dl>
<h2 id="rfc.section.8.15">
<a href="#rfc.section.8.15">8.15.</a> <a href="#frame-ack" id="frame-ack">ACK Frame</a>
</h2>
<p id="rfc.section.8.15.p.1">Receivers send ACK frames (type=0x0d) to inform senders which packets they have received and processed.  A sent packet that has never been acknowledged is missing. The ACK frame contains any number of ACK blocks.  ACK blocks are ranges of acknowledged packets.</p>
<p id="rfc.section.8.15.p.2">Unlike TCP SACKs, QUIC acknowledgements are irrevocable.  Once a packet has been acknowledged, even if it does not appear in a future ACK frame, it remains acknowledged.</p>
<p id="rfc.section.8.15.p.3">A client MUST NOT acknowledge Retry packets.  Retry packets include the packet number from the Initial packet it responds to.  Version Negotiation packets cannot be acknowledged because they do not contain a packet number.  Rather than relying on ACK frames, these packets are implicitly acknowledged by the next Initial packet sent by the client.</p>
<p id="rfc.section.8.15.p.4">A sender MAY intentionally skip packet numbers to introduce entropy into the connection, to avoid opportunistic acknowledgement attacks.  The sender SHOULD close the connection if an unsent packet number is acknowledged.  The format of the ACK frame is efficient at expressing even long blocks of missing packets, allowing for large, unpredictable gaps.</p>
<p id="rfc.section.8.15.p.5">An ACK frame is shown below.</p>
<div id="rfc.figure.7"></div>
<div id="ack-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Largest Acknowledged (i)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          ACK Delay (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       ACK Block Count (i)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          ACK Blocks (*)                     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 7: ACK Frame Format</p>
<p id="rfc.section.8.15.p.6">The fields in the ACK frame are as follows:</p>
<p></p>

<dl>
<dt>Largest Acknowledged:</dt>
<dd style="margin-left: 8">A variable-length integer representing the largest packet number the peer is acknowledging; this is usually the largest packet number that the peer has received prior to generating the ACK frame.  Unlike the packet number in the QUIC long or short header, the value in an ACK frame is not truncated.</dd>
<dt>ACK Delay:</dt>
<dd style="margin-left: 8">A variable-length integer including the time in microseconds that the largest acknowledged packet, as indicated in the Largest Acknowledged field, was received by this peer to when this ACK was sent.  The value of the ACK Delay field is scaled by multiplying the encoded value by the 2 to the power of the value of the <samp>ack_delay_exponent</samp> transport parameter set by the sender of the ACK frame.  The <samp>ack_delay_exponent</samp> defaults to 3, or a multiplier of 8 (see <a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a>).  Scaling in this fashion allows for a larger range of values with a shorter encoding at the cost of lower resolution.</dd>
<dt>ACK Block Count:</dt>
<dd style="margin-left: 8">The number of Additional ACK Block (and Gap) fields after the First ACK Block.</dd>
<dt>ACK Blocks:</dt>
<dd style="margin-left: 8">Contains one or more blocks of packet numbers which have been successfully received, see <a href="#ack-block-section" class="xref">Section 8.15.1</a>.</dd>
</dl>
<h3 id="rfc.section.8.15.1">
<a href="#rfc.section.8.15.1">8.15.1.</a> <a href="#ack-block-section" id="ack-block-section">ACK Block Section</a>
</h3>
<p id="rfc.section.8.15.1.p.1">The ACK Block Section consists of alternating Gap and ACK Block fields in descending packet number order.  A First Ack Block field is followed by a variable number of alternating Gap and Additional ACK Blocks.  The number of Gap and Additional ACK Block fields is determined by the ACK Block Count field.</p>
<p id="rfc.section.8.15.1.p.2">Gap and ACK Block fields use a relative integer encoding for efficiency.  Though each encoded value is positive, the values are subtracted, so that each ACK Block describes progressively lower-numbered packets.  As long as contiguous ranges of packets are small, the variable-length integer encoding ensures that each range can be expressed in a small number of octets.</p>
<div id="rfc.figure.8"></div>
<div id="ack-block-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      First ACK Block (i)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Gap (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Additional ACK Block (i)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Gap (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Additional ACK Block (i)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Gap (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Additional ACK Block (i)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 8: ACK Block Section</p>
<p id="rfc.section.8.15.1.p.3">Each ACK Block acknowledges a contiguous range of packets by indicating the number of acknowledged packets that precede the largest packet number in that block.  A value of zero indicates that only the largest packet number is acknowledged.  Larger ACK Block values indicate a larger range, with corresponding lower values for the smallest packet number in the range.  Thus, given a largest packet number for the ACK, the smallest value is determined by the formula:</p>
<pre>
   smallest = largest - ack_block
</pre>
<p id="rfc.section.8.15.1.p.4">The range of packets that are acknowledged by the ACK block include the range from the smallest packet number to the largest, inclusive.</p>
<p id="rfc.section.8.15.1.p.5">The largest value for the First ACK Block is determined by the Largest Acknowledged field; the largest for Additional ACK Blocks is determined by cumulatively subtracting the size of all preceding ACK Blocks and Gaps.</p>
<p id="rfc.section.8.15.1.p.6">Each Gap indicates a range of packets that are not being acknowledged.  The number of packets in the gap is one higher than the encoded value of the Gap Field.</p>
<p id="rfc.section.8.15.1.p.7">The value of the Gap field establishes the largest packet number value for the ACK block that follows the gap using the following formula:</p>
<pre>
  largest = previous_smallest - gap - 2
</pre>
<p id="rfc.section.8.15.1.p.8">If the calculated value for largest or smallest packet number for any ACK Block is negative, an endpoint MUST generate a connection error of type FRAME_ERROR indicating an error in an ACK frame (that is, 0x10d).</p>
<p id="rfc.section.8.15.1.p.9">The fields in the ACK Block Section are:</p>
<p></p>

<dl>
<dt>First ACK Block:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of contiguous packets preceding the Largest Acknowledged that are being acknowledged.</dd>
<dt>Gap (repeated):</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of contiguous unacknowledged packets preceding the packet number one lower than the smallest in the preceding ACK Block.</dd>
<dt>ACK Block (repeated):</dt>
<dd style="margin-left: 8">A variable-length integer indicating the number of contiguous acknowledged packets preceding the largest packet number, as determined by the preceding Gap.</dd>
</dl>
<h3 id="rfc.section.8.15.2">
<a href="#rfc.section.8.15.2">8.15.2.</a> <a href="#sending-ack-frames" id="sending-ack-frames">Sending ACK Frames</a>
</h3>
<p id="rfc.section.8.15.2.p.1">Implementations MUST NOT generate packets that only contain ACK frames in response to packets which only contain ACK frames. However, they MUST acknowledge packets containing only ACK frames when sending ACK frames in response to other packets.  Implementations MUST NOT send more than one ACK frame per received packet that contains frames other than ACK frames.  Packets containing non-ACK frames MUST be acknowledged immediately or when a delayed ack timer expires.</p>
<p id="rfc.section.8.15.2.p.2">To limit ACK blocks to those that have not yet been received by the sender, the receiver SHOULD track which ACK frames have been acknowledged by its peer.  Once an ACK frame has been acknowledged, the packets it acknowledges SHOULD NOT be acknowledged again.</p>
<p id="rfc.section.8.15.2.p.3">A receiver that is only sending ACK frames will not receive acknowledgments for its packets.  Sending an occasional MAX_DATA or MAX_STREAM_DATA frame as data is received will ensure that acknowledgements are generated by a peer.  Otherwise, an endpoint MAY send a PING frame once per RTT to solicit an acknowledgment.</p>
<p id="rfc.section.8.15.2.p.4">To limit receiver state or the size of ACK frames, a receiver MAY limit the number of ACK blocks it sends.  A receiver can do this even without receiving acknowledgment of its ACK frames, with the knowledge this could cause the sender to unnecessarily retransmit some data.  Standard QUIC <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a> algorithms declare packets lost after sufficiently newer packets are acknowledged.  Therefore, the receiver SHOULD repeatedly acknowledge newly received packets in preference to packets received in the past.</p>
<h3 id="rfc.section.8.15.3">
<a href="#rfc.section.8.15.3">8.15.3.</a> <a href="#ack-frames-and-packet-protection" id="ack-frames-and-packet-protection">ACK Frames and Packet Protection</a>
</h3>
<p id="rfc.section.8.15.3.p.1">ACK frames that acknowledge protected packets MUST be carried in a packet that has an equivalent or greater level of packet protection.</p>
<p id="rfc.section.8.15.3.p.2">Packets that are protected with 1-RTT keys MUST be acknowledged in packets that are also protected with 1-RTT keys.</p>
<p id="rfc.section.8.15.3.p.3">A packet that is not protected and claims to acknowledge a packet number that was sent with packet protection is not valid.  An unprotected packet that carries acknowledgments for protected packets MUST be discarded in its entirety.</p>
<p id="rfc.section.8.15.3.p.4">Packets that a client sends with 0-RTT packet protection MUST be acknowledged by the server in packets protected by 1-RTT keys.  This can mean that the client is unable to use these acknowledgments if the server cryptographic handshake messages are delayed or lost.  Note that the same limitation applies to other data sent by the server protected by the 1-RTT keys.</p>
<p id="rfc.section.8.15.3.p.5">Unprotected packets, such as those that carry the initial cryptographic handshake messages, MAY be acknowledged in unprotected packets.  Unprotected packets are vulnerable to falsification or modification.  Unprotected packets can be acknowledged along with protected packets in a protected packet.</p>
<p id="rfc.section.8.15.3.p.6">An endpoint SHOULD acknowledge packets containing cryptographic handshake messages in the next unprotected packet that it sends, unless it is able to acknowledge those packets in later packets protected by 1-RTT keys.  At the completion of the cryptographic handshake, both peers send unprotected packets containing cryptographic handshake messages followed by packets protected by 1-RTT keys. An endpoint SHOULD acknowledge the unprotected packets that complete the cryptographic handshake in a protected packet, because its peer is guaranteed to have access to 1-RTT packet protection keys.</p>
<p id="rfc.section.8.15.3.p.7">For instance, a server acknowledges a TLS ClientHello in the packet that carries the TLS ServerHello; similarly, a client can acknowledge a TLS HelloRetryRequest in the packet containing a second TLS ClientHello.  The complete set of server handshake messages (TLS ServerHello through to Finished) might be acknowledged by a client in protected packets, because it is certain that the server is able to decipher the packet.</p>
<h2 id="rfc.section.8.16">
<a href="#rfc.section.8.16">8.16.</a> <a href="#frame-path-challenge" id="frame-path-challenge">PATH_CHALLENGE Frame</a>
</h2>
<p id="rfc.section.8.16.p.1">Endpoints can use PATH_CHALLENGE frames (type=0x0e) to check reachability to the peer and for address validation during connection establishment and connection migration.</p>
<p id="rfc.section.8.16.p.2">PATH_CHALLENGE frames contain an 8-byte payload.</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                            Data (8)                           +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</pre>
<p></p>

<dl>
<dt>Data:</dt>
<dd style="margin-left: 8">This 8-byte field contains arbitrary data.</dd>
</dl>
<p id="rfc.section.8.16.p.4">A PATH_CHALLENGE frame containing 8 octets that are hard to guess is sufficient to ensure that it is easier to receive the packet than it is to guess the value correctly.</p>
<p id="rfc.section.8.16.p.5">The recipient of this frame MUST generate a PATH_RESPONSE frame (<a href="#frame-path-response" class="xref">Section 8.17</a>) containing the same Data.</p>
<h2 id="rfc.section.8.17">
<a href="#rfc.section.8.17">8.17.</a> <a href="#frame-path-response" id="frame-path-response">PATH_RESPONSE Frame</a>
</h2>
<p id="rfc.section.8.17.p.1">The PATH_RESPONSE frame (type=0x0f) is sent in response to a PATH_CHALLENGE frame.  Its format is identical to the PATH_CHALLENGE frame (<a href="#frame-path-challenge" class="xref">Section 8.16</a>).</p>
<p id="rfc.section.8.17.p.2">If the content of a PATH_RESPONSE frame does not match the content of a PATH_CHALLENGE frame previously sent by the endpoint, the endpoint MAY generate a connection error of type UNSOLICITED_PATH_RESPONSE.</p>
<h2 id="rfc.section.8.18">
<a href="#rfc.section.8.18">8.18.</a> <a href="#frame-stream" id="frame-stream">STREAM Frames</a>
</h2>
<p id="rfc.section.8.18.p.1">STREAM frames implicitly create a stream and carry stream data.  The STREAM frame takes the form 0b00010XXX (or the set of values from 0x10 to 0x17).  The value of the three low-order bits of the frame type determine the fields that are present in the frame.</p>
<p></p>

<ul>
<li>The OFF bit (0x04) in the frame type is set to indicate that there is an Offset field present.  When set to 1, the Offset field is present; when set to 0, the Offset field is absent and the Stream Data starts at an offset of 0 (that is, the frame contains the first octets of the stream, or the end of a stream that includes no data).</li>
<li>The LEN bit (0x02) in the frame type is set to indicate that there is a Length field present.  If this bit is set to 0, the Length field is absent and the Stream Data field extends to the end of the packet.  If this bit is set to 1, the Length field is present.</li>
<li>The FIN bit (0x01) of the frame type is set only on frames that contain the final offset of the stream.  Setting this bit indicates that the frame marks the end of the stream.</li>
</ul>
<p id="rfc.section.8.18.p.3">An endpoint that receives a STREAM frame for a send-only stream MUST terminate the connection with error PROTOCOL_VIOLATION.</p>
<p id="rfc.section.8.18.p.4">A STREAM frame is shown below.</p>
<div id="rfc.figure.9"></div>
<div id="stream-format"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Stream ID (i)                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         [Offset (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         [Length (i)]                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream Data (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 9: STREAM Frame Format</p>
<p id="rfc.section.8.18.p.5">The STREAM frame contains the following fields:</p>
<p></p>

<dl>
<dt>Stream ID:</dt>
<dd style="margin-left: 8">A variable-length integer indicating the stream ID of the stream (see <a href="#stream-id" class="xref">Section 10.1</a>).</dd>
<dt>Offset:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the byte offset in the stream for the data in this STREAM frame.  This field is present when the OFF bit is set to 1.  When the Offset field is absent, the offset is 0.</dd>
<dt>Length:</dt>
<dd style="margin-left: 8">A variable-length integer specifying the length of the Stream Data field in this STREAM frame.  This field is present when the LEN bit is set to 1.  When the LEN bit is set to 0, the Stream Data field consumes all the remaining octets in the packet.</dd>
<dt>Stream Data:</dt>
<dd style="margin-left: 8">The bytes from the designated stream to be delivered.</dd>
</dl>
<p id="rfc.section.8.18.p.7">A stream frame&#8217;s Stream Data MUST NOT be empty, unless the FIN bit is set.  When the FIN flag is sent on an empty STREAM frame, the offset in the STREAM frame is the offset of the next byte that would be sent.</p>
<p id="rfc.section.8.18.p.8">The first byte in the stream has an offset of 0.  The largest offset delivered on a stream - the sum of the re-constructed offset and data length - MUST be less than 2^62.</p>
<p id="rfc.section.8.18.p.9">Stream multiplexing is achieved by interleaving STREAM frames from multiple streams into one or more QUIC packets.  A single QUIC packet can include multiple STREAM frames from one or more streams.</p>
<p id="rfc.section.8.18.p.10">Implementation note: One of the benefits of QUIC is avoidance of head-of-line blocking across multiple streams.  When a packet loss occurs, only streams with data in that packet are blocked waiting for a retransmission to be received, while other streams can continue making progress.  Note that when data from multiple streams is bundled into a single QUIC packet, loss of that packet blocks all those streams from making progress.  An implementation is therefore advised to bundle as few streams as necessary in outgoing packets without losing transmission efficiency to underfilled packets.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#packetization" id="packetization">Packetization and Reliability</a>
</h1>
<p id="rfc.section.9.p.1">A sender bundles one or more frames in a QUIC packet (see <a href="#frames" class="xref">Section 6</a>).</p>
<p id="rfc.section.9.p.2">A sender SHOULD minimize per-packet bandwidth and computational costs by bundling as many frames as possible within a QUIC packet.  A sender MAY wait for a short period of time to bundle multiple frames before sending a packet that is not maximally packed, to avoid sending out large numbers of small packets.  An implementation may use knowledge about application sending behavior or heuristics to determine whether and for how long to wait.  This waiting period is an implementation decision, and an implementation should be careful to delay conservatively, since any delay is likely to increase application-visible latency.</p>
<h2 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#packet-processing-and-acknowledgment" id="packet-processing-and-acknowledgment">Packet Processing and Acknowledgment</a>
</h2>
<p id="rfc.section.9.1.p.1">A packet MUST NOT be acknowledged until packet protection has been successfully removed and all frames contained in the packet have been processed.  Any stream state transitions triggered by the frame MUST have occurred.  For STREAM frames, this means the data has been enqueued in preparation to be received by the application protocol, but it does not require that data is delivered and consumed.</p>
<p id="rfc.section.9.1.p.2">Once the packet has been fully processed, a receiver acknowledges receipt by sending one or more ACK frames containing the packet number of the received packet.  To avoid creating an indefinite feedback loop, an endpoint MUST NOT send an ACK frame in response to a packet containing only ACK or PADDING frames, even if there are packet gaps which precede the received packet.  The endpoint MUST acknowledge packets containing only ACK or PADDING frames in the next ACK frame that it sends.</p>
<p id="rfc.section.9.1.p.3">Strategies and implications of the frequency of generating acknowledgments are discussed in more detail in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#retransmission-of-information" id="retransmission-of-information">Retransmission of Information</a>
</h2>
<p id="rfc.section.9.2.p.1">QUIC packets that are determined to be lost are not retransmitted whole. The same applies to the frames that are contained within lost packets. Instead, the information that might be carried in frames is sent again in new frames as needed.</p>
<p id="rfc.section.9.2.p.2">New frames and packets are used to carry information that is determined to have been lost.  In general, information is sent again when a packet containing that information is determined to be lost and sending ceases when a packet containing that information is acknowledged.</p>
<p></p>

<ul>
<li>Application data sent in STREAM frames is retransmitted in new STREAM frames unless the endpoint has sent a RST_STREAM for that stream.  Once an endpoint sends a RST_STREAM frame, no further STREAM frames are needed.</li>
<li>The most recent set of acknowledgments are sent in ACK frames.  An ACK frame SHOULD contain all unacknowledged acknowledgments, as described in <a href="#sending-ack-frames" class="xref">Section 8.15.2</a>.</li>
<li>Cancellation of stream transmission, as carried in a RST_STREAM frame, is sent until acknowledged or until all stream data is acknowledged by the peer (that is, either the &#8220;Reset Recvd&#8221; or &#8220;Data Recvd&#8221; state is reached on the send stream). The content of a RST_STREAM frame MUST NOT change when it is sent again.</li>
<li>Similarly, a request to cancel stream transmission, as encoded in a STOP_SENDING frame, is sent until the receive stream enters either a &#8220;Data Recvd&#8221; or &#8220;Reset Recvd&#8221; state, see <a href="#solicited-state-transitions" class="xref">Section 10.3</a>.</li>
<li>Connection close signals, including those that use CONNECTION_CLOSE and APPLICATION_CLOSE frames, are not sent again when packet loss is detected, but as described in <a href="#termination" class="xref">Section 7.9</a>.</li>
<li>The current connection maximum data is sent in MAX_DATA frames. An updated value is sent in a MAX_DATA frame if the packet containing the most recently sent MAX_DATA frame is declared lost, or when the endpoint decides to update the limit.  Care is necessary to avoid sending this frame too often as the limit can increase frequently and cause an unnecessarily large number of MAX_DATA frames to be sent.</li>
<li>The current maximum stream data offset is sent in MAX_STREAM_DATA frames.  Like MAX_DATA, an updated value is sent when the packet containing the most recent MAX_STREAM_DATA frame for a stream is lost or when the limit is updated, with care taken to prevent the frame from being sent too often. An endpoint SHOULD stop sending MAX_STREAM_DATA frames when the receive stream enters a &#8220;Size Known&#8221; state.</li>
<li>The maximum stream ID for a stream of a given type is sent in MAX_STREAM_ID frames.  Like MAX_DATA, an updated value is sent when a packet containing the most recent MAX_STREAM_ID for a stream type frame is declared lost or when the limit is updated, with care taken to prevent the frame from being sent too often.</li>
<li>Blocked signals are carried in BLOCKED, STREAM_BLOCKED, and STREAM_ID_BLOCKED frames. BLOCKED streams have connection scope, STREAM_BLOCKED frames have stream scope, and STREAM_ID_BLOCKED frames are scoped to a specific stream type. New frames are sent if packets containing the most recent frame for a scope is lost, but only while the endpoint is blocked on the corresponding limit. These frames always include the limit that is causing blocking at the time that they are transmitted.</li>
<li>A liveness or path validation check using PATH_CHALLENGE frames is sent periodically until a matching PATH_RESPONSE frame is received or until there is no remaining need for liveness or path validation checking. PATH_CHALLENGE frames include a different payload each time they are sent.</li>
<li>Responses to path validation using PATH_RESPONSE frames are sent just once.  A new PATH_CHALLENGE frame will be sent if another PATH_RESPONSE frame is needed.</li>
<li>New connection IDs are sent in NEW_CONNECTION_ID frames and retransmitted if the packet containing them is lost.</li>
<li>PADDING frames contain no information, so lost PADDING frames do not require repair.</li>
</ul>
<p id="rfc.section.9.2.p.4">Upon detecting losses, a sender MUST take appropriate congestion control action.  The details of loss detection and congestion control are described in <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#packet-size" id="packet-size">Packet Size</a>
</h2>
<p id="rfc.section.9.3.p.1">The QUIC packet size includes the QUIC header and integrity check, but not the UDP or IP header.</p>
<p id="rfc.section.9.3.p.2">Clients MUST pad any Initial packet it sends to have a QUIC packet size of at least 1200 octets. Sending an Initial packet of this size ensures that the network path supports a reasonably sized packet, and helps reduce the amplitude of amplification attacks caused by server responses toward an unverified client address.</p>
<p id="rfc.section.9.3.p.3">An Initial packet MAY exceed 1200 octets if the client knows that the Path Maximum Transmission Unit (PMTU) supports the size that it chooses.</p>
<p id="rfc.section.9.3.p.4">A server MAY send a CONNECTION_CLOSE frame with error code PROTOCOL_VIOLATION in response to an Initial packet smaller than 1200 octets. It MUST NOT send any other frame type in response, or otherwise behave as if any part of the offending packet was processed as valid.</p>
<h2 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#path-maximum-transmission-unit" id="path-maximum-transmission-unit">Path Maximum Transmission Unit</a>
</h2>
<p id="rfc.section.9.4.p.1">The Path Maximum Transmission Unit (PMTU) is the maximum size of the entire IP header, UDP header, and UDP payload. The UDP payload includes the QUIC packet header, protected payload, and any authentication fields.</p>
<p id="rfc.section.9.4.p.2">All QUIC packets SHOULD be sized to fit within the estimated PMTU to avoid IP fragmentation or packet drops. To optimize bandwidth efficiency, endpoints SHOULD use Packetization Layer PMTU Discovery (<a href="#PLPMTUD" class="xref">[PLPMTUD]</a>).  Endpoints MAY use PMTU Discovery (<a href="#PMTUDv4" class="xref">[PMTUDv4]</a>, <a href="#PMTUDv6" class="xref">[PMTUDv6]</a>) for detecting the PMTU, setting the PMTU appropriately, and storing the result of previous PMTU determinations.</p>
<p id="rfc.section.9.4.p.3">In the absence of these mechanisms, QUIC endpoints SHOULD NOT send IP packets larger than 1280 octets. Assuming the minimum IP header size, this results in a QUIC packet size of 1232 octets for IPv6 and 1252 octets for IPv4. Some QUIC implementations MAY wish to be more conservative in computing allowed QUIC packet size given unknown tunneling overheads or IP header options.</p>
<p id="rfc.section.9.4.p.4">QUIC endpoints that implement any kind of PMTU discovery SHOULD maintain an estimate for each combination of local and remote IP addresses.  Each pairing of local and remote addresses could have a different maximum MTU in the path.</p>
<p id="rfc.section.9.4.p.5">QUIC depends on the network path supporting a MTU of at least 1280 octets. This is the IPv6 minimum MTU and therefore also supported by most modern IPv4 networks.  An endpoint MUST NOT reduce its MTU below this number, even if it receives signals that indicate a smaller limit might exist.</p>
<p id="rfc.section.9.4.p.6">If a QUIC endpoint determines that the PMTU between any pair of local and remote IP addresses has fallen below 1280 octets, it MUST immediately cease sending QUIC packets on the affected path.  This could result in termination of the connection if an alternative path cannot be found.</p>
<h3 id="rfc.section.9.4.1">
<a href="#rfc.section.9.4.1">9.4.1.</a> <a href="#special-considerations-for-pmtu-discovery" id="special-considerations-for-pmtu-discovery">Special Considerations for PMTU Discovery</a>
</h3>
<p id="rfc.section.9.4.1.p.1">Traditional ICMP-based path MTU discovery in IPv4 <a href="#RFC1191" class="xref">[RFC1191]</a> is potentially vulnerable to off-path attacks that successfully guess the IP/port 4-tuple and reduce the MTU to a bandwidth-inefficient value. TCP connections mitigate this risk by using the (at minimum) 8 bytes of transport header echoed in the ICMP message to validate the TCP sequence number as valid for the current connection. However, as QUIC operates over UDP, in IPv4 the echoed information could consist only of the IP and UDP headers, which usually has insufficient entropy to mitigate off-path attacks.</p>
<p id="rfc.section.9.4.1.p.2">As a result, endpoints that implement PMTUD in IPv4 SHOULD take steps to mitigate this risk. For instance, an application could:</p>
<p></p>

<ul>
<li>Set the IPv4 Don&#8217;t Fragment (DF) bit on a small proportion of packets, so that most invalid ICMP messages arrive when there are no DF packets outstanding, and can therefore be identified as spurious.</li>
<li>Store additional information from the IP or UDP headers from DF packets (for example, the IP ID or UDP checksum) to further authenticate incoming Datagram Too Big messages.</li>
<li>Any reduction in PMTU due to a report contained in an ICMP packet is provisional until QUIC&#8217;s loss detection algorithm determines that the packet is actually lost.</li>
</ul>
<h3 id="rfc.section.9.4.2">
<a href="#rfc.section.9.4.2">9.4.2.</a> <a href="#special-considerations-for-packetization-layer-pmtu-discovery" id="special-considerations-for-packetization-layer-pmtu-discovery">Special Considerations for Packetization Layer PMTU Discovery</a>
</h3>
<p id="rfc.section.9.4.2.p.1">The PADDING frame provides a useful option for PMTU probe packets that does not exist in other transports. PADDING frames generate acknowledgements, but their content need not be delivered reliably. PADDING frames may delay the delivery of application data, as they consume the congestion window. However, by definition their likely loss in a probe packet does not require delay-inducing retransmission of application data.</p>
<p id="rfc.section.9.4.2.p.2">When implementing the algorithm in Section 7.2 of <a href="#RFC4821" class="xref">[RFC4821]</a>, the initial value of search_low SHOULD be consistent with the IPv6 minimum packet size.  Paths that do not support this size cannot deliver Initial packets, and therefore are not QUIC-compliant.</p>
<p id="rfc.section.9.4.2.p.3">Section 7.3 of <a href="#RFC4821" class="xref">[RFC4821]</a> discusses tradeoffs between small and large increases in the size of probe packets. As QUIC probe packets need not contain application data, aggressive increases in probe size carry fewer consequences.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#streams" id="streams">Streams: QUIC&#8217;s Data Structuring Abstraction</a>
</h1>
<p id="rfc.section.10.p.1">Streams in QUIC provide a lightweight, ordered byte-stream abstraction.</p>
<p id="rfc.section.10.p.2">There are two basic types of stream in QUIC.  Unidirectional streams carry data in one direction only; bidirectional streams allow for data to be sent in both directions.  Different stream identifiers are used to distinguish between unidirectional and bidirectional streams, as well as to create a separation between streams that are initiated by the client and server (see <a href="#stream-id" class="xref">Section 10.1</a>).</p>
<p id="rfc.section.10.p.3">Either type of stream can be created by either endpoint, can concurrently send data interleaved with other streams, and can be cancelled.</p>
<p id="rfc.section.10.p.4">Stream offsets allow for the octets on a stream to be placed in order.  An endpoint MUST be capable of delivering data received on a stream in order.  Implementations MAY choose to offer the ability to deliver data out of order.  There is no means of ensuring ordering between octets on different streams.</p>
<p id="rfc.section.10.p.5">The creation and destruction of streams are expected to have minimal bandwidth and computational cost.  A single STREAM frame may create, carry data for, and terminate a stream, or a stream may last the entire duration of a connection.</p>
<p id="rfc.section.10.p.6">Streams are individually flow controlled, allowing an endpoint to limit memory commitment and to apply back pressure.  The creation of streams is also flow controlled, with each peer declaring the maximum stream ID it is willing to accept at a given time.</p>
<p id="rfc.section.10.p.7">An alternative view of QUIC streams is as an elastic &#8220;message&#8221; abstraction, similar to the way ephemeral streams are used in SST <a href="#SST" class="xref">[SST]</a>, which may be a more appealing description for some applications.</p>
<h2 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#stream-id" id="stream-id">Stream Identifiers</a>
</h2>
<p id="rfc.section.10.1.p.1">Streams are identified by an unsigned 62-bit integer, referred to as the Stream ID.  The least significant two bits of the Stream ID are used to identify the type of stream (unidirectional or bidirectional) and the initiator of the stream.</p>
<p id="rfc.section.10.1.p.2">The least significant bit (0x1) of the Stream ID identifies the initiator of the stream.  Clients initiate even-numbered streams (those with the least significant bit set to 0); servers initiate odd-numbered streams (with the bit set to 1).  Separation of the stream identifiers ensures that client and server are able to open streams without the latency imposed by negotiating for an identifier.</p>
<p id="rfc.section.10.1.p.3">If an endpoint receives a frame for a stream that it expects to initiate (i.e., odd-numbered for the client or even-numbered for the server), but which it has not yet opened, it MUST close the connection with error code STREAM_STATE_ERROR.</p>
<p id="rfc.section.10.1.p.4">The second least significant bit (0x2) of the Stream ID differentiates between unidirectional streams and bidirectional streams. Unidirectional streams always have this bit set to 1 and bidirectional streams have this bit set to 0.</p>
<p id="rfc.section.10.1.p.5">The two type bits from a Stream ID therefore identify streams as summarized in <a href="#stream-id-types" class="xref">Table 5</a>.</p>
<div id="rfc.table.5"></div>
<div id="stream-id-types"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Stream ID Types</caption>
<thead><tr>
<th class="left">Low Bits</th>
<th class="left">Stream Type</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x0</td>
<td class="left">Client-Initiated, Bidirectional</td>
</tr>
<tr>
<td class="left">0x1</td>
<td class="left">Server-Initiated, Bidirectional</td>
</tr>
<tr>
<td class="left">0x2</td>
<td class="left">Client-Initiated, Unidirectional</td>
</tr>
<tr>
<td class="left">0x3</td>
<td class="left">Server-Initiated, Unidirectional</td>
</tr>
</tbody>
</table>
<p id="rfc.section.10.1.p.6">Stream ID 0 (0x0) is a client-initiated, bidirectional stream that is used for the cryptographic handshake.  Stream 0 MUST NOT be used for application data.</p>
<p id="rfc.section.10.1.p.7">A QUIC endpoint MUST NOT reuse a Stream ID.  Open streams can be used in any order.  Streams that are used out of order result in opening all lower-numbered streams of the same type in the same direction.</p>
<p id="rfc.section.10.1.p.8">Stream IDs are encoded as a variable-length integer (see <a href="#integer-encoding" class="xref">Section 8.1</a>).</p>
<h2 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#stream-states" id="stream-states">Stream States</a>
</h2>
<p id="rfc.section.10.2.p.1">This section describes the two types of QUIC stream in terms of the states of their send or receive components.  Two state machines are described: one for streams on which an endpoint transmits data (<a href="#stream-send-states" class="xref">Section 10.2.1</a>); another for streams from which an endpoint receives data (<a href="#stream-recv-states" class="xref">Section 10.2.2</a>).</p>
<p id="rfc.section.10.2.p.2">Unidirectional streams use the applicable state machine directly.  Bidirectional streams use both state machines.  For the most part, the use of these state machines is the same whether the stream is unidirectional or bidirectional.  The conditions for opening a stream are slightly more complex for a bidirectional stream because the opening of either send or receive causes the stream to open in both directions.</p>
<p id="rfc.section.10.2.p.3">Opening a stream causes all lower-numbered streams of the same type to implicitly open.  This includes both send and receive streams if the stream is bidirectional.  For bidirectional streams, an endpoint can send data on an implicitly opened stream.  On both unidirectional and bidirectional streams, an endpoint MAY send MAX_STREAM_DATA or STOP_SENDING on implicitly opened streams.  An endpoint SHOULD NOT implicitly open streams that it initiates, instead opening streams in order.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">These states are largely informative.  This document uses stream states to describe rules for when and how different types of frames can be sent and the reactions that are expected when different types of frames are received.  Though these state machines are intended to be useful in implementing QUIC, these states aren&#8217;t intended to constrain implementations.  An implementation can define a different state machine as long as its behavior is consistent with an implementation that implements these states.</dd>
</dl>
<h3 id="rfc.section.10.2.1">
<a href="#rfc.section.10.2.1">10.2.1.</a> <a href="#stream-send-states" id="stream-send-states">Send Stream States</a>
</h3>
<p><a href="#fig-stream-send-states" class="xref">Figure 10</a> shows the states for the part of a stream that sends data to a peer.</p>
<div id="rfc.figure.10"></div>
<div id="fig-stream-send-states"></div>
<pre>
       o
       | Open Stream (Sending)
       | Open Bidirectional Stream (Receiving)
       v
   +-------+
   | Open  | Send RST_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Send STREAM /             |
       |      STREAM_BLOCKED       |
       v                           |
   +-------+                       |
   | Send  | Send RST_STREAM       |
   |       |----------------------&gt;|
   +-------+                       |
       |                           |
       | Send STREAM + FIN         |
       v                           v
   +-------+                   +-------+
   | Data  | Send RST_STREAM   | Reset |
   | Sent  +------------------&gt;| Sent  |
   +-------+                   +-------+
       |                           |
       | Recv All ACKs             | Recv ACK
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Recvd |                   | Recvd |
   +-------+                   +-------+
</pre>
<p class="figure">Figure 10: States for Send Streams</p>
<p id="rfc.section.10.2.1.p.2">The sending part of stream that the endpoint initiates (types 0 and 2 for clients, 1 and 3 for servers) is opened by the application or application protocol.  The &#8220;Open&#8221; state represents a newly created stream that is able to accept data from the application.  Stream data might be buffered in this state in preparation for sending.</p>
<p id="rfc.section.10.2.1.p.3">The sending part of a bidirectional stream initiated by a peer (type 0 for a server, type 1 for a client) enters the &#8220;Open&#8221; state if the receiving part enters the &#8220;Recv&#8221; state.</p>
<p id="rfc.section.10.2.1.p.4">Sending the first STREAM or STREAM_BLOCKED frame causes a send stream to enter the &#8220;Send&#8221; state.  An implementation might choose to defer allocating a Stream ID to a send stream until it sends the first frame and enters this state, which can allow for better stream prioritization.</p>
<p id="rfc.section.10.2.1.p.5">In the &#8220;Send&#8221; state, an endpoint transmits - and retransmits as necessary - data in STREAM frames.  The endpoint respects the flow control limits of its peer, accepting MAX_STREAM_DATA frames.  An endpoint in the &#8220;Send&#8221; state generates STREAM_BLOCKED frames if it encounters flow control limits.</p>
<p id="rfc.section.10.2.1.p.6">After the application indicates that stream data is complete and a STREAM frame containing the FIN bit is sent, the send stream enters the &#8220;Data Sent&#8221; state.  From this state, the endpoint only retransmits stream data as necessary.  The endpoint no longer needs to track flow control limits or send STREAM_BLOCKED frames for a send stream in this state.  The endpoint can ignore any MAX_STREAM_DATA frames it receives from its peer in this state; MAX_STREAM_DATA frames might be received until the peer receives the final stream offset.</p>
<p id="rfc.section.10.2.1.p.7">Once all stream data has been successfully acknowledged, the send stream enters the &#8220;Data Recvd&#8221; state, which is a terminal state.</p>
<p id="rfc.section.10.2.1.p.8">From any of the &#8220;Open&#8221;, &#8220;Send&#8221;, or &#8220;Data Sent&#8221; states, an application can signal that it wishes to abandon transmission of stream data.  Similarly, the endpoint might receive a STOP_SENDING frame from its peer.  In either case, the endpoint sends a RST_STREAM frame, which causes the stream to enter the &#8220;Reset Sent&#8221; state.</p>
<p id="rfc.section.10.2.1.p.9">An endpoint MAY send a RST_STREAM as the first frame on a send stream; this causes the send stream to open and then immediately transition to the &#8220;Reset Sent&#8221; state.</p>
<p id="rfc.section.10.2.1.p.10">Once a packet containing a RST_STREAM has been acknowledged, the send stream enters the &#8220;Reset Recvd&#8221; state, which is a terminal state.</p>
<h3 id="rfc.section.10.2.2">
<a href="#rfc.section.10.2.2">10.2.2.</a> <a href="#stream-recv-states" id="stream-recv-states">Receive Stream States</a>
</h3>
<p><a href="#fig-stream-recv-states" class="xref">Figure 11</a> shows the states for the part of a stream that receives data from a peer.  The states for a receive stream mirror only some of the states of the send stream at the peer.  A receive stream doesn&#8217;t track states on the send stream that cannot be observed, such as the &#8220;Open&#8221; state; instead, receive streams track the delivery of data to the application or application protocol some of which cannot be observed by the sender.</p>
<div id="rfc.figure.11"></div>
<div id="fig-stream-recv-states"></div>
<pre>
       o
       | Recv STREAM / STREAM_BLOCKED / RST_STREAM
       | Open Bidirectional Stream (Sending)
       | Recv MAX_STREAM_DATA
       v
   +-------+
   | Recv  | Recv RST_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Recv STREAM + FIN         |
       v                           |
   +-------+                       |
   | Size  | Recv RST_STREAM       |
   | Known +----------------------&gt;|
   +-------+                       |
       |                           |
       | Recv All Data             |
       v                           v
   +-------+                   +-------+
   | Data  | Recv RST_STREAM   | Reset |
   | Recvd +&lt;-- (optional) ---&gt;| Recvd |
   +-------+                   +-------+
       |                           |
       | App Read All Data         | App Read RST
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Read  |                   | Read  |
   +-------+                   +-------+
</pre>
<p class="figure">Figure 11: States for Receive Streams</p>
<p id="rfc.section.10.2.2.p.2">The receiving part of a stream initiated by a peer (types 1 and 3 for a client, or 0 and 2 for a server) are created when the first STREAM, STREAM_BLOCKED, RST_STREAM, or MAX_STREAM_DATA (bidirectional only, see below) is received for that stream.  The initial state for a receive stream is &#8220;Recv&#8221;.  Receiving a RST_STREAM frame causes the receive stream to immediately transition to the &#8220;Reset Recvd&#8221;.</p>
<p id="rfc.section.10.2.2.p.3">The receive stream enters the &#8220;Recv&#8221; state when the sending part of a bidirectional stream initiated by the endpoint (type 0 for a client, type 1 for a server) enters the &#8220;Open&#8221; state.</p>
<p id="rfc.section.10.2.2.p.4">A bidirectional stream also opens when a MAX_STREAM_DATA frame is received.  Receiving a MAX_STREAM_DATA frame implies that the remote peer has opened the stream and is providing flow control credit.  A MAX_STREAM_DATA frame might arrive before a STREAM or STREAM_BLOCKED frame if packets are lost or reordered.</p>
<p id="rfc.section.10.2.2.p.5">In the &#8220;Recv&#8221; state, the endpoint receives STREAM and STREAM_BLOCKED frames.  Incoming data is buffered and can be reassembled into the correct order for delivery to the application.  As data is consumed by the application and buffer space becomes available, the endpoint sends MAX_STREAM_DATA frames to allow the peer to send more data.</p>
<p id="rfc.section.10.2.2.p.6">When a STREAM frame with a FIN bit is received, the final offset (see <a href="#final-offset" class="xref">Section 11.3</a>) is known.  The receive stream enters the &#8220;Size Known&#8221; state.  In this state, the endpoint no longer needs to send MAX_STREAM_DATA frames, it only receives any retransmissions of stream data.</p>
<p id="rfc.section.10.2.2.p.7">Once all data for the stream has been received, the receive stream enters the &#8220;Data Recvd&#8221; state.  This might happen as a result of receiving the same STREAM frame that causes the transition to &#8220;Size Known&#8221;.  In this state, the endpoint has all stream data.  Any STREAM or STREAM_BLOCKED frames it receives for the stream can be discarded.</p>
<p id="rfc.section.10.2.2.p.8">The &#8220;Data Recvd&#8221; state persists until stream data has been delivered to the application or application protocol.  Once stream data has been delivered, the stream enters the &#8220;Data Read&#8221; state, which is a terminal state.</p>
<p id="rfc.section.10.2.2.p.9">Receiving a RST_STREAM frame in the &#8220;Recv&#8221; or &#8220;Size Known&#8221; states causes the stream to enter the &#8220;Reset Recvd&#8221; state.  This might cause the delivery of stream data to the application to be interrupted.</p>
<p id="rfc.section.10.2.2.p.10">It is possible that all stream data is received when a RST_STREAM is received (that is, from the &#8220;Data Recvd&#8221; state).  Similarly, it is possible for remaining stream data to arrive after receiving a RST_STREAM frame (the &#8220;Reset Recvd&#8221; state).  An implementation is able to manage this situation as they choose.  Sending RST_STREAM means that an endpoint cannot guarantee delivery of stream data; however there is no requirement that stream data not be delivered if a RST_STREAM is received.  An implementation MAY interrupt delivery of stream data, discard any data that was not consumed, and signal the existence of the RST_STREAM immediately.  Alternatively, the RST_STREAM signal might be suppressed or withheld if stream data is completely received.  In the latter case, the receive stream effectively transitions to &#8220;Data Recvd&#8221; from &#8220;Reset Recvd&#8221;.</p>
<p id="rfc.section.10.2.2.p.11">Once the application has been delivered the signal indicating that the receive stream was reset, the receive stream transitions to the &#8220;Reset Read&#8221; state, which is a terminal state.</p>
<h3 id="rfc.section.10.2.3">
<a href="#rfc.section.10.2.3">10.2.3.</a> <a href="#permitted-frame-types" id="permitted-frame-types">Permitted Frame Types</a>
</h3>
<p id="rfc.section.10.2.3.p.1">The sender of a stream sends just three frame types that affect the state of a stream at either sender or receiver: STREAM (<a href="#frame-stream" class="xref">Section 8.18</a>), STREAM_BLOCKED (<a href="#frame-stream-blocked" class="xref">Section 8.11</a>), and RST_STREAM (<a href="#frame-rst-stream" class="xref">Section 8.3</a>).</p>
<p id="rfc.section.10.2.3.p.2">A sender MUST NOT send any of these frames from a terminal state (&#8220;Data Recvd&#8221; or &#8220;Reset Recvd&#8221;).  A sender MUST NOT send STREAM or STREAM_BLOCKED after sending a RST_STREAM; that is, in the &#8220;Reset Sent&#8221; state in addition to the terminal states.  A receiver could receive any of these frames in any state, but only due to the possibility of delayed delivery of packets carrying them.</p>
<p id="rfc.section.10.2.3.p.3">The receiver of a stream sends MAX_STREAM_DATA (<a href="#frame-max-stream-data" class="xref">Section 8.7</a>) and STOP_SENDING frames (<a href="#frame-stop-sending" class="xref">Section 8.14</a>).</p>
<p id="rfc.section.10.2.3.p.4">The receiver only sends MAX_STREAM_DATA in the &#8220;Recv&#8221; state.  A receiver can send STOP_SENDING in any state where it has not received a RST_STREAM frame; that is states other than &#8220;Reset Recvd&#8221; or &#8220;Reset Read&#8221;.  However there is little value in sending a STOP_SENDING frame after all stream data has been received in the &#8220;Data Recvd&#8221; state.  A sender could receive these frames in any state as a result of delayed delivery of packets.</p>
<h3 id="rfc.section.10.2.4">
<a href="#rfc.section.10.2.4">10.2.4.</a> <a href="#stream-bidi-states" id="stream-bidi-states">Bidirectional Stream States</a>
</h3>
<p id="rfc.section.10.2.4.p.1">A bidirectional stream is composed of a send stream and a receive stream.  Implementations may represent states of the bidirectional stream as composites of send and receive stream states.  The simplest model presents the stream as &#8220;open&#8221; when either send or receive stream is in a non-terminal state and &#8220;closed&#8221; when both send and receive streams are in a terminal state.</p>
<p><a href="#stream-bidi-mapping" class="xref">Table 6</a> shows a more complex mapping of bidirectional stream states that loosely correspond to the stream states in HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a>.  This shows that multiple states on send or receive streams are mapped to the same composite state.  Note that this is just one possibility for such a mapping; this mapping requires that data is acknowledged before the transition to a &#8220;closed&#8221; or &#8220;half-closed&#8221; state.</p>
<div id="rfc.table.6"></div>
<div id="stream-bidi-mapping"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Possible Mapping of Stream States to HTTP/2</caption>
<thead><tr>
<th class="left">Send Stream</th>
<th class="left">Receive Stream</th>
<th class="left">Composite State</th>
</tr></thead>
<tbody>
<tr>
<td class="left">No Stream/Open</td>
<td class="left">No Stream/Recv *1</td>
<td class="left">idle</td>
</tr>
<tr>
<td class="left">Open/Send/Data Sent</td>
<td class="left">Recv/Size Known</td>
<td class="left">open</td>
</tr>
<tr>
<td class="left">Open/Send/Data Sent</td>
<td class="left">Data Recvd/Data Read</td>
<td class="left">half-closed (remote)</td>
</tr>
<tr>
<td class="left">Open/Send/Data Sent</td>
<td class="left">Reset Recvd/Reset Read</td>
<td class="left">half-closed (remote)</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Recv/Size Known</td>
<td class="left">half-closed (local)</td>
</tr>
<tr>
<td class="left">Reset Sent/Reset Recvd</td>
<td class="left">Recv/Size Known</td>
<td class="left">half-closed (local)</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Recv/Size Known</td>
<td class="left">half-closed (local)</td>
</tr>
<tr>
<td class="left">Reset Sent/Reset Recvd</td>
<td class="left">Data Recvd/Data Read</td>
<td class="left">closed</td>
</tr>
<tr>
<td class="left">Reset Sent/Reset Recvd</td>
<td class="left">Reset Recvd/Reset Read</td>
<td class="left">closed</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Data Recvd/Data Read</td>
<td class="left">closed</td>
</tr>
<tr>
<td class="left">Data Recvd</td>
<td class="left">Reset Recvd/Reset Read</td>
<td class="left">closed</td>
</tr>
</tbody>
</table>
<p></p>

<dl>
<dt>Note (*1):</dt>
<dd style="margin-left: 8">A stream is considered &#8220;idle&#8221; if it has not yet been created, or if the receive stream is in the &#8220;Recv&#8221; state without yet having received any frames.</dd>
</dl>
<h2 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> <a href="#solicited-state-transitions" id="solicited-state-transitions">Solicited State Transitions</a>
</h2>
<p id="rfc.section.10.3.p.1">If an endpoint is no longer interested in the data it is receiving on a stream, it MAY send a STOP_SENDING frame identifying that stream to prompt closure of the stream in the opposite direction.  This typically indicates that the receiving application is no longer reading data it receives from the stream, but is not a guarantee that incoming data will be ignored.</p>
<p id="rfc.section.10.3.p.2">STREAM frames received after sending STOP_SENDING are still counted toward the connection and stream flow-control windows, even though these frames will be discarded upon receipt.  This avoids potential ambiguity about which STREAM frames count toward flow control.</p>
<p id="rfc.section.10.3.p.3">A STOP_SENDING frame requests that the receiving endpoint send a RST_STREAM frame.  An endpoint that receives a STOP_SENDING frame MUST send a RST_STREAM frame for that stream, and can use an error code of STOPPING.  If the STOP_SENDING frame is received on a send stream that is already in the &#8220;Data Sent&#8221; state, a RST_STREAM frame MAY still be sent in order to cancel retransmission of previously-sent STREAM frames.</p>
<p id="rfc.section.10.3.p.4">STOP_SENDING SHOULD only be sent for a receive stream that has not been reset. STOP_SENDING is most useful for streams in the &#8220;Recv&#8221; or &#8220;Size Known&#8221; states.</p>
<p id="rfc.section.10.3.p.5">An endpoint is expected to send another STOP_SENDING frame if a packet containing a previous STOP_SENDING is lost.  However, once either all stream data or a RST_STREAM frame has been received for the stream - that is, the stream is in any state other than &#8220;Recv&#8221; or &#8220;Size Known&#8221; - sending a STOP_SENDING frame is unnecessary.</p>
<h2 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> <a href="#stream-concurrency" id="stream-concurrency">Stream Concurrency</a>
</h2>
<p id="rfc.section.10.4.p.1">An endpoint limits the number of concurrently active incoming streams by adjusting the maximum stream ID.  An initial value is set in the transport parameters (see <a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a>) and is subsequently increased by MAX_STREAM_ID frames (see <a href="#frame-max-stream-id" class="xref">Section 8.8</a>).</p>
<p id="rfc.section.10.4.p.2">The maximum stream ID is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum stream ID the server can initiate, and servers specify the maximum stream ID the client can initiate.  Each endpoint may respond on streams initiated by the other peer, regardless of whether it is permitted to initiated new streams.</p>
<p id="rfc.section.10.4.p.3">Endpoints MUST NOT exceed the limit set by their peer.  An endpoint that receives a STREAM frame with an ID greater than the limit it has sent MUST treat this as a stream error of type STREAM_ID_ERROR (<a href="#error-handling" class="xref">Section 12</a>), unless this is a result of a change in the initial offsets (see <a href="#zerortt-parameters" class="xref">Section 7.4.2</a>).</p>
<p id="rfc.section.10.4.p.4">A receiver MUST NOT renege on an advertisement; that is, once a receiver advertises a stream ID via a MAX_STREAM_ID frame, it MUST NOT subsequently advertise a smaller maximum ID.  A sender may receive MAX_STREAM_ID frames out of order; a sender MUST therefore ignore any MAX_STREAM_ID that does not increase the maximum.</p>
<h2 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> <a href="#sending-and-receiving-data" id="sending-and-receiving-data">Sending and Receiving Data</a>
</h2>
<p id="rfc.section.10.5.p.1">Once a stream is created, endpoints may use the stream to send and receive data.  Each endpoint may send a series of STREAM frames encapsulating data on a stream until the stream is terminated in that direction.  Streams are an ordered byte-stream abstraction, and they have no other structure within them.  STREAM frame boundaries are not expected to be preserved in retransmissions from the sender or during delivery to the application at the receiver.</p>
<p id="rfc.section.10.5.p.2">When new data is to be sent on a stream, a sender MUST set the encapsulating STREAM frame&#8217;s offset field to the stream offset of the first byte of this new data.  The first octet of data on a stream has an offset of 0.  An endpoint is expected to send every stream octet.  The largest offset delivered on a stream MUST be less than 2^62. A receiver MUST ensure that received stream data is delivered to the application as an ordered byte-stream.  Data received out of order MUST be buffered for later delivery, as long as it is not in violation of the receiver&#8217;s flow control limits.</p>
<p id="rfc.section.10.5.p.3">An endpoint MUST NOT send data on any stream without ensuring that it is within the data limits set by its peer.  The cryptographic handshake stream, Stream 0, is exempt from the connection-level data limits established by MAX_DATA. Data on stream 0 other than the initial cryptographic handshake message is still subject to stream-level data limits and MAX_STREAM_DATA. This message is exempt from flow control because it needs to be sent in a single packet regardless of the server&#8217;s flow control state. This rule applies even for 0-RTT handshakes where the remembered value of MAX_STREAM_DATA would not permit sending a full initial cryptographic handshake message.</p>
<p id="rfc.section.10.5.p.4">Flow control is described in detail in <a href="#flow-control" class="xref">Section 11</a>, and congestion control is described in the companion document <a href="#QUIC-RECOVERY" class="xref">[QUIC-RECOVERY]</a>.</p>
<h2 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> <a href="#stream-prioritization" id="stream-prioritization">Stream Prioritization</a>
</h2>
<p id="rfc.section.10.6.p.1">Stream multiplexing has a significant effect on application performance if resources allocated to streams are correctly prioritized.  Experience with other multiplexed protocols, such as HTTP/2 <a href="#HTTP2" class="xref">[HTTP2]</a>, shows that effective prioritization strategies have a significant positive impact on performance.</p>
<p id="rfc.section.10.6.p.2">QUIC does not provide frames for exchanging prioritization information.  Instead it relies on receiving priority information from the application that uses QUIC.  Protocols that use QUIC are able to define any prioritization scheme that suits their application semantics.  A protocol might define explicit messages for signaling priority, such as those defined in HTTP/2; it could define rules that allow an endpoint to determine priority based on context; or it could leave the determination to the application.</p>
<p id="rfc.section.10.6.p.3">A QUIC implementation SHOULD provide ways in which an application can indicate the relative priority of streams.  When deciding which streams to dedicate resources to, QUIC SHOULD use the information provided by the application.  Failure to account for priority of streams can result in suboptimal performance.</p>
<p id="rfc.section.10.6.p.4">Stream priority is most relevant when deciding which stream data will be transmitted.  Often, there will be limits on what can be transmitted as a result of connection flow control or the current congestion controller state.</p>
<p id="rfc.section.10.6.p.5">Giving preference to the transmission of its own management frames ensures that the protocol functions efficiently.  That is, prioritizing frames other than STREAM frames ensures that loss recovery, congestion control, and flow control operate effectively.</p>
<p id="rfc.section.10.6.p.6">Stream 0 MUST be prioritized over other streams prior to the completion of the cryptographic handshake.  This includes the retransmission of the second flight of client handshake messages, that is, the TLS Finished and any client authentication messages.</p>
<p id="rfc.section.10.6.p.7">STREAM frames that are determined to be lost SHOULD be retransmitted before sending new data, unless application priorities indicate otherwise.  Retransmitting lost stream data can fill in gaps, which allows the peer to consume already received data and free up flow control window.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#flow-control" id="flow-control">Flow Control</a>
</h1>
<p id="rfc.section.11.p.1">It is necessary to limit the amount of data that a sender may have outstanding at any time, so as to prevent a fast sender from overwhelming a slow receiver, or to prevent a malicious sender from consuming significant resources at a receiver.  This section describes QUIC&#8217;s flow-control mechanisms.</p>
<p id="rfc.section.11.p.2">QUIC employs a credit-based flow-control scheme similar to HTTP/2&#8217;s flow control <a href="#HTTP2" class="xref">[HTTP2]</a>.  A receiver advertises the number of octets it is prepared to receive on a given stream and for the entire connection.  This leads to two levels of flow control in QUIC: (i) Connection flow control, which prevents senders from exceeding a receiver&#8217;s buffer capacity for the connection, and (ii) Stream flow control, which prevents a single stream from consuming the entire receive buffer for a connection.</p>
<p id="rfc.section.11.p.3">A data receiver sends MAX_STREAM_DATA or MAX_DATA frames to the sender to advertise additional credit. MAX_STREAM_DATA frames send the the maximum absolute byte offset of a stream, while MAX_DATA sends the maximum sum of the absolute byte offsets of all streams other than stream 0.</p>
<p id="rfc.section.11.p.4">A receiver MAY advertise a larger offset at any point by sending MAX_DATA or MAX_STREAM_DATA frames.  A receiver MUST NOT renege on an advertisement; that is, once a receiver advertises an offset, it MUST NOT subsequently advertise a smaller offset.  A sender could receive MAX_DATA or MAX_STREAM_DATA frames out of order; a sender MUST therefore ignore any flow control offset that does not move the window forward.</p>
<p id="rfc.section.11.p.5">A receiver MUST close the connection with a FLOW_CONTROL_ERROR error (<a href="#error-handling" class="xref">Section 12</a>) if the peer violates the advertised connection or stream data limits.</p>
<p id="rfc.section.11.p.6">A sender SHOULD send BLOCKED or STREAM_BLOCKED frames to indicate it has data to write but is blocked by flow control limits.  These frames are expected to be sent infrequently in common cases, but they are considered useful for debugging and monitoring purposes.</p>
<p id="rfc.section.11.p.7">A receiver advertises credit for a stream by sending a MAX_STREAM_DATA frame with the Stream ID set appropriately. A receiver could use the current offset of data consumed to determine the flow control offset to be advertised.  A receiver MAY send MAX_STREAM_DATA frames in multiple packets in order to make sure that the sender receives an update before running out of flow control credit, even if one of the packets is lost.</p>
<p id="rfc.section.11.p.8">Connection flow control is a limit to the total bytes of stream data sent in STREAM frames on all streams except stream 0.  A receiver advertises credit for a connection by sending a MAX_DATA frame.  A receiver maintains a cumulative sum of bytes received on all contributing streams, which are used to check for flow control violations. A receiver might use a sum of bytes consumed on all contributing streams to determine the maximum data limit to be advertised.</p>
<h2 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#edge-cases-and-other-considerations" id="edge-cases-and-other-considerations">Edge Cases and Other Considerations</a>
</h2>
<p id="rfc.section.11.1.p.1">There are some edge cases which must be considered when dealing with stream and connection level flow control.  Given enough time, both endpoints must agree on flow control state.  If one end believes it can send more than the other end is willing to receive, the connection will be torn down when too much data arrives.</p>
<p id="rfc.section.11.1.p.2">Conversely if a sender believes it is blocked, while endpoint B expects more data can be received, then the connection can be in a deadlock, with the sender waiting for a MAX_DATA or MAX_STREAM_DATA frame which will never come.</p>
<p id="rfc.section.11.1.p.3">On receipt of a RST_STREAM frame, an endpoint will tear down state for the matching stream and ignore further data arriving on that stream.  This could result in the endpoints getting out of sync, since the RST_STREAM frame may have arrived out of order and there may be further bytes in flight.  The data sender would have counted the data against its connection level flow control budget, but a receiver that has not received these bytes would not know to include them as well.  The receiver must learn the number of bytes that were sent on the stream to make the same adjustment in its connection flow controller.</p>
<p id="rfc.section.11.1.p.4">To avoid this de-synchronization, a RST_STREAM sender MUST include the final byte offset sent on the stream in the RST_STREAM frame.  On receiving a RST_STREAM frame, a receiver definitively knows how many bytes were sent on that stream before the RST_STREAM frame, and the receiver MUST use the final offset to account for all bytes sent on the stream in its connection level flow controller.</p>
<h3 id="rfc.section.11.1.1">
<a href="#rfc.section.11.1.1">11.1.1.</a> <a href="#response-to-a-rststream" id="response-to-a-rststream">Response to a RST_STREAM</a>
</h3>
<p id="rfc.section.11.1.1.p.1">RST_STREAM terminates one direction of a stream abruptly.  Whether any action or response can or should be taken on the data already received is an application-specific issue, but it will often be the case that upon receipt of a RST_STREAM an endpoint will choose to stop sending data in its own direction. If the sender of a RST_STREAM wishes to explicitly state that no future data will be processed, that endpoint MAY send a STOP_SENDING frame at the same time.</p>
<h3 id="rfc.section.11.1.2">
<a href="#rfc.section.11.1.2">11.1.2.</a> <a href="#fc-credit" id="fc-credit">Data Limit Increments</a>
</h3>
<p id="rfc.section.11.1.2.p.1">This document leaves when and how many bytes to advertise in a MAX_DATA or MAX_STREAM_DATA to implementations, but offers a few considerations.  These frames contribute to connection overhead.  Therefore frequently sending frames with small changes is undesirable.  At the same time, infrequent updates require larger increments to limits if blocking is to be avoided.  Thus, larger updates require a receiver to commit to larger resource commitments.  Thus there is a tradeoff between resource commitment and overhead when determining how large a limit is advertised.</p>
<p id="rfc.section.11.1.2.p.2">A receiver MAY use an autotuning mechanism to tune the frequency and amount that it increases data limits based on a roundtrip time estimate and the rate at which the receiving application consumes data, similar to common TCP implementations.</p>
<h3 id="rfc.section.11.1.3">
<a href="#rfc.section.11.1.3">11.1.3.</a> <a href="#handshake-exemption" id="handshake-exemption">Handshake Exemption</a>
</h3>
<p id="rfc.section.11.1.3.p.1">During the initial handshake, an endpoint could need to send a larger message on stream 0 than would ordinarily be permitted by the peer&#8217;s initial stream flow control window. Since MAX_STREAM_DATA frames are not permitted in these early packets, the peer cannot provide additional flow control window in order to complete the handshake.</p>
<p id="rfc.section.11.1.3.p.2">Endpoints MAY exceed the flow control limits on stream 0 prior to the completion of the cryptographic handshake.  (That is, in Initial, Retry, and Handshake packets.)  However, once the handshake is complete, endpoints MUST NOT send additional data beyond the peer&#8217;s permitted offset.  If the amount of data sent during the handshake exceeds the peer&#8217;s maximum offset, the endpoint cannot send additional data on stream 0 until the peer has sent a MAX_STREAM_DATA frame indicating a larger maximum offset.</p>
<h2 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> <a href="#stream-limit-increment" id="stream-limit-increment">Stream Limit Increment</a>
</h2>
<p id="rfc.section.11.2.p.1">As with flow control, this document leaves when and how many streams to make available to a peer via MAX_STREAM_ID to implementations, but offers a few considerations.  MAX_STREAM_ID frames constitute minimal overhead, while withholding MAX_STREAM_ID frames can prevent the peer from using the available parallelism.</p>
<p id="rfc.section.11.2.p.2">Implementations will likely want to increase the maximum stream ID as peer-initiated streams close.  A receiver MAY also advance the maximum stream ID based on current activity, system conditions, and other environmental factors.</p>
<h3 id="rfc.section.11.2.1">
<a href="#rfc.section.11.2.1">11.2.1.</a> <a href="#blocking" id="blocking">Blocking on Flow Control</a>
</h3>
<p id="rfc.section.11.2.1.p.1">If a sender does not receive a MAX_DATA or MAX_STREAM_DATA frame when it has run out of flow control credit, the sender will be blocked and SHOULD send a BLOCKED or STREAM_BLOCKED frame.  These frames are expected to be useful for debugging at the receiver; they do not require any other action.  A receiver SHOULD NOT wait for a BLOCKED or STREAM_BLOCKED frame before sending MAX_DATA or MAX_STREAM_DATA, since doing so will mean that a sender is unable to send for an entire round trip.</p>
<p id="rfc.section.11.2.1.p.2">For smooth operation of the congestion controller, it is generally considered best to not let the sender go into quiescence if avoidable.  To avoid blocking a sender, and to reasonably account for the possibiity of loss, a receiver should send a MAX_DATA or MAX_STREAM_DATA frame at least two roundtrips before it expects the sender to get blocked.</p>
<p id="rfc.section.11.2.1.p.3">A sender sends a single BLOCKED or STREAM_BLOCKED frame only once when it reaches a data limit.  A sender SHOULD NOT send multiple BLOCKED or STREAM_BLOCKED frames for the same data limit, unless the original frame is determined to be lost.  Another BLOCKED or STREAM_BLOCKED frame can be sent after the data limit is increased.</p>
<h2 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> <a href="#final-offset" id="final-offset">Stream Final Offset</a>
</h2>
<p id="rfc.section.11.3.p.1">The final offset is the count of the number of octets that are transmitted on a stream.  For a stream that is reset, the final offset is carried explicitly in a RST_STREAM frame.  Otherwise, the final offset is the offset of the end of the data carried in a STREAM frame marked with a FIN flag, or 0 in the case of incoming unidirectional streams.</p>
<p id="rfc.section.11.3.p.2">An endpoint will know the final offset for a stream when the receive stream enters the &#8220;Size Known&#8221; or &#8220;Reset Recvd&#8221; state.</p>
<p id="rfc.section.11.3.p.3">An endpoint MUST NOT send data on a stream at or beyond the final offset.</p>
<p id="rfc.section.11.3.p.4">Once a final offset for a stream is known, it cannot change.  If a RST_STREAM or STREAM frame causes the final offset to change for a stream, an endpoint SHOULD respond with a FINAL_OFFSET_ERROR error (see <a href="#error-handling" class="xref">Section 12</a>).  A receiver SHOULD treat receipt of data at or beyond the final offset as a FINAL_OFFSET_ERROR error, even after a stream is closed.  Generating these errors is not mandatory, but only because requiring that an endpoint generate these errors also means that the endpoint needs to maintain the final offset state for closed streams, which could mean a significant state commitment.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#error-handling" id="error-handling">Error Handling</a>
</h1>
<p id="rfc.section.12.p.1">An endpoint that detects an error SHOULD signal the existence of that error to its peer.  Errors can affect an entire connection (see <a href="#connection-errors" class="xref">Section 12.1</a>), or a single stream (see <a href="#stream-errors" class="xref">Section 12.2</a>).</p>
<p id="rfc.section.12.p.2">The most appropriate error code (<a href="#error-codes" class="xref">Section 12.3</a>) SHOULD be included in the frame that signals the error.  Where this specification identifies error conditions, it also identifies the error code that is used.</p>
<p id="rfc.section.12.p.3">A stateless reset (<a href="#stateless-reset" class="xref">Section 7.9.4</a>) is not suitable for any error that can be signaled with a CONNECTION_CLOSE, APPLICATION_CLOSE, or RST_STREAM frame.  A stateless reset MUST NOT be used by an endpoint that has the state necessary to send a frame on the connection.</p>
<h2 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#connection-errors" id="connection-errors">Connection Errors</a>
</h2>
<p id="rfc.section.12.1.p.1">Errors that result in the connection being unusable, such as an obvious violation of protocol semantics or corruption of state that affects an entire connection, MUST be signaled using a CONNECTION_CLOSE or APPLICATION_CLOSE frame (<a href="#frame-connection-close" class="xref">Section 8.4</a>, <a href="#frame-application-close" class="xref">Section 8.5</a>). An endpoint MAY close the connection in this manner even if the error only affects a single stream.</p>
<p id="rfc.section.12.1.p.2">Application protocols can signal application-specific protocol errors using the APPLICATION_CLOSE frame.  Errors that are specific to the transport, including all those described in this document, are carried in a CONNECTION_CLOSE frame.  Other than the type of error code they carry, these frames are identical in format and semantics.</p>
<p id="rfc.section.12.1.p.3">A CONNECTION_CLOSE or APPLICATION_CLOSE frame could be sent in a packet that is lost.  An endpoint SHOULD be prepared to retransmit a packet containing either frame type if it receives more packets on a terminated connection.  Limiting the number of retransmissions and the time over which this final packet is sent limits the effort expended on terminated connections.</p>
<p id="rfc.section.12.1.p.4">An endpoint that chooses not to retransmit packets containing CONNECTION_CLOSE or APPLICATION_CLOSE risks a peer missing the first such packet.  The only mechanism available to an endpoint that continues to receive data for a terminated connection is to use the stateless reset process (<a href="#stateless-reset" class="xref">Section 7.9.4</a>).</p>
<p id="rfc.section.12.1.p.5">An endpoint that receives an invalid CONNECTION_CLOSE or APPLICATION_CLOSE frame MUST NOT signal the existence of the error to its peer.</p>
<h2 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#stream-errors" id="stream-errors">Stream Errors</a>
</h2>
<p id="rfc.section.12.2.p.1">If the error affects a single stream, but otherwise leaves the connection in a recoverable state, the endpoint can send a RST_STREAM frame (<a href="#frame-rst-stream" class="xref">Section 8.3</a>) with an appropriate error code to terminate just the affected stream.</p>
<p id="rfc.section.12.2.p.2">Stream 0 is critical to the functioning of the entire connection.  If stream 0 is closed with either a RST_STREAM or STREAM frame bearing the FIN flag, an endpoint MUST generate a connection error of type PROTOCOL_VIOLATION.</p>
<p id="rfc.section.12.2.p.3">RST_STREAM MUST be instigated by the application and MUST carry an application error code.  Resetting a stream without knowledge of the application protocol could cause the protocol to enter an unrecoverable state.  Application protocols might require certain streams to be reliably delivered in order to guarantee consistent state between endpoints.</p>
<h2 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> <a href="#error-codes" id="error-codes">Transport Error Codes</a>
</h2>
<p id="rfc.section.12.3.p.1">QUIC error codes are 16-bit unsigned integers.</p>
<p id="rfc.section.12.3.p.2">This section lists the defined QUIC transport error codes that may be used in a CONNECTION_CLOSE frame.  These errors apply to the entire connection.</p>
<p></p>

<dl>
<dt>NO_ERROR (0x0):</dt>
<dd style="margin-left: 8">An endpoint uses this with CONNECTION_CLOSE to signal that the connection is being closed abruptly in the absence of any error.</dd>
<dt>INTERNAL_ERROR (0x1):</dt>
<dd style="margin-left: 8">The endpoint encountered an internal error and cannot continue with the connection.</dd>
<dt>FLOW_CONTROL_ERROR (0x3):</dt>
<dd style="margin-left: 8">An endpoint received more data than it permitted in its advertised data limits (see <a href="#flow-control" class="xref">Section 11</a>).</dd>
<dt>STREAM_ID_ERROR (0x4):</dt>
<dd style="margin-left: 8">An endpoint received a frame for a stream identifier that exceeded its advertised maximum stream ID.</dd>
<dt>STREAM_STATE_ERROR (0x5):</dt>
<dd style="margin-left: 8">An endpoint received a frame for a stream that was not in a state that permitted that frame (see <a href="#stream-states" class="xref">Section 10.2</a>).</dd>
<dt>FINAL_OFFSET_ERROR (0x6):</dt>
<dd style="margin-left: 8">An endpoint received a STREAM frame containing data that exceeded the previously established final offset.  Or an endpoint received a RST_STREAM frame containing a final offset that was lower than the maximum offset of data that was already received.  Or an endpoint received a RST_STREAM frame containing a different final offset to the one already established.</dd>
<dt>FRAME_FORMAT_ERROR (0x7):</dt>
<dd style="margin-left: 8">An endpoint received a frame that was badly formatted.  For instance, an empty STREAM frame that omitted the FIN flag, or an ACK frame that has more acknowledgment ranges than the remainder of the packet could carry.  This is a generic error code; an endpoint SHOULD use the more specific frame format error codes (0x1XX) if possible.</dd>
<dt>TRANSPORT_PARAMETER_ERROR (0x8):</dt>
<dd style="margin-left: 8">An endpoint received transport parameters that were badly formatted, included an invalid value, was absent even though it is mandatory, was present though it is forbidden, or is otherwise in error.</dd>
<dt>VERSION_NEGOTIATION_ERROR (0x9):</dt>
<dd style="margin-left: 8">An endpoint received transport parameters that contained version negotiation parameters that disagreed with the version negotiation that it performed.  This error code indicates a potential version downgrade attack.</dd>
<dt>PROTOCOL_VIOLATION (0xA):</dt>
<dd style="margin-left: 8">An endpoint detected an error with protocol compliance that was not covered by more specific error codes.</dd>
<dt>UNSOLICITED_PATH_RESPONSE (0xB):</dt>
<dd style="margin-left: 8">An endpoint received a PATH_RESPONSE frame that did not correspond to any PATH_CHALLENGE frame that it previously sent.</dd>
<dt>FRAME_ERROR (0x1XX):</dt>
<dd style="margin-left: 8">An endpoint detected an error in a specific frame type.  The frame type is included as the last octet of the error code.  For example, an error in a MAX_STREAM_ID frame would be indicated with the code (0x106).</dd>
</dl>
<p id="rfc.section.12.3.p.4">Codes for errors occuring when TLS is used for the crypto handshake are defined in Section 11 of <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>.  See <a href="#iana-error-codes" class="xref">Section 14.2</a> for details of registering new error codes.</p>
<h2 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> <a href="#app-error-codes" id="app-error-codes">Application Protocol Error Codes</a>
</h2>
<p id="rfc.section.12.4.p.1">Application protocol error codes are 16-bit unsigned integers, but the management of application error codes are left to application protocols.  Application protocol error codes are used for the RST_STREAM (<a href="#frame-rst-stream" class="xref">Section 8.3</a>) and APPLICATION_CLOSE (<a href="#frame-application-close" class="xref">Section 8.5</a>) frames.</p>
<p id="rfc.section.12.4.p.2">There is no restriction on the use of the 16-bit error code space for application protocols.  However, QUIC reserves the error code with a value of 0 to mean STOPPING.  The application error code of STOPPING (0) is used by the transport to cancel a stream in response to receipt of a STOP_SENDING frame.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#security-and-privacy-considerations" id="security-and-privacy-considerations">Security and Privacy Considerations</a>
</h1>
<h2 id="rfc.section.13.1">
<a href="#rfc.section.13.1">13.1.</a> <a href="#spoofed-ack-attack" id="spoofed-ack-attack">Spoofed ACK Attack</a>
</h2>
<p id="rfc.section.13.1.p.1">An attacker might be able to receive an address validation token (<a href="#address-validation" class="xref">Section 7.6</a>) from the server and then release the IP address it used to acquire that token.  The attacker may, in the future, spoof this same address (which now presumably addresses a different endpoint), and initiate a 0-RTT connection with a server on the victim&#8217;s behalf.  The attacker can then spoof ACK frames to the server which cause the server to send excessive amounts of data toward the new owner of the IP address.</p>
<p id="rfc.section.13.1.p.2">There are two possible mitigations to this attack.  The simplest one is that a server can unilaterally create a gap in packet-number space.  In the non-attack scenario, the client will send an ACK frame with the larger value for largest acknowledged.  In the attack scenario, the attacker could acknowledge a packet in the gap.  If the server sees an acknowledgment for a packet that was never sent, the connection can be aborted.</p>
<p id="rfc.section.13.1.p.3">The second mitigation is that the server can require that acknowledgments for sent packets match the encryption level of the sent packet.  This mitigation is useful if the connection has an ephemeral forward-secure key that is generated and used for every new connection.  If a packet sent is protected with a forward-secure key, then any acknowledgments that are received for them MUST also be forward-secure protected.  Since the attacker will not have the forward secure key, the attacker will not be able to generate forward-secure protected packets with ACK frames.</p>
<h2 id="rfc.section.13.2">
<a href="#rfc.section.13.2">13.2.</a> <a href="#slowloris-attacks" id="slowloris-attacks">Slowloris Attacks</a>
</h2>
<p id="rfc.section.13.2.p.1">The attacks commonly known as Slowloris <a href="#SLOWLORIS" class="xref">[SLOWLORIS]</a> try to keep many connections to the target endpoint open and hold them open as long as possible.  These attacks can be executed against a QUIC endpoint by generating the minimum amount of activity necessary to avoid being closed for inactivity.  This might involve sending small amounts of data, gradually opening flow control windows in order to control the sender rate, or manufacturing ACK frames that simulate a high loss rate.</p>
<p id="rfc.section.13.2.p.2">QUIC deployments SHOULD provide mitigations for the Slowloris attacks, such as increasing the maximum number of clients the server will allow, limiting the number of connections a single IP address is allowed to make, imposing restrictions on the minimum transfer speed a connection is allowed to have, and restricting the length of time an endpoint is allowed to stay connected.</p>
<h2 id="rfc.section.13.3">
<a href="#rfc.section.13.3">13.3.</a> <a href="#stream-fragmentation-and-reassembly-attacks" id="stream-fragmentation-and-reassembly-attacks">Stream Fragmentation and Reassembly Attacks</a>
</h2>
<p id="rfc.section.13.3.p.1">An adversarial endpoint might intentionally fragment the data on stream buffers in order to cause disproportionate memory commitment.  An adversarial endpoint could open a stream and send some STREAM frames containing arbitrary fragments of the stream content.</p>
<p id="rfc.section.13.3.p.2">The attack is mitigated if flow control windows correspond to available memory.  However, some receivers will over-commit memory and advertise flow control offsets in the aggregate that exceed actual available memory.  The over-commitment strategy can lead to better performance when endpoints are well behaved, but renders endpoints vulnerable to the stream fragmentation attack.</p>
<p id="rfc.section.13.3.p.3">QUIC deployments SHOULD provide mitigations against the stream fragmentation attack.  Mitigations could consist of avoiding over-committing memory, delaying reassembly of STREAM frames, implementing heuristics based on the age and duration of reassembly holes, or some combination.</p>
<h2 id="rfc.section.13.4">
<a href="#rfc.section.13.4">13.4.</a> <a href="#stream-commitment-attack" id="stream-commitment-attack">Stream Commitment Attack</a>
</h2>
<p id="rfc.section.13.4.p.1">An adversarial endpoint can open lots of streams, exhausting state on an endpoint.  The adversarial endpoint could repeat the process on a large number of connections, in a manner similar to SYN flooding attacks in TCP.</p>
<p id="rfc.section.13.4.p.2">Normally, clients will open streams sequentially, as explained in <a href="#stream-id" class="xref">Section 10.1</a>.  However, when several streams are initiated at short intervals, transmission error may cause STREAM DATA frames opening streams to be received out of sequence.  A receiver is obligated to open intervening streams if a higher-numbered stream ID is received.  Thus, on a new connection, opening stream 2000001 opens 1 million streams, as required by the specification.</p>
<p id="rfc.section.13.4.p.3">The number of active streams is limited by the concurrent stream limit transport parameter, as explained in <a href="#stream-concurrency" class="xref">Section 10.4</a>.  If chosen judisciously, this limit mitigates the effect of the stream commitment attack.  However, setting the limit too low could affect performance when applications expect to open large number of streams.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h2 id="rfc.section.14.1">
<a href="#rfc.section.14.1">14.1.</a> <a href="#iana-transport-parameters" id="iana-transport-parameters">QUIC Transport Parameter Registry</a>
</h2>
<p id="rfc.section.14.1.p.1">IANA [SHALL add/has added] a registry for &#8220;QUIC Transport Parameters&#8221; under a &#8220;QUIC Protocol&#8221; heading.</p>
<p id="rfc.section.14.1.p.2">The &#8220;QUIC Transport Parameters&#8221; registry governs a 16-bit space.  This space is split into two spaces that are governed by different policies.  Values with the first byte in the range 0x00 to 0xfe (in hexadecimal) are assigned via the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>.  Values with the first byte 0xff are reserved for Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.14.1.p.3">Registrations MUST include the following fields:</p>
<p></p>

<dl>
<dt>Value:</dt>
<dd style="margin-left: 8">The numeric value of the assignment (registrations will be between 0x0000 and 0xfeff).</dd>
<dt>Parameter Name:</dt>
<dd style="margin-left: 8">A short mnemonic for the parameter.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a publicly available specification for the value.</dd>
</dl>
<p id="rfc.section.14.1.p.5">The nominated expert(s) verify that a specification exists and is readily accessible.  The expert(s) are encouraged to be biased towards approving registrations unless they are abusive, frivolous, or actively harmful (not merely aesthetically displeasing, or architecturally dubious).</p>
<p id="rfc.section.14.1.p.6">The initial contents of this registry are shown in <a href="#iana-tp-table" class="xref">Table 7</a>.</p>
<div id="rfc.table.7"></div>
<div id="iana-tp-table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Initial QUIC Transport Parameters Entries</caption>
<thead><tr>
<th class="left">Value</th>
<th class="left">Parameter Name</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x0000</td>
<td class="left">initial_max_stream_data</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0001</td>
<td class="left">initial_max_data</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0002</td>
<td class="left">initial_max_stream_id_bidi</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0003</td>
<td class="left">idle_timeout</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0004</td>
<td class="left">omit_connection_id</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0005</td>
<td class="left">max_packet_size</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0006</td>
<td class="left">stateless_reset_token</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0007</td>
<td class="left">ack_delay_exponent</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
<tr>
<td class="left">0x0008</td>
<td class="left">initial_max_stream_id_uni</td>
<td class="left"><a href="#transport-parameter-definitions" class="xref">Section 7.4.1</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.14.2">
<a href="#rfc.section.14.2">14.2.</a> <a href="#iana-error-codes" id="iana-error-codes">QUIC Transport Error Codes Registry</a>
</h2>
<p id="rfc.section.14.2.p.1">IANA [SHALL add/has added] a registry for &#8220;QUIC Transport Error Codes&#8221; under a &#8220;QUIC Protocol&#8221; heading.</p>
<p id="rfc.section.14.2.p.2">The &#8220;QUIC Transport Error Codes&#8221; registry governs a 16-bit space.  This space is split into two spaces that are governed by different policies.  Values with the first byte in the range 0x00 to 0xfe (in hexadecimal) are assigned via the Specification Required policy <a href="#RFC8126" class="xref">[RFC8126]</a>.  Values with the first byte 0xff are reserved for Private Use <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.14.2.p.3">Registrations MUST include the following fields:</p>
<p></p>

<dl>
<dt>Value:</dt>
<dd style="margin-left: 8">The numeric value of the assignment (registrations will be between 0x0000 and 0xfeff).</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">A short mnemonic for the parameter.</dd>
<dt>Description:</dt>
<dd style="margin-left: 8">A brief description of the error code semantics, which MAY be a summary if a specification reference is provided.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a publicly available specification for the value.</dd>
</dl>
<p id="rfc.section.14.2.p.5">The initial contents of this registry are shown in <a href="#iana-error-table" class="xref">Table 8</a>.  Note that FRAME_ERROR takes the range from 0x100 to 0x1FF and private use occupies the range from 0xFE00 to 0xFFFF.</p>
<div id="rfc.table.8"></div>
<div id="iana-error-table"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Initial QUIC Transport Error Codes Entries</caption>
<thead><tr>
<th class="left">Value</th>
<th class="left">Error</th>
<th class="left">Description</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">0x0</td>
<td class="left">NO_ERROR</td>
<td class="left">No error</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x1</td>
<td class="left">INTERNAL_ERROR</td>
<td class="left">Implementation error</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x3</td>
<td class="left">FLOW_CONTROL_ERROR</td>
<td class="left">Flow control error</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x4</td>
<td class="left">STREAM_ID_ERROR</td>
<td class="left">Invalid stream ID</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x5</td>
<td class="left">STREAM_STATE_ERROR</td>
<td class="left">Frame received in invalid stream state</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x6</td>
<td class="left">FINAL_OFFSET_ERROR</td>
<td class="left">Change to final stream offset</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x7</td>
<td class="left">FRAME_FORMAT_ERROR</td>
<td class="left">Generic frame format error</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x8</td>
<td class="left">TRANSPORT_PARAMETER_ERROR</td>
<td class="left">Error in transport parameters</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x9</td>
<td class="left">VERSION_NEGOTIATION_ERROR</td>
<td class="left">Version negotiation failure</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0xA</td>
<td class="left">PROTOCOL_VIOLATION</td>
<td class="left">Generic protocol violation</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0xB</td>
<td class="left">UNSOLICITED_PATH_RESPONSE</td>
<td class="left">Unsolicited PATH_RESPONSE frame</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
<tr>
<td class="left">0x100-0x1FF</td>
<td class="left">FRAME_ERROR</td>
<td class="left">Specific frame format error</td>
<td class="left"><a href="#error-codes" class="xref">Section 12.3</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.references">
<a href="#rfc.references">15.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">15.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-21">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-21, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="PLPMTUD">[PLPMTUD]</b></td>
<td class="top">
<a>Mathis, M.</a> and <a>J. Heffner</a>, "<a href="https://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>", RFC 4821, DOI 10.17487/RFC4821, March 2007.</td>
</tr>
<tr>
<td class="reference"><b id="PMTUDv4">[PMTUDv4]</b></td>
<td class="top">
<a>Mogul, J.</a> and <a>S. Deering</a>, "<a href="https://tools.ietf.org/html/rfc1191">Path MTU discovery</a>", RFC 1191, DOI 10.17487/RFC1191, November 1990.</td>
</tr>
<tr>
<td class="reference"><b id="PMTUDv6">[PMTUDv6]</b></td>
<td class="top">
<a>McCann, J.</a>, <a>Deering, S.</a>, <a>Mogul, J.</a> and <a>R. Hinden</a>, "<a href="https://tools.ietf.org/html/rfc8201">Path MTU Discovery for IP version 6</a>", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-RECOVERY">[QUIC-RECOVERY]</b></td>
<td class="top">
<a title="Google">Iyengar, J.</a> and <a title="Google">I. Swett</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery">QUIC Loss Detection and Congestion Control</a>", Internet-Draft draft-ietf-quic-recovery, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TLS">[QUIC-TLS]</b></td>
<td class="top">
<a title="Mozilla">Thomson, M.</a> and <a title="sn3rd">S. Turner</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-tls">Using Transport Layer Security (TLS) to Secure QUIC</a>", Internet-Draft draft-ietf-quic-tls, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1191">[RFC1191]</b></td>
<td class="top">
<a>Mogul, J.</a> and <a>S. Deering</a>, "<a href="https://tools.ietf.org/html/rfc1191">Path MTU discovery</a>", RFC 1191, DOI 10.17487/RFC1191, November 1990.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="https://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4821">[RFC4821]</b></td>
<td class="top">
<a>Mathis, M.</a> and <a>J. Heffner</a>, "<a href="https://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>", RFC 4821, DOI 10.17487/RFC4821, March 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8126">[RFC8126]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Leiba, B.</a> and <a>T. Narten</a>, "<a href="https://tools.ietf.org/html/rfc8126">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">15.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="EARLY-DESIGN">[EARLY-DESIGN]</b></td>
<td class="top">
<a>Roskind, J.</a>, "<a href="https://goo.gl/dMVtFi">QUIC: Multiplexed Transport Over UDP</a>", December 2013.</td>
</tr>
<tr>
<td class="reference"><b id="HTTP2">[HTTP2]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-INVARIANTS">[QUIC-INVARIANTS]</b></td>
<td class="top">
<a title="Mozilla">Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-invariants">Version-Independent Properties of QUIC</a>", Internet-Draft draft-ietf-quic-invariants, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2104">[RFC2104]</b></td>
<td class="top">
<a>Krawczyk, H.</a>, <a>Bellare, M.</a> and <a>R. Canetti</a>, "<a href="https://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>", RFC 2104, DOI 10.17487/RFC2104, February 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2360">[RFC2360]</b></td>
<td class="top">
<a>Scott, G.</a>, "<a href="https://tools.ietf.org/html/rfc2360">Guide for Internet Standards Writers</a>", BCP 22, RFC 2360, DOI 10.17487/RFC2360, June 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4787">[RFC4787]</b></td>
<td class="top">
<a>Audet, F.</a> and <a>C. Jennings</a>, "<a href="https://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6824">[RFC6824]</b></td>
<td class="top">
<a>Ford, A.</a>, <a>Raiciu, C.</a>, <a>Handley, M.</a> and <a>O. Bonaventure</a>, "<a href="https://tools.ietf.org/html/rfc6824">TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6824, DOI 10.17487/RFC6824, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7301">[RFC7301]</b></td>
<td class="top">
<a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
</tr>
<tr>
<td class="reference"><b id="SLOWLORIS">[SLOWLORIS]</b></td>
<td class="top">
<a>RSnake Hansen, R.</a>, "<a href="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">Welcome to Slowloris...</a>", June 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SST">[SST]</b></td>
<td class="top">
<a>Ford, B.</a>, "<a>Structured streams</a>", ACM SIGCOMM Computer Communication Review Vol. 37, pp. 361, DOI 10.1145/1282427.1282421, October 2007.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p id="rfc.section.A.p.1">The original authors of this specification were Ryan Hamilton, Jana Iyengar, Ian Swett, and Alyssa Wilk.</p>
<p id="rfc.section.A.p.2">The original design and rationale behind this protocol draw significantly from work by Jim Roskind <a href="#EARLY-DESIGN" class="xref">[EARLY-DESIGN]</a>. In alphabetical order, the contributors to the pre-IETF QUIC project at Google are: Britt Cyr, Jeremy Dorfman, Ryan Hamilton, Jana Iyengar, Fedor Kouranov, Charles Krasic, Jo Kulik, Adam Langley, Jim Roskind, Robbie Shade, Satyam Shekhar, Cherie Shi, Ian Swett, Raman Tenneti, Victor Vasiliev, Antonio Vicente, Patrik Westin, Alyssa Wilk, Dale Worley, Fan Yang, Dan Zhang, Daniel Ziegler.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.B.p.1">Special thanks are due to the following for helping shape pre-IETF QUIC and its deployment: Chris Bentzel, Misha Efimov, Roberto Peon, Alistair Riddoch, Siddharth Vijayakrishnan, and Assar Westerlund.</p>
<p id="rfc.section.B.p.2">This document has benefited immensely from various private discussions and public ones on the quic@ietf.org and proto-quic@chromium.org mailing lists. Our thanks to all.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong> Please remove this section prior to publication of a final version of this document.</li></ul>
<p id="rfc.section.C.p.2">Issue and pull request numbers are listed with a leading octothorp.</p>
<h2 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#since-draft-ietf-quic-transport-09" id="since-draft-ietf-quic-transport-09">Since draft-ietf-quic-transport-09</a>
</h2>
<p></p>

<ul><li>Added PATH_CHALLENGE and PATH_RESPONSE frames to replace PING with Data and PONG frame. Changed ACK frame type from 0x0e to 0x0d. (#1091, #1086)</li></ul>
<h2 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#since-draft-ietf-quic-transport-08" id="since-draft-ietf-quic-transport-08">Since draft-ietf-quic-transport-08</a>
</h2>
<p></p>

<ul>
<li>Clarified requirements for BLOCKED usage (#65,  #924)</li>
<li>BLOCKED frame now includes reason for blocking (#452, #924, #927, #928)</li>
<li>GAP limitation in ACK Frame (#613)</li>
<li>Improved PMTUD description (#614, #1036)</li>
<li>Clarified stream state machine (#634, #662, #894)</li>
<li>Reserved versions don&#8217;t need to be generated deterministically (#831, #931)</li>
<li>You don&#8217;t always need the draining period (#871)</li>
<li>Stateless reset clarified as version-specific (#930, #986)</li>
<li>initial_max_stream_id_x transport parameters are optional (#970, #971)</li>
<li>Ack Delay assumes a default value during the handshake (#1007, #1009)</li>
<li>Removed transport parameters from NewSessionTicket (#1015)</li>
</ul>
<h2 id="rfc.appendix.C.3">
<a href="#rfc.appendix.C.3">C.3.</a> <a href="#since-draft-ietf-quic-transport-07" id="since-draft-ietf-quic-transport-07">Since draft-ietf-quic-transport-07</a>
</h2>
<p></p>

<ul>
<li>The long header now has version before packet number (#926, #939)</li>
<li>Rename and consolidate packet types (#846, #822, #847)</li>
<li>Packet types are assigned new codepoints and the Connection ID Flag is inverted (#426, #956)</li>
<li>Removed type for Version Negotiation and use Version 0 (#963, #968)</li>
<li>Streams are split into unidirectional and bidirectional (#643, #656, #720, #872, #175, #885) <ul>
<li>Stream limits now have separate uni- and bi-directinal transport parameters (#909, #958)</li>
<li>Stream limit transport parameters are now optional and default to 0 (#970, #971)</li>
</ul>
</li>
<li>The stream state machine has been split into read and write (#634, #894)</li>
<li>Employ variable-length integer encodings throughout (#595)</li>
<li>Improvements to connection close <ul>
<li>Added distinct closing and draining states (#899, #871)</li>
<li>Draining period can terminate early (#869, #870)</li>
<li>Clarifications about stateless reset (#889, #890)</li>
</ul>
</li>
<li>Address validation for connection migration (#161, #732, #878)</li>
<li>Clearly defined retransmission rules for BLOCKED (#452, #65, #924)</li>
<li>negotiated_version is sent in server transport parameters (#710, #959)</li>
<li>Increased the range over which packet numbers are randomized (#864, #850, #964)</li>
</ul>
<h2 id="rfc.appendix.C.4">
<a href="#rfc.appendix.C.4">C.4.</a> <a href="#since-draft-ietf-quic-transport-06" id="since-draft-ietf-quic-transport-06">Since draft-ietf-quic-transport-06</a>
</h2>
<p></p>

<ul>
<li>Replaced FNV-1a with AES-GCM for all &#8220;Cleartext&#8221; packets (#554)</li>
<li>Split error code space between application and transport (#485)</li>
<li>Stateless reset token moved to end (#820)</li>
<li>1-RTT-protected long header types removed (#848)</li>
<li>No acknowledgments during draining period (#852)</li>
<li>Remove &#8220;application close&#8221; as a separate close type (#854)</li>
<li>Remove timestamps from the ACK frame (#841)</li>
<li>Require transport parameters to only appear once (#792)</li>
</ul>
<h2 id="rfc.appendix.C.5">
<a href="#rfc.appendix.C.5">C.5.</a> <a href="#since-draft-ietf-quic-transport-05" id="since-draft-ietf-quic-transport-05">Since draft-ietf-quic-transport-05</a>
</h2>
<p></p>

<ul>
<li>Stateless token is server-only (#726)</li>
<li>Refactor section on connection termination (#733, #748, #328, #177)</li>
<li>Limit size of Version Negotiation packet (#585)</li>
<li>Clarify when and what to ack (#736)</li>
<li>Renamed STREAM_ID_NEEDED to STREAM_ID_BLOCKED</li>
<li>Clarify Keep-alive requirements (#729)</li>
</ul>
<h2 id="rfc.appendix.C.6">
<a href="#rfc.appendix.C.6">C.6.</a> <a href="#since-draft-ietf-quic-transport-04" id="since-draft-ietf-quic-transport-04">Since draft-ietf-quic-transport-04</a>
</h2>
<p></p>

<ul>
<li>Introduce STOP_SENDING frame, RST_STREAM only resets in one direction (#165)</li>
<li>Removed GOAWAY; application protocols are responsible for graceful shutdown (#696)</li>
<li>Reduced the number of error codes (#96, #177, #184, #211)</li>
<li>Version validation fields can&#8217;t move or change (#121)</li>
<li>Removed versions from the transport parameters in a NewSessionTicket message (#547)</li>
<li>Clarify the meaning of &#8220;bytes in flight&#8221; (#550)</li>
<li>Public reset is now stateless reset and not visible to the path (#215)</li>
<li>Reordered bits and fields in STREAM frame (#620)</li>
<li>Clarifications to the stream state machine (#572, #571)</li>
<li>Increased the maximum length of the Largest Acknowledged field in ACK frames to 64 bits (#629)</li>
<li>truncate_connection_id is renamed to omit_connection_id (#659)</li>
<li>CONNECTION_CLOSE terminates the connection like TCP RST (#330, #328)</li>
<li>Update labels used in HKDF-Expand-Label to match TLS 1.3 (#642)</li>
</ul>
<h2 id="rfc.appendix.C.7">
<a href="#rfc.appendix.C.7">C.7.</a> <a href="#since-draft-ietf-quic-transport-03" id="since-draft-ietf-quic-transport-03">Since draft-ietf-quic-transport-03</a>
</h2>
<p></p>

<ul>
<li>Change STREAM and RST_STREAM layout</li>
<li>Add MAX_STREAM_ID settings</li>
</ul>
<h2 id="rfc.appendix.C.8">
<a href="#rfc.appendix.C.8">C.8.</a> <a href="#since-draft-ietf-quic-transport-02" id="since-draft-ietf-quic-transport-02">Since draft-ietf-quic-transport-02</a>
</h2>
<p></p>

<ul>
<li>The size of the initial packet payload has a fixed minimum (#267, #472)</li>
<li>Define when Version Negotiation packets are ignored (#284, #294, #241, #143, #474)</li>
<li>The 64-bit FNV-1a algorithm is used for integrity protection of unprotected packets (#167, #480, #481, #517)</li>
<li>Rework initial packet types to change how the connection ID is chosen (#482, #442, #493)</li>
<li>No timestamps are forbidden in unprotected packets (#542, #429)</li>
<li>Cryptographic handshake is now on stream 0 (#456)</li>
<li>Remove congestion control exemption for cryptographic handshake (#248, #476)</li>
<li>Version 1 of QUIC uses TLS; a new version is needed to use a different handshake protocol (#516)</li>
<li>STREAM frames have a reduced number of offset lengths (#543, #430)</li>
<li>Split some frames into separate connection- and stream- level frames (#443) <ul>
<li>WINDOW_UPDATE split into MAX_DATA and MAX_STREAM_DATA (#450)</li>
<li>BLOCKED split to match WINDOW_UPDATE split (#454)</li>
<li>Define STREAM_ID_NEEDED frame (#455)</li>
</ul>
</li>
<li>A NEW_CONNECTION_ID frame supports connection migration without linkability (#232, #491, #496)</li>
<li>Transport parameters for 0-RTT are retained from a previous connection (#405, #513, #512) <ul><li>A client in 0-RTT no longer required to reset excess streams (#425, #479)</li></ul>
</li>
<li>Expanded security considerations (#440, #444, #445, #448)</li>
</ul>
<h2 id="rfc.appendix.C.9">
<a href="#rfc.appendix.C.9">C.9.</a> <a href="#since-draft-ietf-quic-transport-01" id="since-draft-ietf-quic-transport-01">Since draft-ietf-quic-transport-01</a>
</h2>
<p></p>

<ul>
<li>Defined short and long packet headers (#40, #148, #361)</li>
<li>Defined a versioning scheme and stable fields (#51, #361)</li>
<li>Define reserved version values for &#8220;greasing&#8221; negotiation (#112, #278)</li>
<li>The initial packet number is randomized (#35, #283)</li>
<li>Narrow the packet number encoding range requirement (#67, #286, #299, #323, #356)</li>
<li>Defined client address validation (#52, #118, #120, #275)</li>
<li>Define transport parameters as a TLS extension (#49, #122)</li>
<li>SCUP and COPT parameters are no longer valid (#116, #117)</li>
<li>Transport parameters for 0-RTT are either remembered from before, or assume default values (#126)</li>
<li>The server chooses connection IDs in its final flight (#119, #349, #361)</li>
<li>The server echoes the Connection ID and packet number fields when sending a Version Negotiation packet (#133, #295, #244)</li>
<li>Defined a minimum packet size for the initial handshake packet from the client (#69, #136, #139, #164)</li>
<li>Path MTU Discovery (#64, #106)</li>
<li>The initial handshake packet from the client needs to fit in a single packet (#338)</li>
<li>Forbid acknowledgment of packets containing only ACK and PADDING (#291)</li>
<li>Require that frames are processed when packets are acknowledged (#381, #341)</li>
<li>Removed the STOP_WAITING frame (#66)</li>
<li>Don&#8217;t require retransmission of old timestamps for lost ACK frames (#308)</li>
<li>Clarified that frames are not retransmitted, but the information in them can be (#157, #298)</li>
<li>Error handling definitions (#335)</li>
<li>Split error codes into four sections (#74)</li>
<li>Forbid the use of Public Reset where CONNECTION_CLOSE is possible (#289)</li>
<li>Define packet protection rules (#336)</li>
<li>Require that stream be entirely delivered or reset, including acknowledgment of all STREAM frames or the RST_STREAM, before it closes (#381)</li>
<li>Remove stream reservation from state machine (#174, #280)</li>
<li>Only stream 1 does not contribute to connection-level flow control (#204)</li>
<li>Stream 1 counts towards the maximum concurrent stream limit (#201, #282)</li>
<li>Remove connection-level flow control exclusion for some streams (except 1) (#246)</li>
<li>RST_STREAM affects connection-level flow control (#162, #163)</li>
<li>Flow control accounting uses the maximum data offset on each stream, rather than bytes received (#378)</li>
<li>Moved length-determining fields to the start of STREAM and ACK (#168, #277)</li>
<li>Added the ability to pad between frames (#158, #276)</li>
<li>Remove error code and reason phrase from GOAWAY (#352, #355)</li>
<li>GOAWAY includes a final stream number for both directions (#347)</li>
<li>Error codes for RST_STREAM and CONNECTION_CLOSE are now at a consistent offset (#249)</li>
<li>Defined priority as the responsibility of the application protocol (#104, #303)</li>
</ul>
<h2 id="rfc.appendix.C.10">
<a href="#rfc.appendix.C.10">C.10.</a> <a href="#since-draft-ietf-quic-transport-00" id="since-draft-ietf-quic-transport-00">Since draft-ietf-quic-transport-00</a>
</h2>
<p></p>

<ul>
<li>Replaced DIVERSIFICATION_NONCE flag with KEY_PHASE flag</li>
<li>Defined versioning</li>
<li>Reworked description of packet and frame layout</li>
<li>Error code space is divided into regions for each component</li>
<li>Use big endian for all numeric values</li>
</ul>
<h2 id="rfc.appendix.C.11">
<a href="#rfc.appendix.C.11">C.11.</a> <a href="#since-draft-hamilton-quic-transport-protocol-01" id="since-draft-hamilton-quic-transport-protocol-01">Since draft-hamilton-quic-transport-protocol-01</a>
</h2>
<p></p>

<ul>
<li>Adopted as base for draft-ietf-quic-tls</li>
<li>Updated authors/editors list</li>
<li>Added IANA Considerations section</li>
<li>Moved Contributors and Acknowledgments to appendices</li>
</ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri@google.com">jri@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>

</body>
</html>
