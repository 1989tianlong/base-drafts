



QUIC                                                           C. Krasic
Internet-Draft                                               Google, Inc
Intended status: Standards Track                               M. Bishop
Expires: September 20, 2018                          Akamai Technologies
                                                        A. Frindell, Ed.
                                                                Facebook
                                                          March 19, 2018


              QPACK: Header Compression for HTTP over QUIC
                      draft-ietf-quic-qpack-latest

Abstract

   This specification defines QPACK, a compression format for
   efficiently representing HTTP header fields, to be used in HTTP over
   QUIC.  This is a variation of HPACK header compression that seeks to
   reduce head-of-line blocking.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=quic [1].

   Working Group information can be found at https://github.com/quicwg
   [2]; source code and issues list for this draft can be found at
   https://github.com/quicwg/base-drafts/labels/-qpack [3].

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 20, 2018.






Krasic, et al.         Expires September 20, 2018               [Page 1]

Internet-Draft                    QPACK                       March 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Head-of-Line Blocking in HPACK  . . . . . . . . . . . . .   3
     1.2.  Avoiding Head-of-Line Blocking in HTTP/QUIC . . . . . . .   4
   2.  HPACK extensions  . . . . . . . . . . . . . . . . . . . . . .   4
     2.1.  Allowed Instructions  . . . . . . . . . . . . . . . . . .   4
     2.2.  Header Block Prefix . . . . . . . . . . . . . . . . . . .   4
     2.3.  Hybrid absolute-relative indexing . . . . . . . . . . . .   5
     2.4.  Single pass encoding  . . . . . . . . . . . . . . . . . .   6
       2.4.1.  Literal with Above Base Name Index  . . . . . . . . .   6
       2.4.2.  Indexed Header Field with Above Base Index  . . . . .   7
     2.5.  Preventing Eviction Races . . . . . . . . . . . . . . . .   7
       2.5.1.  Blocked Evictions . . . . . . . . . . . . . . . . . .   7
     2.6.  Refreshing Entries with Duplication . . . . . . . . . . .   7
   3.  Performance considerations  . . . . . . . . . . . . . . . . .   8
     3.1.  Speculative table updates . . . . . . . . . . . . . . . .   8
     3.2.  Additional state beyond HPACK.  . . . . . . . . . . . . .   8
       3.2.1.  Vulnerable Entries  . . . . . . . . . . . . . . . . .   8
       3.2.2.  Safe evictions  . . . . . . . . . . . . . . . . . . .   8
       3.2.3.  Decoder Blocking  . . . . . . . . . . . . . . . . . .   9
     3.3.  Sample One Pass Encoding Algorithm  . . . . . . . . . . .   9
   4.  Security Considerations . . . . . . . . . . . . . . . . . . .  11
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11
   6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     6.1.  Normative References  . . . . . . . . . . . . . . . . . .  11
     6.2.  Informative References  . . . . . . . . . . . . . . . . .  11
     6.3.  URIs  . . . . . . . . . . . . . . . . . . . . . . . . . .  11
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  11
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  12






Krasic, et al.         Expires September 20, 2018               [Page 2]

Internet-Draft                    QPACK                       March 2018


1.  Introduction

   The QUIC transport protocol was designed from the outset to support
   HTTP semantics, and its design subsumes many of the features of
   HTTP/2.  QUIC's stream multiplexing comes into some conflict with
   header compression.  A key goal of the design of QUIC is to improve
   stream multiplexing relative to HTTP/2 by eliminating HoL (head of
   line) blocking, which can occur in HTTP/2.  HoL blocking can happen
   because all HTTP/2 streams are multiplexed onto a single TCP
   connection with its in-order semantics.  QUIC can maintain
   independence between streams because it implements core transport
   functionality in a fully stream-aware manner.  However, the HTTP/QUIC
   mapping is still subject to HoL blocking if HPACK is used directly.
   HPACK exploits multiplexing for greater compression, shrinking the
   representation of headers that have appeared earlier on the same
   connection.  In the context of QUIC, this imposes a vulnerability to
   HoL blocking (see Section 1.1).

   QUIC is described in [QUIC-TRANSPORT].  The HTTP/QUIC mapping is
   described in [QUIC-HTTP].  For a full description of HTTP/2, see
   [RFC7540].  The description of HPACK is [RFC7541], with important
   terminology in Section 1.3.

   QPACK modifies HPACK to allow correctness in the presence of out-of-
   order delivery, with flexibility for implementations to balance
   between resilience against HoL blocking and optimal compression
   ratio.  The design goals are to closely approach the compression
   ratio of HPACK with substantially less head-of-line blocking under
   the same loss conditions.

   QPACK is intended to be a relatively non-intrusive extension to
   HPACK; an implementation should be easily shared within stacks
   supporting both HTTP/2 over (TLS+)TCP and HTTP/QUIC.

1.1.  Head-of-Line Blocking in HPACK

   HPACK enables several types of header representations, one of which
   also adds the header to a dynamic table of header values.  These
   values are then available for reuse in subsequent header blocks
   simply by referencing the entry number in the table.

   If the packet containing a header is lost, that stream cannot
   complete header processing until the packet is retransmitted.  This
   is unavoidable.  However, other streams which rely on the state
   created by that packet _also_ cannot make progress.  This is the
   problem which QUIC solves in general, but which is reintroduced by
   HPACK when the loss includes a HEADERS frame.




Krasic, et al.         Expires September 20, 2018               [Page 3]

Internet-Draft                    QPACK                       March 2018


1.2.  Avoiding Head-of-Line Blocking in HTTP/QUIC

   In the example above, the second stream contained a reference to data
   which might not yet have been processed by the recipient.  Such
   references are called "vulnerable," because the loss of a different
   packet can keep the reference from being usable.

   The encoder can choose on a per-header-block basis whether to favor
   higher compression ratio (by permitting vulnerable references) or HoL
   resilience (by avoiding them).

   QPACK header blocks contains a prefix (Section 2.2) that specifies
   the minimum state of the decoder required to process the block.  If
   the decoder does not yet have the required state, it must defer
   processing until it reaches the required state.  While blocked, the
   portion of the header block data after the prefix MUST remain in the
   blocked stream's flow control window.  Conversely, a header block
   that contains no vulnerable headers may be processed by the decoder
   immediately upon receipt.

2.  HPACK extensions

2.1.  Allowed Instructions

   HEADERS frames on the Control Stream SHOULD contain only Literal with
   Incremental Indexing and Indexed with Duplication (see Section 2.6)
   representations.  Frames on this stream modify the dynamic table
   state without generating output to any particular request.

   HEADERS and PUSH_PROMISE frames on request and push streams MUST NOT
   contain Literal with Incremental Indexing and Indexed with
   Duplication representations.  Frames on these streams reference the
   dynamic table in a particular state without modifying it, but emit
   the headers for an HTTP request or response.

2.2.  Header Block Prefix

   Header block data in HEADERS and PUSH_PROMISE frames begin with a
   prefix.  The prefix contains two logical values: "Largest Reference"
   and "Base Index".  "Largest Reference" is the largest absolute
   dynamic index referenced in the block.  Blocking decoders use the
   Largest Reference to determine when it is safe to process the rest of
   the block.  "Base Index" is the cumulative number of entries added to
   the dynamic table prior to encoding the current block, including any
   entries already evicted.  To save space, Base Index is encoded
   relative to Largest Reference using a one-bit sign flag.

   "baseDelta = largestReference - baseIndex"



Krasic, et al.         Expires September 20, 2018               [Page 4]

Internet-Draft                    QPACK                       March 2018


   If the encoder inserted entries to the table while the encoding the
   block, baseDelta will be positive, and is encoded with S=1.  If the
   block did not reference the most recent entry in the table and did
   not insert any new entries, baseDelta will be negative and is encoded
   with S=0.  baseDelta of 0 is encoded with S=1.

       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |Largest Ref(8+)|
      +-+-+-+-+-+-+-+-+
      |S|BaseDelta(7+)|
      +---------------+

                       Figure 1: Header Block Prefix

   Section 2.3 describes the role of "Base Index".

2.3.  Hybrid absolute-relative indexing

   HPACK indexed entries refer to an entry by its current position in
   the dynamic table.  As Figure 1 of [RFC7541] illustrates, newer
   entries have smaller indices, and older entries are evicted first if
   the table is full.  Under this scheme, each insertion to the table
   causes the index of all existing entries to change (implicitly).
   Implicit index updates are acceptable for HTTP/2 because TCP is
   totally ordered, but are problematic in the out-of-order context of
   QUIC.

   QPACK uses a hybrid absolute-relative indexing approach.

   When the encoder adds a new entry to its header table, it can compute
   an absolute index:

   "entry.absoluteIndex = baseIndex++; "

   Since literals with indexing are only sent on the control stream, the
   decoder can be guaranteed to compute the same absolute index values
   when it adds corresponding entries to its table, just as in HPACK and
   HTTP/2.

   When encoding indexed representations, the following holds for
   (relative) HPACK indices:

   "relative index = baseIndex - entry.absoluteIndex + staticTable.size"

   Header blocks on request and push streams do not modify the dynamic
   table state, so they never change the "baseIndex".  However, since
   ordering between streams is not guaranteed, the value of "baseIndex"



Krasic, et al.         Expires September 20, 2018               [Page 5]

Internet-Draft                    QPACK                       March 2018


   can not be synchronized implicitly.  Instead then, QPACK sends
   encoder's "Base Index" explicitly as part of the prefix (see
   Section 2.2), so that the decoder can compute the same absolute
   indices that the encoder used:

   "absoluteIndex = prefix.baseIndex + staticTable.size -
   relativeIndex;"

   In this way, even if request or push stream headers are decoded in a
   different order than encoded, the absolute indices will still
   identify the correct table entries.

   It is an error if the decoder encounters an indexed representation
   that refers to an entry missing from the table, and the connection
   MUST be closed with the "HTTP_HPACK_DECOMPRESSION_FAILED" error code.

2.4.  Single pass encoding

   An encoder making a single pass over a list of headers must choose
   Base Index before knowing Largest Reference.  An exception occurs
   when trying to reference a header inserted to the table after
   encoding has begun.  In this case, "relativeIndex = baseIndex -
   entry.absoluteIndex + staticTable.size" would either appear to be a
   static table reference, or a negative number that cannot be encoded
   using HPACK integer representation.  Instead, the index is encoded as
   "aboveBaseIndex = entry.absoluteIndex - baseIndex +
   staticTable.size", and is used with different instructions that tell
   the decoder to use a different mechanism to calculate an entry's
   absolute index.

2.4.1.  Literal with Above Base Name Index

   Literal with Above Base Name Index reuses the Literal with
   Incremental Indexing instruction, and is represented as follows:

       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |0|1| Index (6+)|
      +---------------+
      |H|Value Len(8+)|
      +---------------+
      |Value (*)      |
      +---------------+








Krasic, et al.         Expires September 20, 2018               [Page 6]

Internet-Draft                    QPACK                       March 2018


2.4.2.  Indexed Header Field with Above Base Index

   Indexed Header Field with Above Base Index reuses the Table Size
   Update instruction, and is represented as follows:

       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |0|0|1|Index(5+)|
      +---------------+

2.5.  Preventing Eviction Races

   Due to out-of-order arrival, QPACK's eviction algorithm requires
   changes (relative to HPACK) to avoid the possibility that an indexed
   representation is decoded after the referenced entry has already been
   evicted.  QPACK employs a two-phase eviction algorithm, in which the
   encoder will not evict entries that have outstanding (unacknowledged)
   references.

2.5.1.  Blocked Evictions

   The encoder MUST NOT permit an entry to be evicted while a reference
   to that entry remains unacknowledged.  If a new header to be inserted
   into the dynamic table would cause the eviction of such an entry, the
   encoder MUST NOT emit the insert instruction until the reference has
   been processed by the decoder and acknowledged.

   The encoder can emit a literal representation for the new header in
   order to avoid encoding delays, and MAY insert the header into the
   table later if desired.

   To ensure that the blocked eviction case is rare, references to the
   oldest entries in the dynamic table SHOULD be avoided.  When one of
   the oldest entries in the table is still actively used for
   references, the encoder SHOULD emit an Indexed-Duplicate
   representation instead (see Section 2.6).

2.6.  Refreshing Entries with Duplication

       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |0|0|1|Index(5+)|
      +-+-+-+---------+

              Figure 2: Indexed Header Field with Duplication






Krasic, et al.         Expires September 20, 2018               [Page 7]

Internet-Draft                    QPACK                       March 2018


   _Indexed-Duplicates_ insert a new entry into the dynamic table which
   duplicates an existing entry.  [RFC7541] allows duplicate HPACK table
   entries, that is entries that have the same name and value.

   This replaces the HPACK instruction for Dynamic Table Size Update
   (see Section 6.3 of [RFC7541], which is not supported by HTTP over
   QUIC.

3.  Performance considerations

3.1.  Speculative table updates

   Implementations can _speculatively_ send header frames on the HTTP
   Control Streams which are not needed for any current HTTP request or
   response.  Such headers could be used strategically to improve
   performance.  For instance, the encoder might decide to _refresh_ by
   sending Indexed-Duplicate representations for popular header fields
   (Section 2.2), ensuring they have small indices and hence minimal
   size on the wire.

3.2.  Additional state beyond HPACK.

3.2.1.  Vulnerable Entries

   For header blocks encoded in non-blocking mode, the encoder needs to
   forego indexed representations that refer to vulnerable entries (see
   Section 1.2).  An implementation could extend the header table entry
   with a boolean to track vulnerability.  However, the number of
   entries in the table that are vulnerable is likely to be small in
   practice, much less than the total number of entries, so a data
   tracking only vulnerable (un-acknowledged) entries, separate from the
   main header table, might be more space efficient.

3.2.2.  Safe evictions

   Section Section 2.5 describes how QPACK avoids invalid references
   that might result from out-of-order delivery.  When the encoder
   processes a HEADER_ACK, it dereferences table entries that were
   indexed in the acknowledged header.  To track which entries must be
   dereferenced, it can maintain a map from unacknowledged headers to
   lists of (absolute) indices.  The simplest place to store the actual
   reference count might be the table entries.  In practice the number
   of entries in the table with a non-zero reference count is likely to
   stay quite small.  A data structure tracking only entries with non-
   zero reference counts, separate from the main header table, could be
   more space efficient.





Krasic, et al.         Expires September 20, 2018               [Page 8]

Internet-Draft                    QPACK                       March 2018


3.2.3.  Decoder Blocking

   To support blocking, the decoder needs to keep track of entries it
   has added to the dynamic table (see Section 1.2), and it needs to
   track blocked streams.

   Tracking added entries might be done in a brute force fashion without
   additional space.  However, this would have O(N) cost where N is the
   number of entries in the dynamic table.  Alternatively, a dedicated
   data structure might improve on brute force in exchange a small
   amount of additional space.  For example, a set of pairs (of
   indices), representing non-overlapping sub-ranges can be used.  Each
   operation (add, or query) can be done within O(log M) complexity.
   Here set size M is the number of sub-ranges.  In practice M would be
   very small, as most table entries would be concentrated in the first
   sub-range "[1,M]".

   To track blocked streams, an ordered map (e.g. multi-map) from
   "Depends Index" values to streams can be used.  Whenever the decoder
   processes a header block, it can drain any members of the blocked
   streams map that have "Depends Index <= M" where "[1,M]" is the first
   member of the added- entries sub-ranges set.  Again, the complexity
   of operations would be at most O(log N), N being the number of
   concurrently blocked streams.

3.3.  Sample One Pass Encoding Algorithm

   Pseudo-code for single pass encoding, excluding handling of
   duplicates, non-blocking mode, and reference tracking.






















Krasic, et al.         Expires September 20, 2018               [Page 9]

Internet-Draft                    QPACK                       March 2018


   baseIndex = dynamicTable.baseIndex
   largestReference = 0
   for header in headers:
     staticIdx = staticTable.getIndex(header)
     if staticIdx:
       encodeIndexReference(streamBuffer, staticIdx)
       continue

     dynamicIdx = dynamicTable.getIndex(header)
     if !dynamicIdx:
       # No matching entry.  Either insert+index or encode literal
       nameIdx = getNameIndex(header)
       if shouldIndex(header) and dynamicTable.canIndex(header):
         encodeLiteralWithIncrementalIndex(controlBuffer, nameIdx,
                                           header)
         dynamicTable.add(header)
         dynamicIdx = dynamicTable.baseIndex

     if !dynamicIdx:
       # Couldn't index it, literal
       if nameIdx <= staticTable.size:
         encodeLiteral(streamBuffer, nameIndex, header)
       else:
         # encode literal, possibly with nameIdx above baseIndex
         encodeDynamicLiteral(streamBuffer, nameIndex, baseIndex,
                              header)
         largestReference = max(largestReference,
                                dynamicTable.toAbsolute(nameIdx))
     else:
       # Dynamic index reference
       assert(dynamicIdx)
       largestReference = max(largestReference, dynamicIdx)
       # Encode dynamicIdx, possibly with dynamicIdx above baseIndex
       encodeDynamicIndexReference(streamBuffer, dynamicIdx,
                                   baseIndex)

   # encode the prefix
   encodeInteger(prefixBuffer, 0x00, largestReference, 8)
   delta = largestReference - baseIndex
   sign = delta > 0 ? 0x80 : 0
   encodeInteger(prefixBuffer, sign, delta, 7)

   return controlBuffer, prefixBuffer + streamBuffer








Krasic, et al.         Expires September 20, 2018              [Page 10]

Internet-Draft                    QPACK                       March 2018


4.  Security Considerations

   TBD.

5.  IANA Considerations

   This document registers a new frame type, HEADER_ACK, for HTTP/QUIC.
   This will need to be added to the IANA Considerations of [QUIC-HTTP].

6.  References

6.1.  Normative References

   [QUIC-HTTP]
              Bishop, M., "Hypertext Transfer Protocol (HTTP) over
              QUIC", draft-ietf-quic-http-10 (work in progress), March
              2018.

   [RFC7541]  Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

6.2.  Informative References

   [QUIC-TRANSPORT]
              Iyengar, J. and M. Thomson, "QUIC: A UDP-Based Multiplexed
              and Secure Transport", draft-ietf-quic-transport-10 (work
              in progress), March 2018.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

6.3.  URIs

   [1] https://mailarchive.ietf.org/arch/search/?email_list=quic

   [2] https://github.com/quicwg

   [3] https://github.com/quicwg/base-drafts/labels/-qpack

Acknowledgments

   This draft draws heavily on the text of [RFC7541].  The indirect
   input of those authors is gratefully acknowledged, as well as ideas
   from:




Krasic, et al.         Expires September 20, 2018              [Page 11]

Internet-Draft                    QPACK                       March 2018


   o  Ryan Hamilton

   o  Patrick McManus

   o  Kazuho Oku

   o  Biren Roy

   o  Ian Swett

   o  Dmitri Tikhonov

Authors' Addresses

   Charles 'Buck' Krasic
   Google, Inc

   Email: ckrasic@google.com


   Mike Bishop
   Akamai Technologies

   Email: mbishop@evequefou.be


   Alan Frindell (editor)
   Facebook

   Email: afrind@fb.com





















Krasic, et al.         Expires September 20, 2018              [Page 12]
