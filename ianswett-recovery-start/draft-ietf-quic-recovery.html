<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC Loss Detection and Congestion Control</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre {
  font: 13.5px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions">
<link href="#rfc.section.3" rel="Chapter" title="3 Design of the QUIC Transmission Machinery">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Relevant Differences Between QUIC and TCP">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Separate Packet Number Spaces">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Monotonically Increasing Packet Numbers">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 No Reneging">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 More ACK Ranges">
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 Explicit Correction For Delayed ACKs">
<link href="#rfc.section.4" rel="Chapter" title="4 Loss Detection">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Computing the RTT estimate">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Ack-based Detection">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Fast Retransmit">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Early Retransmit">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Timer-based Detection">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Crypto Retransmission Timeout">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Tail Loss Probe">
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Retransmission Timeout">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Generating Acknowledgements">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Crypto Handshake Data">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 ACK Ranges">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 Receiver Tracking of ACK Frames">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Pseudocode">
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Constants of interest">
<link href="#rfc.section.4.5.2" rel="Chapter" title="4.5.2 Variables of interest">
<link href="#rfc.section.4.5.3" rel="Chapter" title="4.5.3 Initialization">
<link href="#rfc.section.4.5.4" rel="Chapter" title="4.5.4 On Sending a Packet">
<link href="#rfc.section.4.5.5" rel="Chapter" title="4.5.5 On Receiving an Acknowledgment">
<link href="#rfc.section.4.5.6" rel="Chapter" title="4.5.6 On Packet Acknowledgment">
<link href="#rfc.section.4.5.7" rel="Chapter" title="4.5.7 Setting the Loss Detection Timer">
<link href="#rfc.section.4.5.8" rel="Chapter" title="4.5.8 On Timeout">
<link href="#rfc.section.4.5.9" rel="Chapter" title="4.5.9 Detecting Lost Packets">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Discussion">
<link href="#rfc.section.5" rel="Chapter" title="5 Congestion Control">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Explicit Congestion Notification">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Slow Start">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Congestion Avoidance">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Recovery Period">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Tail Loss Probe">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Retransmission Timeout">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Pacing">
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Pseudocode">
<link href="#rfc.section.5.8.1" rel="Chapter" title="5.8.1 Constants of interest">
<link href="#rfc.section.5.8.2" rel="Chapter" title="5.8.2 Variables of interest">
<link href="#rfc.section.5.8.3" rel="Chapter" title="5.8.3 Initialization">
<link href="#rfc.section.5.8.4" rel="Chapter" title="5.8.4 On Packet Sent">
<link href="#rfc.section.5.8.5" rel="Chapter" title="5.8.5 On Packet Acknowledgement">
<link href="#rfc.section.5.8.6" rel="Chapter" title="5.8.6 On New Congestion Event">
<link href="#rfc.section.5.8.7" rel="Chapter" title="5.8.7 Process ECN Information">
<link href="#rfc.section.5.8.8" rel="Chapter" title="5.8.8 On Packets Lost">
<link href="#rfc.section.5.8.9" rel="Chapter" title="5.8.9 On Retransmission Timeout Verified">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Congestion Signals">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Traffic Analysis">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Misreporting ECN Markings">
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="8 References">
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Change Log">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Since draft-ietf-quic-recovery-14">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Since draft-ietf-quic-recovery-13">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Since draft-ietf-quic-recovery-12">
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 Since draft-ietf-quic-recovery-11">
<link href="#rfc.appendix.A.5" rel="Chapter" title="A.5 Since draft-ietf-quic-recovery-10">
<link href="#rfc.appendix.A.6" rel="Chapter" title="A.6 Since draft-ietf-quic-recovery-09">
<link href="#rfc.appendix.A.7" rel="Chapter" title="A.7 Since draft-ietf-quic-recovery-08">
<link href="#rfc.appendix.A.8" rel="Chapter" title="A.8 Since draft-ietf-quic-recovery-07">
<link href="#rfc.appendix.A.9" rel="Chapter" title="A.9 Since draft-ietf-quic-recovery-06">
<link href="#rfc.appendix.A.10" rel="Chapter" title="A.10 Since draft-ietf-quic-recovery-05">
<link href="#rfc.appendix.A.11" rel="Chapter" title="A.11 Since draft-ietf-quic-recovery-04">
<link href="#rfc.appendix.A.12" rel="Chapter" title="A.12 Since draft-ietf-quic-recovery-03">
<link href="#rfc.appendix.A.13" rel="Chapter" title="A.13 Since draft-ietf-quic-recovery-02">
<link href="#rfc.appendix.A.14" rel="Chapter" title="A.14 Since draft-ietf-quic-recovery-01">
<link href="#rfc.appendix.A.15" rel="Chapter" title="A.15 Since draft-ietf-quic-recovery-00">
<link href="#rfc.appendix.A.16" rel="Chapter" title="A.16 Since draft-iyengar-quic-loss-recovery-01">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.11.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and I. Swett, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-recovery-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-10-30" />
  <meta name="dct.abstract" content="This document describes loss detection and congestion control mechanisms for QUIC." />
  <meta name="description" content="This document describes loss detection and congestion control mechanisms for QUIC." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Fastly</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">I. Swett, Ed.</td>
</tr>
<tr>
<td class="left">Expires: May 3, 2019</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 30, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC Loss Detection and Congestion Control<br />
  <span class="filename">draft-ietf-quic-recovery-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes loss detection and congestion control mechanisms for QUIC.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-recovery">https://github.com/quicwg/base-drafts/labels/-recovery</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 3, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Conventions and Definitions</a>
</li>
<li>3.   <a href="#rfc.section.3">Design of the QUIC Transmission Machinery</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Relevant Differences Between QUIC and TCP</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Separate Packet Number Spaces</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Monotonically Increasing Packet Numbers</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">No Reneging</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">More ACK Ranges</a>
</li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">Explicit Correction For Delayed ACKs</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Loss Detection</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Computing the RTT estimate</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Ack-based Detection</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Fast Retransmit</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Early Retransmit</a>
</li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Timer-based Detection</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Crypto Retransmission Timeout</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Tail Loss Probe</a>
</li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Retransmission Timeout</a>
</li>
</ul><li>4.4.   <a href="#rfc.section.4.4">Generating Acknowledgements</a>
</li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">Crypto Handshake Data</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">ACK Ranges</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">Receiver Tracking of ACK Frames</a>
</li>
</ul><li>4.5.   <a href="#rfc.section.4.5">Pseudocode</a>
</li>
<ul><li>4.5.1.   <a href="#rfc.section.4.5.1">Constants of interest</a>
</li>
<li>4.5.2.   <a href="#rfc.section.4.5.2">Variables of interest</a>
</li>
<li>4.5.3.   <a href="#rfc.section.4.5.3">Initialization</a>
</li>
<li>4.5.4.   <a href="#rfc.section.4.5.4">On Sending a Packet</a>
</li>
<li>4.5.5.   <a href="#rfc.section.4.5.5">On Receiving an Acknowledgment</a>
</li>
<li>4.5.6.   <a href="#rfc.section.4.5.6">On Packet Acknowledgment</a>
</li>
<li>4.5.7.   <a href="#rfc.section.4.5.7">Setting the Loss Detection Timer</a>
</li>
<li>4.5.8.   <a href="#rfc.section.4.5.8">On Timeout</a>
</li>
<li>4.5.9.   <a href="#rfc.section.4.5.9">Detecting Lost Packets</a>
</li>
</ul><li>4.6.   <a href="#rfc.section.4.6">Discussion</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Congestion Control</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Explicit Congestion Notification</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Slow Start</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Congestion Avoidance</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Recovery Period</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Tail Loss Probe</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Retransmission Timeout</a>
</li>
<li>5.7.   <a href="#rfc.section.5.7">Pacing</a>
</li>
<li>5.8.   <a href="#rfc.section.5.8">Pseudocode</a>
</li>
<ul><li>5.8.1.   <a href="#rfc.section.5.8.1">Constants of interest</a>
</li>
<li>5.8.2.   <a href="#rfc.section.5.8.2">Variables of interest</a>
</li>
<li>5.8.3.   <a href="#rfc.section.5.8.3">Initialization</a>
</li>
<li>5.8.4.   <a href="#rfc.section.5.8.4">On Packet Sent</a>
</li>
<li>5.8.5.   <a href="#rfc.section.5.8.5">On Packet Acknowledgement</a>
</li>
<li>5.8.6.   <a href="#rfc.section.5.8.6">On New Congestion Event</a>
</li>
<li>5.8.7.   <a href="#rfc.section.5.8.7">Process ECN Information</a>
</li>
<li>5.8.8.   <a href="#rfc.section.5.8.8">On Packets Lost</a>
</li>
<li>5.8.9.   <a href="#rfc.section.5.8.9">On Retransmission Timeout Verified</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Congestion Signals</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Traffic Analysis</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Misreporting ECN Markings</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">IANA Considerations</a>
</li>
<li>8.   <a href="#rfc.references">References</a>
</li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Change Log</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Since draft-ietf-quic-recovery-14</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Since draft-ietf-quic-recovery-13</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">Since draft-ietf-quic-recovery-12</a>
</li>
<li>A.4.   <a href="#rfc.appendix.A.4">Since draft-ietf-quic-recovery-11</a>
</li>
<li>A.5.   <a href="#rfc.appendix.A.5">Since draft-ietf-quic-recovery-10</a>
</li>
<li>A.6.   <a href="#rfc.appendix.A.6">Since draft-ietf-quic-recovery-09</a>
</li>
<li>A.7.   <a href="#rfc.appendix.A.7">Since draft-ietf-quic-recovery-08</a>
</li>
<li>A.8.   <a href="#rfc.appendix.A.8">Since draft-ietf-quic-recovery-07</a>
</li>
<li>A.9.   <a href="#rfc.appendix.A.9">Since draft-ietf-quic-recovery-06</a>
</li>
<li>A.10.   <a href="#rfc.appendix.A.10">Since draft-ietf-quic-recovery-05</a>
</li>
<li>A.11.   <a href="#rfc.appendix.A.11">Since draft-ietf-quic-recovery-04</a>
</li>
<li>A.12.   <a href="#rfc.appendix.A.12">Since draft-ietf-quic-recovery-03</a>
</li>
<li>A.13.   <a href="#rfc.appendix.A.13">Since draft-ietf-quic-recovery-02</a>
</li>
<li>A.14.   <a href="#rfc.appendix.A.14">Since draft-ietf-quic-recovery-01</a>
</li>
<li>A.15.   <a href="#rfc.appendix.A.15">Since draft-ietf-quic-recovery-00</a>
</li>
<li>A.16.   <a href="#rfc.appendix.A.16">Since draft-iyengar-quic-loss-recovery-01</a>
</li>
</ul><li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">QUIC is a new multiplexed and secure transport atop UDP.  QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport.  The QUIC protocol is described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.1.p.2">QUIC implements the spirit of known TCP loss recovery mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation.  This document describes QUIC congestion control and loss recovery, and where applicable, attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and/or TCP implementations.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a>
</h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.2.p.2">Definitions of terms that are used in this document:</p>
<p></p>

<dl>
<dt>ACK-only:</dt>
<dd style="margin-left: 8">Any packet containing only an ACK frame.</dd>
<dt>In-flight:</dt>
<dd style="margin-left: 8">Packets are considered in-flight when they have been sent and neither acknowledged nor declared lost, and they are not ACK-only.</dd>
<dt>Retransmittable Frames:</dt>
<dd style="margin-left: 8">All frames besides ACK or PADDING are considered retransmittable.</dd>
<dt>Retransmittable Packets:</dt>
<dd style="margin-left: 8">Packets that contain retransmittable frames elicit an ACK from the receiver and are called retransmittable packets.</dd>
<dt>Crypto Packets:</dt>
<dd style="margin-left: 8">Packets containing CRYPTO data sent in Initial or Handshake packets.</dd>
</dl>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#design-of-the-quic-transmission-machinery" id="design-of-the-quic-transmission-machinery">Design of the QUIC Transmission Machinery</a>
</h1>
<p id="rfc.section.3.p.1">All transmissions in QUIC are sent with a packet-level header, which indicates the encryption level and includes a packet sequence number (referred to below as a packet number).  The encryption level indicates the packet number space, as described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  Packet numbers never repeat within a packet number space for the lifetime of a connection.  Packet numbers monotonically increase within a space, preventing ambiguity.</p>
<p id="rfc.section.3.p.2">This design obviates the need for disambiguating between transmissions and retransmissions and eliminates significant complexity from QUIC&#8217;s interpretation of TCP loss detection mechanisms.</p>
<p id="rfc.section.3.p.3">QUIC packets can contain multiple frames of different types. The recovery mechanisms ensure that data and frames that need reliable delivery are acknowledged or declared lost and sent in new packets as necessary. The types of frames contained in a packet affect recovery and congestion control logic:</p>
<p></p>

<ul>
<li>All packets are acknowledged, though packets that contain only ACK and PADDING frames are not acknowledged immediately.</li>
<li>Long header packets that contain CRYPTO frames are critical to the performance of the QUIC handshake and use shorter timers for acknowledgement and retransmission.</li>
<li>Packets that contain only ACK frames do not count toward congestion control limits and are not considered in-flight. Note that this means PADDING frames cause packets to contribute toward bytes in flight without directly causing an acknowledgment to be sent.</li>
</ul>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#relevant-differences-between-quic-and-tcp" id="relevant-differences-between-quic-and-tcp">Relevant Differences Between QUIC and TCP</a>
</h2>
<p id="rfc.section.3.1.p.1">Readers familiar with TCP&#8217;s loss detection and congestion control will find algorithms here that parallel well-known TCP ones. Protocol differences between QUIC and TCP however contribute to algorithmic differences. We briefly describe these protocol differences below.</p>
<h3 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#separate-packet-number-spaces" id="separate-packet-number-spaces">Separate Packet Number Spaces</a>
</h3>
<p id="rfc.section.3.1.1.p.1">QUIC uses separate packet number spaces for each encryption level, except 0-RTT and all generations of 1-RTT keys use the same packet number space.  Separate packet number spaces ensures acknowledgement of packets sent with one level of encryption will not cause spurious retransmission of packets sent with a different encryption level.  Congestion control and RTT measurement are unified across packet number spaces.</p>
<h3 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#monotonically-increasing-packet-numbers" id="monotonically-increasing-packet-numbers">Monotonically Increasing Packet Numbers</a>
</h3>
<p id="rfc.section.3.1.2.p.1">TCP conflates transmission sequence number at the sender with delivery sequence number at the receiver, which results in retransmissions of the same data carrying the same sequence number, and consequently to problems caused by &#8220;retransmission ambiguity&#8221;.  QUIC separates the two: QUIC uses a packet number for transmissions, and any application data is sent in one or more streams, with delivery order determined by stream offsets encoded within STREAM frames.</p>
<p id="rfc.section.3.1.2.p.2">QUIC&#8217;s packet number is strictly increasing, and directly encodes transmission order.  A higher QUIC packet number signifies that the packet was sent later, and a lower QUIC packet number signifies that the packet was sent earlier.  When a packet containing frames is deemed lost, QUIC rebundles necessary frames in a new packet with a new packet number, removing ambiguity about which packet is acknowledged when an ACK is received.  Consequently, more accurate RTT measurements can be made, spurious retransmissions are trivially detected, and mechanisms such as Fast Retransmit can be applied universally, based only on packet number.</p>
<p id="rfc.section.3.1.2.p.3">This design point significantly simplifies loss detection mechanisms for QUIC.  Most TCP mechanisms implicitly attempt to infer transmission ordering based on TCP sequence numbers - a non-trivial task, especially when TCP timestamps are not available.</p>
<h3 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#no-reneging" id="no-reneging">No Reneging</a>
</h3>
<p id="rfc.section.3.1.3.p.1">QUIC ACKs contain information that is similar to TCP SACK, but QUIC does not allow any acked packet to be reneged, greatly simplifying implementations on both sides and reducing memory pressure on the sender.</p>
<h3 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#more-ack-ranges" id="more-ack-ranges">More ACK Ranges</a>
</h3>
<p id="rfc.section.3.1.4.p.1">QUIC supports many ACK ranges, opposed to TCP&#8217;s 3 SACK ranges.  In high loss environments, this speeds recovery, reduces spurious retransmits, and ensures forward progress without relying on timeouts.</p>
<h3 id="rfc.section.3.1.5">
<a href="#rfc.section.3.1.5">3.1.5.</a> <a href="#explicit-correction-for-delayed-acks" id="explicit-correction-for-delayed-acks">Explicit Correction For Delayed ACKs</a>
</h3>
<p id="rfc.section.3.1.5.p.1">QUIC ACKs explicitly encode the delay incurred at the receiver between when a packet is received and when the corresponding ACK is sent.  This allows the receiver of the ACK to adjust for receiver delays, specifically the delayed ack timer, when estimating the path RTT.  This mechanism also allows a receiver to measure and report the delay from when a packet was received by the OS kernel, which is useful in receivers which may incur delays such as context-switch latency before a userspace QUIC receiver processes a received packet.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#loss-detection" id="loss-detection">Loss Detection</a>
</h1>
<p id="rfc.section.4.p.1">QUIC senders use both ack information and timeouts to detect lost packets, and this section provides a description of these algorithms. Estimating the network round-trip time (RTT) is critical to these algorithms and is described first.</p>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#computing-the-rtt-estimate" id="computing-the-rtt-estimate">Computing the RTT estimate</a>
</h2>
<p id="rfc.section.4.1.p.1">RTT is calculated when an ACK frame arrives by computing the difference between the current time and the time the largest newly acked packet was sent.  If no packets are newly acknowledged, RTT cannot be calculated. When RTT is calculated, the ack delay field from the ACK frame SHOULD be subtracted from the RTT as long as the result is larger than the Min RTT.  If the result is smaller than the min_rtt, the RTT should be used, but the ack delay field should be ignored.</p>
<p id="rfc.section.4.1.p.2">Like TCP, QUIC calculates both smoothed RTT and RTT variance similar to those specified in <a href="#RFC6298" class="xref">[RFC6298]</a>.</p>
<p id="rfc.section.4.1.p.3">Min RTT is the minimum RTT measured over the connection, prior to adjusting by ack delay.  Ignoring ack delay for min RTT prevents intentional or unintentional underestimation of min RTT, which in turn prevents underestimating smoothed RTT.</p>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#ack-based-detection" id="ack-based-detection">Ack-based Detection</a>
</h2>
<p id="rfc.section.4.2.p.1">Ack-based loss detection implements the spirit of TCP&#8217;s Fast Retransmit <a href="#RFC5681" class="xref">[RFC5681]</a>, Early Retransmit <a href="#RFC5827" class="xref">[RFC5827]</a>, FACK, and SACK loss recovery <a href="#RFC6675" class="xref">[RFC6675]</a>. This section provides an overview of how these algorithms are implemented in QUIC.</p>
<h3 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#fast-retransmit" id="fast-retransmit">Fast Retransmit</a>
</h3>
<p id="rfc.section.4.2.1.p.1">An unacknowledged packet is marked as lost when an acknowledgment is received for a packet that was sent a threshold number of packets (kReorderingThreshold) and/or a threshold amount of time after the unacknowledged packet. Receipt of the acknowledgement indicates that a later packet was received, while the reordering threshold provides some tolerance for reordering of packets in the network.</p>
<p id="rfc.section.4.2.1.p.2">The RECOMMENDED initial value for kReorderingThreshold is 3, based on TCP loss recovery <a href="#RFC5681" class="xref">[RFC5681]</a> <a href="#RFC6675" class="xref">[RFC6675]</a>. Some networks may exhibit higher degrees of reordering, causing a sender to detect spurious losses. Spuriously declaring packets lost leads to unnecessary retransmissions and may result in degraded performance due to the actions of the congestion controller upon detecting loss. Implementers MAY use algorithms developed for TCP, such as TCP-NCR <a href="#RFC4653" class="xref">[RFC4653]</a>, to improve QUIC&#8217;s reordering resilience.</p>
<p id="rfc.section.4.2.1.p.3">QUIC implementations can use time-based loss detection to handle reordering based on time elapsed since the packet was sent.  This may be used either as a replacement for a packet reordering threshold or in addition to it.  The RECOMMENDED time threshold, expressed as a fraction of the round-trip time (kTimeReorderingFraction), is 1/8.</p>
<h3 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#early-retransmit" id="early-retransmit">Early Retransmit</a>
</h3>
<p id="rfc.section.4.2.2.p.1">Unacknowledged packets close to the tail may have fewer than kReorderingThreshold retransmittable packets sent after them.  Loss of such packets cannot be detected via Fast Retransmit. To enable ack-based loss detection of such packets, receipt of an acknowledgment for the last outstanding retransmittable packet triggers the Early Retransmit process, as follows.</p>
<p id="rfc.section.4.2.2.p.2">If there are unacknowledged in-flight packets still pending, they should be marked as lost. To compensate for the reduced reordering resilience, the sender SHOULD set a timer for a small period of time. If the unacknowledged in-flight packets are not acknowledged during this time, then these packets MUST be marked as lost.</p>
<p id="rfc.section.4.2.2.p.3">An endpoint SHOULD set the timer such that a packet is marked as lost no earlier than 1.125 * max(SRTT, latest_RTT) since when it was sent.</p>
<p id="rfc.section.4.2.2.p.4">Using max(SRTT, latest_RTT) protects from the two following cases:</p>
<p></p>

<ul>
<li>the latest RTT sample is lower than the SRTT, perhaps due to reordering where packet whose ack triggered the Early Retransit process encountered a shorter path;</li>
<li>the latest RTT sample is higher than the SRTT, perhaps due to a sustained increase in the actual RTT, but the smoothed SRTT has not yet caught up.</li>
</ul>
<p id="rfc.section.4.2.2.p.6">The 1.125 multiplier increases reordering resilience. Implementers MAY experiment with using other multipliers, bearing in mind that a lower multiplier reduces reordering resilience and increases spurious retransmissions, and a higher multiplier increases loss recovery delay.</p>
<p id="rfc.section.4.2.2.p.7">This mechanism is based on Early Retransmit for TCP <a href="#RFC5827" class="xref">[RFC5827]</a>. However, <a href="#RFC5827" class="xref">[RFC5827]</a> does not include the timer described above. Early Retransmit is prone to spurious retransmissions due to its reduced reordering resilence without the timer. This observation led Linux TCP implementers to implement a timer for TCP as well, and this document incorporates this advancement.</p>
<h2 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#timer-based-detection" id="timer-based-detection">Timer-based Detection</a>
</h2>
<p id="rfc.section.4.3.p.1">Timer-based loss detection recovers from losses that cannot be handled by ack-based loss detection.  It uses a single timer which switches between a crypto retransmission timer, a Tail Loss Probe timer and Retransmission Timeout mechanisms.</p>
<h3 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#crypto-retransmission-timeout" id="crypto-retransmission-timeout">Crypto Retransmission Timeout</a>
</h3>
<p id="rfc.section.4.3.1.p.1">Data in CRYPTO frames is critical to QUIC transport and crypto negotiation, so a more aggressive timeout is used to retransmit it.</p>
<p id="rfc.section.4.3.1.p.2">The initial crypto retransmission timeout SHOULD be set to twice the initial RTT.</p>
<p id="rfc.section.4.3.1.p.3">At the beginning, there are no prior RTT samples within a connection.  Resumed connections over the same network SHOULD use the previous connection&#8217;s final smoothed RTT value as the resumed connection&#8217;s initial RTT.  If no previous RTT is available, or if the network changes, the initial RTT SHOULD be set to 100ms.  When an acknowledgement is received, a new RTT is computed and the timer SHOULD be set for twice the newly computed smoothed RTT.</p>
<p id="rfc.section.4.3.1.p.4">When crypto packets are sent, the sender MUST set a timer for the crypto timeout period.  Upon timeout, the sender MUST retransmit all unacknowledged CRYPTO data if possible.</p>
<p id="rfc.section.4.3.1.p.5">Until the server has validated the client&#8217;s address on the path, the amount of data it can send is limited, as specified in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  If not all unacknowledged CRYPTO data can be sent, then all unacknowledged CRYPTO data sent in Initial packets should be retransmitted.  If no data can be sent, then no alarm should be armed until data has been received from the client.</p>
<p id="rfc.section.4.3.1.p.6">Because the server could be blocked until more packets are received, the client MUST start the crypto retransmission timer even if there is no unacknowledged CRYPTO data.  If the timer expires and the client has no CRYPTO data to retransmit and does not have Handshake keys, it SHOULD send an Initial packet in a UDP datagram of at least 1200 bytes.  If the client has Handshake keys, it SHOULD send a Handshake packet.</p>
<p id="rfc.section.4.3.1.p.7">On each consecutive expiration of the crypto timer without receiving an acknowledgement for a new packet, the sender SHOULD double the crypto retransmission timeout and set a timer for this period.</p>
<p id="rfc.section.4.3.1.p.8">When crypto packets are outstanding, the TLP and RTO timers are not active.</p>
<h4 id="rfc.section.4.3.1.1">
<a href="#rfc.section.4.3.1.1">4.3.1.1.</a> <a href="#retry-and-version-negotiation" id="retry-and-version-negotiation">Retry and Version Negotiation</a>
</h4>
<p id="rfc.section.4.3.1.1.p.1">A Retry or Version Negotiation packet causes a client to send another Initial packet, effectively restarting the connection process.</p>
<p id="rfc.section.4.3.1.1.p.2">Either packet indicates that the Initial was received but not processed.  Neither packet can be treated as an acknowledgment for the Initial, but they MAY be used to improve the RTT estimate.</p>
<h3 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#tlp" id="tlp">Tail Loss Probe</a>
</h3>
<p id="rfc.section.4.3.2.p.1">The algorithm described in this section is an adaptation of the Tail Loss Probe algorithm proposed for TCP <a href="#TLP" class="xref">[TLP]</a>.</p>
<p id="rfc.section.4.3.2.p.2">A packet sent at the tail is particularly vulnerable to slow loss detection, since acks of subsequent packets are needed to trigger ack-based detection. To ameliorate this weakness of tail packets, the sender schedules a timer when the last retransmittable packet before quiescence is transmitted. Upon timeout, a Tail Loss Probe (TLP) packet is sent to evoke an acknowledgement from the receiver.</p>
<p id="rfc.section.4.3.2.p.3">The timer duration, or Probe Timeout (PTO), is set based on the following conditions:</p>
<p></p>

<ul>
<li>PTO SHOULD be scheduled for max(1.5*SRTT+MaxAckDelay, kMinTLPTimeout)</li>
<li>If RTO (<a href="#rto" class="xref">Section 4.3.3</a>) is earlier, schedule a TLP in its place. That is, PTO SHOULD be scheduled for min(RTO, PTO).</li>
</ul>
<p id="rfc.section.4.3.2.p.5">QUIC includes MaxAckDelay in all probe timeouts, because it assumes the ack delay may come into play, regardless of the number of packets outstanding.  TCP&#8217;s TLP assumes if at least 2 packets are outstanding, acks will not be delayed.</p>
<p id="rfc.section.4.3.2.p.6">A PTO value of at least 1.5*SRTT ensures that the ACK is overdue.  The 1.5 is based on <a href="#TLP" class="xref">[TLP]</a>, but implementations MAY experiment with other constants.</p>
<p id="rfc.section.4.3.2.p.7">To reduce latency, it is RECOMMENDED that the sender set and allow the TLP timer to fire twice before setting an RTO timer. In other words, when the TLP timer expires the first time, a TLP packet is sent, and it is RECOMMENDED that the TLP timer be scheduled for a second time. When the TLP timer expires the second time, a second TLP packet is sent, and an RTO timer SHOULD be scheduled <a href="#rto" class="xref">Section 4.3.3</a>.</p>
<p id="rfc.section.4.3.2.p.8">A TLP packet SHOULD carry new data when possible. If new data is unavailable or new data cannot be sent due to flow control, a TLP packet MAY retransmit unacknowledged data to potentially reduce recovery time. Since a TLP timer is used to send a probe into the network prior to establishing any packet loss, prior unacknowledged packets SHOULD NOT be marked as lost when a TLP timer expires.</p>
<p id="rfc.section.4.3.2.p.9">A sender may not know that a packet being sent is a tail packet.  Consequently, a sender may have to arm or adjust the TLP timer on every sent retransmittable packet.</p>
<h3 id="rfc.section.4.3.3">
<a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#rto" id="rto">Retransmission Timeout</a>
</h3>
<p id="rfc.section.4.3.3.p.1">A Retransmission Timeout (RTO) timer is the final backstop for loss detection. The algorithm used in QUIC is based on the RTO algorithm for TCP <a href="#RFC5681" class="xref">[RFC5681]</a> and is additionally resilient to spurious RTO events <a href="#RFC5682" class="xref">[RFC5682]</a>.</p>
<p id="rfc.section.4.3.3.p.2">When the last TLP packet is sent, a timer is set for the RTO period. When this timer expires, the sender sends two packets, to evoke acknowledgements from the receiver, and restarts the RTO timer.</p>
<p id="rfc.section.4.3.3.p.3">Similar to TCP <a href="#RFC6298" class="xref">[RFC6298]</a>, the RTO period is set based on the following conditions:</p>
<p></p>

<ul>
<li>When the final TLP packet is sent, the RTO period is set to max(SRTT + 4*RTTVAR + MaxAckDelay, kMinRTOTimeout)</li>
<li>When an RTO timer expires, the RTO period is doubled.</li>
</ul>
<p id="rfc.section.4.3.3.p.5">The sender typically has incurred a high latency penalty by the time an RTO timer expires, and this penalty increases exponentially in subsequent consecutive RTO events. Sending a single packet on an RTO event therefore makes the connection very sensitive to single packet loss. Sending two packets instead of one significantly increases resilience to packet drop in both directions, thus reducing the probability of consecutive RTO events.</p>
<p id="rfc.section.4.3.3.p.6">QUIC&#8217;s RTO algorithm differs from TCP in that the firing of an RTO timer is not considered a strong enough signal of packet loss, so does not result in an immediate change to congestion window or recovery state. An RTO timer expires only when there&#8217;s a prolonged period of network silence, which could be caused by a change in the underlying network RTT.</p>
<p id="rfc.section.4.3.3.p.7">QUIC also diverges from TCP by including MaxAckDelay in the RTO period. Since QUIC corrects for this delay in its SRTT and RTTVAR computations, it is necessary to add this delay explicitly in the TLP and RTO computation.</p>
<p id="rfc.section.4.3.3.p.8">When an acknowledgment is received for a packet sent on an RTO event, any unacknowledged packets with lower packet numbers than those acknowledged MUST be marked as lost.  If an acknowledgement for a packet sent on an RTO is received at the same time packets sent prior to the first RTO are acknowledged, the RTO is considered spurious and standard loss detection rules apply.</p>
<p id="rfc.section.4.3.3.p.9">A packet sent when an RTO timer expires MAY carry new data if available or unacknowledged data to potentially reduce recovery time. Since this packet is sent as a probe into the network prior to establishing any packet loss, prior unacknowledged packets SHOULD NOT be marked as lost.</p>
<p id="rfc.section.4.3.3.p.10">A packet sent on an RTO timer MUST NOT be blocked by the sender&#8217;s congestion controller. A sender MUST however count these packets as being in flight, since this packet adds network load without establishing packet loss.</p>
<h2 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#generating-acknowledgements" id="generating-acknowledgements">Generating Acknowledgements</a>
</h2>
<p id="rfc.section.4.4.p.1">QUIC SHOULD delay sending acknowledgements in response to packets, but MUST NOT excessively delay acknowledgements of packets containing frames other than ACK.  Specifically, implementations MUST attempt to enforce a maximum ack delay to avoid causing the peer spurious timeouts.  The maximum ack delay is communicated in the <samp>max_ack_delay</samp> transport parameter and the default value is 25ms.</p>
<p id="rfc.section.4.4.p.2">An acknowledgement SHOULD be sent immediately upon receipt of a second packet but the delay SHOULD NOT exceed the maximum ack delay. QUIC recovery algorithms do not assume the peer generates an acknowledgement immediately when receiving a second full-packet.</p>
<p id="rfc.section.4.4.p.3">Out-of-order packets SHOULD be acknowledged more quickly, in order to accelerate loss recovery.  The receiver SHOULD send an immediate ACK when it receives a new packet which is not one greater than the largest received packet number.</p>
<p id="rfc.section.4.4.p.4">Similarly, packets marked with the ECN Congestion Experienced (CE) codepoint in the IP header SHOULD be acknowledged immediately, to reduce the peer&#8217;s response time to congestion events.</p>
<p id="rfc.section.4.4.p.5">As an optimization, a receiver MAY process multiple packets before sending any ACK frames in response.  In this case they can determine whether an immediate or delayed acknowledgement should be generated after processing incoming packets.</p>
<h3 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#crypto-handshake-data" id="crypto-handshake-data">Crypto Handshake Data</a>
</h3>
<p id="rfc.section.4.4.1.p.1">In order to quickly complete the handshake and avoid spurious retransmissions due to crypto retransmission timeouts, crypto packets SHOULD use a very short ack delay, such as 1ms.  ACK frames MAY be sent immediately when the crypto stack indicates all data for that encryption level has been received.</p>
<h3 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#ack-ranges" id="ack-ranges">ACK Ranges</a>
</h3>
<p id="rfc.section.4.4.2.p.1">When an ACK frame is sent, one or more ranges of acknowledged packets are included.  Including older packets reduces the chance of spurious retransmits caused by losing previously sent ACK frames, at the cost of larger ACK frames.</p>
<p id="rfc.section.4.4.2.p.2">ACK frames SHOULD always acknowledge the most recently received packets, and the more out-of-order the packets are, the more important it is to send an updated ACK frame quickly, to prevent the peer from declaring a packet as lost and spuriously retransmitting the frames it contains.</p>
<p id="rfc.section.4.4.2.p.3">Below is one recommended approach for determining what packets to include in an ACK frame.</p>
<h3 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#receiver-tracking-of-ack-frames" id="receiver-tracking-of-ack-frames">Receiver Tracking of ACK Frames</a>
</h3>
<p id="rfc.section.4.4.3.p.1">When a packet containing an ACK frame is sent, the largest acknowledged in that frame may be saved.  When a packet containing an ACK frame is acknowledged, the receiver can stop acknowledging packets less than or equal to the largest acknowledged in the sent ACK frame.</p>
<p id="rfc.section.4.4.3.p.2">In cases without ACK frame loss, this algorithm allows for a minimum of 1 RTT of reordering. In cases with ACK frame loss, this approach does not guarantee that every acknowledgement is seen by the sender before it is no longer included in the ACK frame. Packets could be received out of order and all subsequent ACK frames containing them could be lost. In this case, the loss recovery algorithm may cause spurious retransmits, but the sender will continue making forward progress.</p>
<h2 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#pseudocode" id="pseudocode">Pseudocode</a>
</h2>
<h3 id="rfc.section.4.5.1">
<a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#constants-of-interest" id="constants-of-interest">Constants of interest</a>
</h3>
<p id="rfc.section.4.5.1.p.1">Constants used in loss recovery are based on a combination of RFCs, papers, and common practice.  Some may need to be changed or negotiated in order to better suit a variety of environments.</p>
<p></p>

<dl>
<dt>kMaxTLPs:</dt>
<dd style="margin-left: 8">Maximum number of tail loss probes before an RTO expires.  The RECOMMENDED value is 2.</dd>
<dt>kReorderingThreshold:</dt>
<dd style="margin-left: 8">Maximum reordering in packet number space before FACK style loss detection considers a packet lost. The RECOMMENDED value is 3.</dd>
<dt>kTimeReorderingFraction:</dt>
<dd style="margin-left: 8">Maximum reordering in time space before time based loss detection considers a packet lost.  In fraction of an RTT. The RECOMMENDED value is 1/8.</dd>
<dt>kUsingTimeLossDetection:</dt>
<dd style="margin-left: 8">Whether time based loss detection is in use.  If false, uses FACK style loss detection. The RECOMMENDED value is false.</dd>
<dt>kMinTLPTimeout:</dt>
<dd style="margin-left: 8">Minimum time in the future a tail loss probe timer may be set for.  The RECOMMENDED value is 10ms.</dd>
<dt>kMinRTOTimeout:</dt>
<dd style="margin-left: 8">Minimum time in the future an RTO timer may be set for. The RECOMMENDED value is 200ms.</dd>
<dt>kDelayedAckTimeout:</dt>
<dd style="margin-left: 8">The length of the peer&#8217;s delayed ack timer. The RECOMMENDED value is 25ms.</dd>
<dt>kInitialRtt:</dt>
<dd style="margin-left: 8">The RTT used before an RTT sample is taken. The RECOMMENDED value is 100ms.</dd>
</dl>
<h3 id="rfc.section.4.5.2">
<a href="#rfc.section.4.5.2">4.5.2.</a> <a href="#variables-of-interest" id="variables-of-interest">Variables of interest</a>
</h3>
<p id="rfc.section.4.5.2.p.1">Variables required to implement the congestion control mechanisms are described in this section.</p>
<p></p>

<dl>
<dt>loss_detection_timer:</dt>
<dd style="margin-left: 8">Multi-modal timer used for loss detection.</dd>
<dt>crypto_count:</dt>
<dd style="margin-left: 8">The number of times all unacknowledged CRYPTO data has been retransmitted without receiving an ack.</dd>
<dt>tlp_count:</dt>
<dd style="margin-left: 8">The number of times a tail loss probe has been sent without receiving an ack.</dd>
<dt>rto_count:</dt>
<dd style="margin-left: 8">The number of times an RTO has been sent without receiving an ack.</dd>
<dt>largest_sent_before_rto:</dt>
<dd style="margin-left: 8">The last packet number sent prior to the first retransmission timeout.</dd>
<dt>time_of_last_sent_retransmittable_packet:</dt>
<dd style="margin-left: 8">The time the most recent retransmittable packet was sent.</dd>
<dt>time_of_last_sent_crypto_packet:</dt>
<dd style="margin-left: 8">The time the most recent crypto packet was sent.</dd>
<dt>largest_sent_packet:</dt>
<dd style="margin-left: 8">The packet number of the most recently sent packet.</dd>
<dt>largest_acked_packet:</dt>
<dd style="margin-left: 8">The largest packet number acknowledged in an ACK frame.</dd>
<dt>latest_rtt:</dt>
<dd style="margin-left: 8">The most recent RTT measurement made when receiving an ack for a previously unacked packet.</dd>
<dt>smoothed_rtt:</dt>
<dd style="margin-left: 8">The smoothed RTT of the connection, computed as described in <a href="#RFC6298" class="xref">[RFC6298]</a>
</dd>
<dt>rttvar:</dt>
<dd style="margin-left: 8">The RTT variance, computed as described in <a href="#RFC6298" class="xref">[RFC6298]</a>
</dd>
<dt>min_rtt:</dt>
<dd style="margin-left: 8">The minimum RTT seen in the connection, ignoring ack delay.</dd>
<dt>max_ack_delay:</dt>
<dd style="margin-left: 8">The maximum amount of time by which the receiver intends to delay acknowledgments, in milliseconds.  The actual ack_delay in a received ACK frame may be larger due to late timers, reordering, or lost ACKs.</dd>
<dt>reordering_threshold:</dt>
<dd style="margin-left: 8">The largest packet number gap between the largest acknowledged retransmittable packet and an unacknowledged retransmittable packet before it is declared lost.</dd>
<dt>time_reordering_fraction:</dt>
<dd style="margin-left: 8">The reordering window as a fraction of max(smoothed_rtt, latest_rtt).</dd>
<dt>loss_time:</dt>
<dd style="margin-left: 8">The time at which the next packet will be considered lost based on early transmit or exceeding the reordering window in time.</dd>
<dt>sent_packets:</dt>
<dd style="margin-left: 8">An association of packet numbers to information about them, including a number field indicating the packet number, a time field indicating the time a packet was sent, a boolean indicating whether the packet is ack-only, a boolean indicating whether it counts towards bytes in flight, and a size field that indicates the packet&#8217;s size in bytes.  sent_packets is ordered by packet number, and packets remain in sent_packets until acknowledged or lost.  A sent_packets data structure is maintained per packet number space, and ACK processing only applies to a single space.</dd>
</dl>
<h3 id="rfc.section.4.5.3">
<a href="#rfc.section.4.5.3">4.5.3.</a> <a href="#initialization" id="initialization">Initialization</a>
</h3>
<p id="rfc.section.4.5.3.p.1">At the beginning of the connection, initialize the loss detection variables as follows:</p>
<pre>
   loss_detection_timer.reset()
   crypto_count = 0
   tlp_count = 0
   rto_count = 0
   if (kUsingTimeLossDetection)
     reordering_threshold = infinite
     time_reordering_fraction = kTimeReorderingFraction
   else:
     reordering_threshold = kReorderingThreshold
     time_reordering_fraction = infinite
   loss_time = 0
   smoothed_rtt = 0
   rttvar = 0
   min_rtt = infinite
   largest_sent_before_rto = 0
   time_of_last_sent_retransmittable_packet = 0
   time_of_last_sent_crypto_packet = 0
   largest_sent_packet = 0
</pre>
<h3 id="rfc.section.4.5.4">
<a href="#rfc.section.4.5.4">4.5.4.</a> <a href="#on-sending-a-packet" id="on-sending-a-packet">On Sending a Packet</a>
</h3>
<p id="rfc.section.4.5.4.p.1">After any packet is sent, be it a new transmission or a rebundled transmission, the following OnPacketSent function is called.  The parameters to OnPacketSent are as follows:</p>
<p></p>

<ul>
<li>packet_number: The packet number of the sent packet.</li>
<li>ack_only: A boolean that indicates whether a packet contains only ACK or PADDING frame(s).  If true, it is still expected an ack will be received for this packet, but it is not retransmittable.</li>
<li>in_flight: A boolean that indicates whether the packet counts towards bytes in flight.</li>
<li>is_crypto_packet: A boolean that indicates whether the packet contains cryptographic handshake messages critical to the completion of the QUIC handshake. In this version of QUIC, this includes any packet with the long header that includes a CRYPTO frame.</li>
<li>sent_bytes: The number of bytes sent in the packet, not including UDP or IP overhead, but including QUIC framing overhead.</li>
</ul>
<p id="rfc.section.4.5.4.p.3">Pseudocode for OnPacketSent follows:</p>
<pre>
 OnPacketSent(packet_number, ack_only, in_flight,
              is_crypto_packet, sent_bytes):
   largest_sent_packet = packet_number
   sent_packets[packet_number].packet_number = packet_number
   sent_packets[packet_number].time = now
   sent_packets[packet_number].ack_only = ack_only
   sent_packets[packet_number].in_flight = in_flight
   if !ack_only:
     if is_crypto_packet:
       time_of_last_sent_crypto_packet = now
     time_of_last_sent_retransmittable_packet = now
     OnPacketSentCC(sent_bytes)
     sent_packets[packet_number].size = sent_bytes
     SetLossDetectionTimer()
</pre>
<h3 id="rfc.section.4.5.5">
<a href="#rfc.section.4.5.5">4.5.5.</a> <a href="#on-receiving-an-acknowledgment" id="on-receiving-an-acknowledgment">On Receiving an Acknowledgment</a>
</h3>
<p id="rfc.section.4.5.5.p.1">When an ACK frame is received, it may newly acknowledge any number of packets.</p>
<p id="rfc.section.4.5.5.p.2">Pseudocode for OnAckReceived and UpdateRtt follow:</p>
<pre>
  OnAckReceived(ack):
    largest_acked_packet = ack.largest_acked
    // If the largest acknowledged is newly acked,
    // update the RTT.
    if (sent_packets[ack.largest_acked]):
      latest_rtt = now - sent_packets[ack.largest_acked].time
      UpdateRtt(latest_rtt, ack.ack_delay)

    // Find all newly acked packets in this ACK frame
    newly_acked_packets = DetermineNewlyAckedPackets(ack)
    for acked_packet in newly_acked_packets:
      OnPacketAcked(acked_packet.packet_number)

    if !newly_acked_packets.empty():
      // Find the smallest newly acknowledged packet
      smallest_newly_acked =
        FindSmallestNewlyAcked(newly_acked_packets)
      // If any packets sent prior to RTO were acked, then the
      // RTO was spurious. Otherwise, inform congestion control.
      if (rto_count &gt; 0 &amp;&amp;
            smallest_newly_acked &gt; largest_sent_before_rto):
        OnRetransmissionTimeoutVerified(smallest_newly_acked)
      crypto_count = 0
      tlp_count = 0
      rto_count = 0

    DetectLostPackets(ack.largest_acked_packet)
    SetLossDetectionTimer()

    // Process ECN information if present.
    if (ACK frame contains ECN information):
       ProcessECN(ack)


  UpdateRtt(latest_rtt, ack_delay):
    // min_rtt ignores ack delay.
    min_rtt = min(min_rtt, latest_rtt)
    // Adjust for ack delay if it's plausible.
    if (latest_rtt - min_rtt &gt; ack_delay):
      latest_rtt -= ack_delay
    // Based on {{RFC6298}}.
    if (smoothed_rtt == 0):
      smoothed_rtt = latest_rtt
      rttvar = latest_rtt / 2
    else:
      rttvar_sample = abs(smoothed_rtt - latest_rtt)
      rttvar = 3/4 * rttvar + 1/4 * rttvar_sample
      smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * latest_rtt
</pre>
<h3 id="rfc.section.4.5.6">
<a href="#rfc.section.4.5.6">4.5.6.</a> <a href="#on-packet-acknowledgment" id="on-packet-acknowledgment">On Packet Acknowledgment</a>
</h3>
<p id="rfc.section.4.5.6.p.1">When a packet is acked for the first time, the following OnPacketAcked function is called.  Note that a single ACK frame may newly acknowledge several packets.  OnPacketAcked must be called once for each of these newly acked packets.</p>
<p id="rfc.section.4.5.6.p.2">OnPacketAcked takes one parameter, acked_packet, which is the struct of the newly acked packet.</p>
<p id="rfc.section.4.5.6.p.3">If this is the first acknowledgement following RTO, check if the smallest newly acknowledged packet is one sent by the RTO, and if so, inform congestion control of a verified RTO, similar to F-RTO <a href="#RFC5682" class="xref">[RFC5682]</a>.</p>
<p id="rfc.section.4.5.6.p.4">Pseudocode for OnPacketAcked follows:</p>
<pre>
   OnPacketAcked(acked_packet):
     if (!acked_packet.is_ack_only):
       OnPacketAckedCC(acked_packet)
     sent_packets.remove(acked_packet.packet_number)
</pre>
<h3 id="rfc.section.4.5.7">
<a href="#rfc.section.4.5.7">4.5.7.</a> <a href="#setting-the-loss-detection-timer" id="setting-the-loss-detection-timer">Setting the Loss Detection Timer</a>
</h3>
<p id="rfc.section.4.5.7.p.1">QUIC loss detection uses a single timer for all timer-based loss detection.  The duration of the timer is based on the timer&#8217;s mode, which is set in the packet and timer events further below.  The function SetLossDetectionTimer defined below shows how the single timer is set.</p>
<p id="rfc.section.4.5.7.p.2">Pseudocode for SetLossDetectionTimer follows:</p>
<pre>
 SetLossDetectionTimer():
    // Don't arm timer if there are no retransmittable packets
    // in flight.
    if (bytes_in_flight == 0):
      loss_detection_timer.cancel()
      return

    if (crypto packets are outstanding):
      // Crypto retransmission timer.
      if (smoothed_rtt == 0):
        timeout = 2 * kInitialRtt
      else:
        timeout = 2 * smoothed_rtt
      timeout = max(timeout, kMinTLPTimeout)
      timeout = timeout * (2 ^ crypto_count)
      loss_detection_timer.set(
        time_of_last_sent_crypto_packet + timeout)
      return
    if (loss_time != 0):
      // Early retransmit timer or time loss detection.
      timeout = loss_time -
        time_of_last_sent_retransmittable_packet
    else:
      // RTO or TLP timer
      // Calculate RTO duration
      timeout =
        smoothed_rtt + 4 * rttvar + max_ack_delay
      timeout = max(timeout, kMinRTOTimeout)
      timeout = timeout * (2 ^ rto_count)
      if (tlp_count &lt; kMaxTLPs):
        // Tail Loss Probe
        tlp_timeout = max(1.5 * smoothed_rtt
                           + max_ack_delay, kMinTLPTimeout)
        timeout = min(tlp_timeout, timeout)

    loss_detection_timer.set(
      time_of_last_sent_retransmittable_packet + timeout)
</pre>
<h3 id="rfc.section.4.5.8">
<a href="#rfc.section.4.5.8">4.5.8.</a> <a href="#on-timeout" id="on-timeout">On Timeout</a>
</h3>
<p id="rfc.section.4.5.8.p.1">When the loss detection timer expires, the timer&#8217;s mode determines the action to be performed.</p>
<p id="rfc.section.4.5.8.p.2">Pseudocode for OnLossDetectionTimeout follows:</p>
<pre>
   OnLossDetectionTimeout():
     if (crypto packets are outstanding):
       // Crypto retransmission timeout.
       RetransmitUnackedCryptoData()
       crypto_count++
     else if (loss_time != 0):
       // Early retransmit or Time Loss Detection
       DetectLostPackets(largest_acked_packet)
     else if (tlp_count &lt; kMaxTLPs):
       // Tail Loss Probe.
       SendOnePacket()
       tlp_count++
     else:
       // RTO.
       if (rto_count == 0)
         largest_sent_before_rto = largest_sent_packet
       SendTwoPackets()
       rto_count++

     SetLossDetectionTimer()
</pre>
<h3 id="rfc.section.4.5.9">
<a href="#rfc.section.4.5.9">4.5.9.</a> <a href="#detecting-lost-packets" id="detecting-lost-packets">Detecting Lost Packets</a>
</h3>
<p id="rfc.section.4.5.9.p.1">Packets in QUIC are only considered lost once a larger packet number in the same packet number space is acknowledged.  DetectLostPackets is called every time an ack is received and operates on the sent_packets for that packet number space.  If the loss detection timer expires and the loss_time is set, the previous largest acked packet is supplied.</p>
<h4 id="rfc.section.4.5.9.1">
<a href="#rfc.section.4.5.9.1">4.5.9.1.</a> <a href="#pseudocode-1" id="pseudocode-1">Pseudocode</a>
</h4>
<p id="rfc.section.4.5.9.1.p.1">DetectLostPackets takes one parameter, acked, which is the largest acked packet.</p>
<p id="rfc.section.4.5.9.1.p.2">Pseudocode for DetectLostPackets follows:</p>
<pre>
DetectLostPackets(largest_acked):
  loss_time = 0
  lost_packets = {}
  delay_until_lost = infinite
  if (kUsingTimeLossDetection):
    delay_until_lost =
      (1 + time_reordering_fraction) *
          max(latest_rtt, smoothed_rtt)
  else if (largest_acked.packet_number == largest_sent_packet):
    // Early retransmit timer.
    delay_until_lost = 9/8 * max(latest_rtt, smoothed_rtt)
  foreach (unacked &lt; largest_acked.packet_number):
    time_since_sent = now() - unacked.time_sent
    delta = largest_acked.packet_number - unacked.packet_number
    if (time_since_sent &gt; delay_until_lost ||
        delta &gt; reordering_threshold):
      sent_packets.remove(unacked.packet_number)
      if (!unacked.is_ack_only):
        lost_packets.insert(unacked)
    else if (loss_time == 0 &amp;&amp; delay_until_lost != infinite):
      loss_time = now() + delay_until_lost - time_since_sent

  // Inform the congestion controller of lost packets and
  // lets it decide whether to retransmit immediately.
  if (!lost_packets.empty()):
    OnPacketsLost(lost_packets)
</pre>
<h2 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#discussion" id="discussion">Discussion</a>
</h2>
<p id="rfc.section.4.6.p.1">The majority of constants were derived from best common practices among widely deployed TCP implementations on the internet.  Exceptions follow.</p>
<p id="rfc.section.4.6.p.2">A shorter delayed ack time of 25ms was chosen because longer delayed acks can delay loss recovery and for the small number of connections where less than packet per 25ms is delivered, acking every packet is beneficial to congestion control and loss recovery.</p>
<p id="rfc.section.4.6.p.3">The default initial RTT of 100ms was chosen because it is slightly higher than both the median and mean min_rtt typically observed on the public internet.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#congestion-control" id="congestion-control">Congestion Control</a>
</h1>
<p id="rfc.section.5.p.1">QUIC&#8217;s congestion control is based on TCP NewReno <a href="#RFC6582" class="xref">[RFC6582]</a>.  NewReno is a congestion window based congestion control.  QUIC specifies the congestion window in bytes rather than packets due to finer control and the ease of appropriate byte counting <a href="#RFC3465" class="xref">[RFC3465]</a>.</p>
<p id="rfc.section.5.p.2">QUIC hosts MUST NOT send packets if they would increase bytes_in_flight (defined in <a href="#vars-of-interest" class="xref">Section 5.8.2</a>) beyond the available congestion window, unless the packet is a probe packet sent after the TLP or RTO timer expires, as described in <a href="#tlp" class="xref">Section 4.3.2</a> and <a href="#rto" class="xref">Section 4.3.3</a>.</p>
<p id="rfc.section.5.p.3">Implementations MAY use other congestion control algorithms, and endpoints MAY use different algorithms from one another. The signals QUIC provides for congestion control are generic and are designed to support different algorithms.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#congestion-ecn" id="congestion-ecn">Explicit Congestion Notification</a>
</h2>
<p id="rfc.section.5.1.p.1">If a path has been verified to support ECN, QUIC treats a Congestion Experienced codepoint in the IP header as a signal of congestion. This document specifies an endpoint&#8217;s response when its peer receives packets with the Congestion Experienced codepoint.  As discussed in <a href="#RFC8311" class="xref">[RFC8311]</a>, endpoints are permitted to experiment with other response functions.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#slow-start" id="slow-start">Slow Start</a>
</h2>
<p id="rfc.section.5.2.p.1">QUIC begins every connection in slow start and exits slow start upon loss or upon increase in the ECN-CE counter. QUIC re-enters slow start anytime the congestion window is less than ssthresh, which typically only occurs after an RTO. While in slow start, QUIC increases the congestion window by the number of bytes acknowledged when each acknowledgment is processed.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#congestion-avoidance" id="congestion-avoidance">Congestion Avoidance</a>
</h2>
<p id="rfc.section.5.3.p.1">Slow start exits to congestion avoidance.  Congestion avoidance in NewReno uses an additive increase multiplicative decrease (AIMD) approach that increases the congestion window by one maximum packet size per congestion window acknowledged.  When a loss is detected, NewReno halves the congestion window and sets the slow start threshold to the new congestion window.</p>
<h2 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#recovery-period" id="recovery-period">Recovery Period</a>
</h2>
<p id="rfc.section.5.4.p.1">Recovery is a period of time beginning with detection of a lost packet or an increase in the ECN-CE counter. Because QUIC retransmits stream data and control frames, not packets, it defines the end of recovery as a packet sent after the start of recovery being acknowledged. This is slightly different from TCP&#8217;s definition of recovery, which ends when the lost packet that started recovery is acknowledged.</p>
<p id="rfc.section.5.4.p.2">The recovery period limits congestion window reduction to once per round trip.  During recovery, the congestion window remains unchanged irrespective of new losses or increases in the ECN-CE counter.</p>
<h2 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#tail-loss-probe" id="tail-loss-probe">Tail Loss Probe</a>
</h2>
<p id="rfc.section.5.5.p.1">A TLP packet MUST NOT be blocked by the sender&#8217;s congestion controller. The sender MUST however count TLP packets against bytes in flight, since a TLP adds network load without establishing packet loss.</p>
<p id="rfc.section.5.5.p.2">Acknowledgement or loss of tail loss probes are treated like any other packet.</p>
<h2 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#retransmission-timeout" id="retransmission-timeout">Retransmission Timeout</a>
</h2>
<p id="rfc.section.5.6.p.1">When retransmissions are sent due to a retransmission timeout timer, no change is made to the congestion window until the next acknowledgement arrives.  The retransmission timeout is considered spurious when this acknowledgement acknowledges packets sent prior to the first retransmission timeout.  The retransmission timeout is considered valid when this acknowledgement acknowledges no packets sent prior to the first retransmission timeout.  In this case, the congestion window MUST be reduced to the minimum congestion window and slow start is re-entered.</p>
<h2 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> <a href="#pacing" id="pacing">Pacing</a>
</h2>
<p id="rfc.section.5.7.p.1">This document does not specify a pacer, but it is RECOMMENDED that a sender pace sending of all in-flight packets based on input from the congestion controller. For example, a pacer might distribute the congestion window over the SRTT when used with a window-based controller, and a pacer might use the rate estimate of a rate-based controller.</p>
<p id="rfc.section.5.7.p.2">An implementation should take care to architect its congestion controller to work well with a pacer.  For instance, a pacer might wrap the congestion controller and control the availability of the congestion window, or a pacer might pace out packets handed to it by the congestion controller. Timely delivery of ACK frames is important for efficient loss recovery. Packets containing only ACK frames should therefore not be paced, to avoid delaying their delivery to the peer.</p>
<p id="rfc.section.5.7.p.3">As an example of a well-known and publicly available implementation of a flow pacer, implementers are referred to the Fair Queue packet scheduler (fq qdisc) in Linux (3.11 onwards).</p>
<h2 id="rfc.section.5.8">
<a href="#rfc.section.5.8">5.8.</a> <a href="#pseudocode-2" id="pseudocode-2">Pseudocode</a>
</h2>
<h3 id="rfc.section.5.8.1">
<a href="#rfc.section.5.8.1">5.8.1.</a> <a href="#constants-of-interest-1" id="constants-of-interest-1">Constants of interest</a>
</h3>
<p id="rfc.section.5.8.1.p.1">Constants used in congestion control are based on a combination of RFCs, papers, and common practice.  Some may need to be changed or negotiated in order to better suit a variety of environments.</p>
<p></p>

<dl>
<dt>kMaxDatagramSize:</dt>
<dd style="margin-left: 8">The sender&#8217;s maximum payload size. Does not include UDP or IP overhead.  The max packet size is used for calculating initial and minimum congestion windows. The RECOMMENDED value is 1200 bytes.</dd>
<dt>kInitialWindow:</dt>
<dd style="margin-left: 8">Default limit on the initial amount of outstanding data in bytes.  Taken from <a href="#RFC6928" class="xref">[RFC6928]</a>.  The RECOMMENDED value is the minimum of 10 * kMaxDatagramSize and max(2* kMaxDatagramSize, 14600)).</dd>
<dt>kMinimumWindow:</dt>
<dd style="margin-left: 8">Minimum congestion window in bytes. The RECOMMENDED value is 2 * kMaxDatagramSize.</dd>
<dt>kLossReductionFactor:</dt>
<dd style="margin-left: 8">Reduction in congestion window when a new loss event is detected.  The RECOMMENDED value is 0.5.</dd>
</dl>
<h3 id="rfc.section.5.8.2">
<a href="#rfc.section.5.8.2">5.8.2.</a> <a href="#vars-of-interest" id="vars-of-interest">Variables of interest</a>
</h3>
<p id="rfc.section.5.8.2.p.1">Variables required to implement the congestion control mechanisms are described in this section.</p>
<p></p>

<dl>
<dt>ecn_ce_counter:</dt>
<dd style="margin-left: 8">The highest value reported for the ECN-CE counter by the peer in an ACK frame. This variable is used to detect increases in the reported ECN-CE counter.</dd>
<dt>bytes_in_flight:</dt>
<dd style="margin-left: 8">The sum of the size in bytes of all sent packets that contain at least one retransmittable or PADDING frame, and have not been acked or declared lost. The size does not include IP or UDP overhead, but does include the QUIC header and AEAD overhead.  Packets only containing ACK frames do not count towards bytes_in_flight to ensure congestion control does not impede congestion feedback.</dd>
<dt>congestion_window:</dt>
<dd style="margin-left: 8">Maximum number of bytes-in-flight that may be sent.</dd>
<dt>recovery_start_time:</dt>
<dd style="margin-left: 8">The time when QUIC first detects a loss, causing it to enter recovery.  When a packet sent after this time is acknowledged, QUIC exits recovery.</dd>
<dt>ssthresh:</dt>
<dd style="margin-left: 8">Slow start threshold in bytes.  When the congestion window is below ssthresh, the mode is slow start and the window grows by the number of bytes acknowledged.</dd>
</dl>
<h3 id="rfc.section.5.8.3">
<a href="#rfc.section.5.8.3">5.8.3.</a> <a href="#initialization-1" id="initialization-1">Initialization</a>
</h3>
<p id="rfc.section.5.8.3.p.1">At the beginning of the connection, initialize the congestion control variables as follows:</p>
<pre>
   congestion_window = kInitialWindow
   bytes_in_flight = 0
   recovery_start_time = 0
   ssthresh = infinite
   ecn_ce_counter = 0
</pre>
<h3 id="rfc.section.5.8.4">
<a href="#rfc.section.5.8.4">5.8.4.</a> <a href="#on-packet-sent" id="on-packet-sent">On Packet Sent</a>
</h3>
<p id="rfc.section.5.8.4.p.1">Whenever a packet is sent, and it contains non-ACK frames, the packet increases bytes_in_flight.</p>
<pre>
   OnPacketSentCC(bytes_sent):
     bytes_in_flight += bytes_sent
</pre>
<h3 id="rfc.section.5.8.5">
<a href="#rfc.section.5.8.5">5.8.5.</a> <a href="#on-packet-acknowledgement" id="on-packet-acknowledgement">On Packet Acknowledgement</a>
</h3>
<p id="rfc.section.5.8.5.p.1">Invoked from loss detection&#8217;s OnPacketAcked and is supplied with acked_packet from sent_packets.</p>
<pre>
   InRecovery(sent_time):
     return sent_time &lt;= recovery_start_time

   OnPacketAckedCC(acked_packet):
     // Remove from bytes_in_flight.
     bytes_in_flight -= acked_packet.size
     if (InRecovery(acked_packet.time)):
       // Do not increase congestion window in recovery period.
       return
     if (congestion_window &lt; ssthresh):
       // Slow start.
       congestion_window += acked_packet.size
     else:
       // Congestion avoidance.
       congestion_window += kMaxDatagramSize * acked_packet.size
           / congestion_window
</pre>
<h3 id="rfc.section.5.8.6">
<a href="#rfc.section.5.8.6">5.8.6.</a> <a href="#on-new-congestion-event" id="on-new-congestion-event">On New Congestion Event</a>
</h3>
<p id="rfc.section.5.8.6.p.1">Invoked from ProcessECN and OnPacketsLost when a new congestion event is detected. Starts a new recovery period and reduces the congestion window.</p>
<pre>
   CongestionEvent(time):
     // Start a new congestion event if the sent time is larger
     // than the start time of the previous recovery epoch.
     if (!InRecovery(time)):
       recovery_start_time = time
       congestion_window *= kLossReductionFactor
       congestion_window = max(congestion_window, kMinimumWindow)
       ssthresh = congestion_window
</pre>
<h3 id="rfc.section.5.8.7">
<a href="#rfc.section.5.8.7">5.8.7.</a> <a href="#process-ecn-information" id="process-ecn-information">Process ECN Information</a>
</h3>
<p id="rfc.section.5.8.7.p.1">Invoked when an ACK frame with an ECN section is received from the peer.</p>
<pre>
   ProcessECN(ack):
     // If the ECN-CE counter reported by the peer has increased,
     // this could be a new congestion event.
     if (ack.ce_counter &gt; ecn_ce_counter):
       ecn_ce_counter = ack.ce_counter
       // Start a new congestion event if the last acknowledged
       // packet is past the end of the previous recovery epoch.
       CongestionEvent(Now())
</pre>
<h3 id="rfc.section.5.8.8">
<a href="#rfc.section.5.8.8">5.8.8.</a> <a href="#on-packets-lost" id="on-packets-lost">On Packets Lost</a>
</h3>
<p id="rfc.section.5.8.8.p.1">Invoked by loss detection from DetectLostPackets when new packets are detected lost.</p>
<pre>
   OnPacketsLost(lost_packets):
     // Remove lost packets from bytes_in_flight.
     for (lost_packet : lost_packets):
       bytes_in_flight -= lost_packet.size
     largest_lost_packet = lost_packets.last()

     // Start a new congestion epoch if the last lost packet
     // is past the end of the previous recovery epoch.
     CongestionEvent(largest_lost_packet.time)
</pre>
<h3 id="rfc.section.5.8.9">
<a href="#rfc.section.5.8.9">5.8.9.</a> <a href="#on-retransmission-timeout-verified" id="on-retransmission-timeout-verified">On Retransmission Timeout Verified</a>
</h3>
<p id="rfc.section.5.8.9.p.1">QUIC decreases the congestion window to the minimum value once the retransmission timeout has been verified and removes any packets sent before the newly acknowledged RTO packet.</p>
<pre>
   OnRetransmissionTimeoutVerified(packet_number)
     congestion_window = kMinimumWindow
     // Declare all packets prior to packet_number lost.
     for (sent_packet: sent_packets):
       if (sent_packet.packet_number &lt; packet_number):
         bytes_in_flight -= sent_packet.size
         sent_packets.remove(sent_packet.packet_number)
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h2 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#congestion-signals" id="congestion-signals">Congestion Signals</a>
</h2>
<p id="rfc.section.6.1.p.1">Congestion control fundamentally involves the consumption of signals &#8211; both loss and ECN codepoints &#8211; from unauthenticated entities.  On-path attackers can spoof or alter these signals.  An attacker can cause endpoints to reduce their sending rate by dropping packets, or alter send rate by changing ECN codepoints.</p>
<h2 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#traffic-analysis" id="traffic-analysis">Traffic Analysis</a>
</h2>
<p id="rfc.section.6.2.p.1">Packets that carry only ACK frames can be heuristically identified by observing packet size.  Acknowledgement patterns may expose information about link characteristics or application behavior.  Endpoints can use PADDING frames or bundle acknowledgments with other frames to reduce leaked information.</p>
<h2 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#misreporting-ecn-markings" id="misreporting-ecn-markings">Misreporting ECN Markings</a>
</h2>
<p id="rfc.section.6.3.p.1">A receiver can misreport ECN markings to alter the congestion response of a sender.  Suppressing reports of ECN-CE markings could cause a sender to increase their send rate.  This increase could result in congestion and loss.</p>
<p id="rfc.section.6.3.p.2">A sender MAY attempt to detect suppression of reports by marking occasional packets that they send with ECN-CE.  If a packet marked with ECN-CE is not reported as having been marked when the packet is acknowledged, the sender SHOULD then disable ECN for that path.</p>
<p id="rfc.section.6.3.p.3">Reporting additional ECN-CE markings will cause a sender to reduce their sending rate, which is similar in effect to advertising reduced connection flow control limits and so no advantage is gained by doing so.</p>
<p id="rfc.section.6.3.p.4">Endpoints choose the congestion controller that they use.  Though congestion controllers generally treat reports of ECN-CE markings as equivalent to loss <a href="#RFC8311" class="xref">[RFC8311]</a>, the exact response for each controller could be different.  Failure to correctly respond to information about ECN markings is therefore difficult to detect.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.7.p.1">This document has no IANA actions.  Yet.</p>
<h1 id="rfc.references">
<a href="#rfc.references">8.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">8.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8311">[RFC8311]</b></td>
<td class="top">
<a>Black, D.</a>, "<a href="https://tools.ietf.org/html/rfc8311">Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation</a>", RFC 8311, DOI 10.17487/RFC8311, January 2018.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">8.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3465">[RFC3465]</b></td>
<td class="top">
<a>Allman, M.</a>, "<a href="https://tools.ietf.org/html/rfc3465">TCP Congestion Control with Appropriate Byte Counting (ABC)</a>", RFC 3465, DOI 10.17487/RFC3465, February 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4653">[RFC4653]</b></td>
<td class="top">
<a>Bhandarkar, S.</a>, <a>Reddy, A.</a>, <a>Allman, M.</a> and <a>E. Blanton</a>, "<a href="https://tools.ietf.org/html/rfc4653">Improving the Robustness of TCP to Non-Congestion Events</a>", RFC 4653, DOI 10.17487/RFC4653, August 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5681">[RFC5681]</b></td>
<td class="top">
<a>Allman, M.</a>, <a>Paxson, V.</a> and <a>E. Blanton</a>, "<a href="https://tools.ietf.org/html/rfc5681">TCP Congestion Control</a>", RFC 5681, DOI 10.17487/RFC5681, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5682">[RFC5682]</b></td>
<td class="top">
<a>Sarolahti, P.</a>, <a>Kojo, M.</a>, <a>Yamamoto, K.</a> and <a>M. Hata</a>, "<a href="https://tools.ietf.org/html/rfc5682">Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</a>", RFC 5682, DOI 10.17487/RFC5682, September 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5827">[RFC5827]</b></td>
<td class="top">
<a>Allman, M.</a>, <a>Avrachenkov, K.</a>, <a>Ayesta, U.</a>, <a>Blanton, J.</a> and <a>P. Hurtig</a>, "<a href="https://tools.ietf.org/html/rfc5827">Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)</a>", RFC 5827, DOI 10.17487/RFC5827, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6298">[RFC6298]</b></td>
<td class="top">
<a>Paxson, V.</a>, <a>Allman, M.</a>, <a>Chu, J.</a> and <a>M. Sargent</a>, "<a href="https://tools.ietf.org/html/rfc6298">Computing TCP's Retransmission Timer</a>", RFC 6298, DOI 10.17487/RFC6298, June 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6582">[RFC6582]</b></td>
<td class="top">
<a>Henderson, T.</a>, <a>Floyd, S.</a>, <a>Gurtov, A.</a> and <a>Y. Nishida</a>, "<a href="https://tools.ietf.org/html/rfc6582">The NewReno Modification to TCP's Fast Recovery Algorithm</a>", RFC 6582, DOI 10.17487/RFC6582, April 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6675">[RFC6675]</b></td>
<td class="top">
<a>Blanton, E.</a>, <a>Allman, M.</a>, <a>Wang, L.</a>, <a>Jarvinen, I.</a>, <a>Kojo, M.</a> and <a>Y. Nishida</a>, "<a href="https://tools.ietf.org/html/rfc6675">A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP</a>", RFC 6675, DOI 10.17487/RFC6675, August 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6928">[RFC6928]</b></td>
<td class="top">
<a>Chu, J.</a>, <a>Dukkipati, N.</a>, <a>Cheng, Y.</a> and <a>M. Mathis</a>, "<a href="https://tools.ietf.org/html/rfc6928">Increasing TCP's Initial Window</a>", RFC 6928, DOI 10.17487/RFC6928, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="TLP">[TLP]</b></td>
<td class="top">
<a>Dukkipati, N.</a>, <a>Cardwell, N.</a>, <a>Cheng, Y.</a> and <a>M. Mathis</a>, "<a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses</a>", Internet-Draft draft-dukkipati-tcpm-tcp-loss-probe-01, February 2013.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li></ul>
<h2 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#since-draft-ietf-quic-recovery-14" id="since-draft-ietf-quic-recovery-14">Since draft-ietf-quic-recovery-14</a>
</h2>
<p></p>

<ul>
<li>Used max_ack_delay from transport params (#1796, #1782)</li>
<li>Merge ACK and ACK_ECN (#1783)</li>
</ul>
<h2 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#since-draft-ietf-quic-recovery-13" id="since-draft-ietf-quic-recovery-13">Since draft-ietf-quic-recovery-13</a>
</h2>
<p></p>

<ul>
<li>Corrected the lack of ssthresh reduction in CongestionEvent pseudocode (#1598)</li>
<li>Considerations for ECN spoofing (#1426, #1626)</li>
<li>Clarifications for PADDING and congestion control (#837, #838, #1517, #1531, #1540)</li>
<li>Reduce early retransmission timer to RTT/8 (#945, #1581)</li>
<li>Packets are declared lost after an RTO is verified (#935, #1582)</li>
</ul>
<h2 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#since-draft-ietf-quic-recovery-12" id="since-draft-ietf-quic-recovery-12">Since draft-ietf-quic-recovery-12</a>
</h2>
<p></p>

<ul>
<li>Changes to manage separate packet number spaces and encryption levels (#1190, #1242, #1413, #1450)</li>
<li>Added ECN feedback mechanisms and handling; new ACK_ECN frame (#804, #805, #1372)</li>
</ul>
<h2 id="rfc.appendix.A.4">
<a href="#rfc.appendix.A.4">A.4.</a> <a href="#since-draft-ietf-quic-recovery-11" id="since-draft-ietf-quic-recovery-11">Since draft-ietf-quic-recovery-11</a>
</h2>
<p id="rfc.section.A.4.p.1">No significant changes.</p>
<h2 id="rfc.appendix.A.5">
<a href="#rfc.appendix.A.5">A.5.</a> <a href="#since-draft-ietf-quic-recovery-10" id="since-draft-ietf-quic-recovery-10">Since draft-ietf-quic-recovery-10</a>
</h2>
<p></p>

<ul>
<li>Improved text on ack generation (#1139, #1159)</li>
<li>Make references to TCP recovery mechanisms informational (#1195)</li>
<li>Define time_of_last_sent_handshake_packet (#1171)</li>
<li>Added signal from TLS the data it includes needs to be sent in a Retry packet (#1061, #1199)</li>
<li>Minimum RTT (min_rtt) is initialized with an infinite value (#1169)</li>
</ul>
<h2 id="rfc.appendix.A.6">
<a href="#rfc.appendix.A.6">A.6.</a> <a href="#since-draft-ietf-quic-recovery-09" id="since-draft-ietf-quic-recovery-09">Since draft-ietf-quic-recovery-09</a>
</h2>
<p id="rfc.section.A.6.p.1">No significant changes.</p>
<h2 id="rfc.appendix.A.7">
<a href="#rfc.appendix.A.7">A.7.</a> <a href="#since-draft-ietf-quic-recovery-08" id="since-draft-ietf-quic-recovery-08">Since draft-ietf-quic-recovery-08</a>
</h2>
<p></p>

<ul><li>Clarified pacing and RTO (#967, #977)</li></ul>
<h2 id="rfc.appendix.A.8">
<a href="#rfc.appendix.A.8">A.8.</a> <a href="#since-draft-ietf-quic-recovery-07" id="since-draft-ietf-quic-recovery-07">Since draft-ietf-quic-recovery-07</a>
</h2>
<p></p>

<ul>
<li>Include Ack Delay in RTO(and TLP) computations (#981)</li>
<li>Ack Delay in SRTT computation (#961)</li>
<li>Default RTT and Slow Start (#590)</li>
<li>Many editorial fixes.</li>
</ul>
<h2 id="rfc.appendix.A.9">
<a href="#rfc.appendix.A.9">A.9.</a> <a href="#since-draft-ietf-quic-recovery-06" id="since-draft-ietf-quic-recovery-06">Since draft-ietf-quic-recovery-06</a>
</h2>
<p id="rfc.section.A.9.p.1">No significant changes.</p>
<h2 id="rfc.appendix.A.10">
<a href="#rfc.appendix.A.10">A.10.</a> <a href="#since-draft-ietf-quic-recovery-05" id="since-draft-ietf-quic-recovery-05">Since draft-ietf-quic-recovery-05</a>
</h2>
<p></p>

<ul><li>Add more congestion control text (#776)</li></ul>
<h2 id="rfc.appendix.A.11">
<a href="#rfc.appendix.A.11">A.11.</a> <a href="#since-draft-ietf-quic-recovery-04" id="since-draft-ietf-quic-recovery-04">Since draft-ietf-quic-recovery-04</a>
</h2>
<p id="rfc.section.A.11.p.1">No significant changes.</p>
<h2 id="rfc.appendix.A.12">
<a href="#rfc.appendix.A.12">A.12.</a> <a href="#since-draft-ietf-quic-recovery-03" id="since-draft-ietf-quic-recovery-03">Since draft-ietf-quic-recovery-03</a>
</h2>
<p id="rfc.section.A.12.p.1">No significant changes.</p>
<h2 id="rfc.appendix.A.13">
<a href="#rfc.appendix.A.13">A.13.</a> <a href="#since-draft-ietf-quic-recovery-02" id="since-draft-ietf-quic-recovery-02">Since draft-ietf-quic-recovery-02</a>
</h2>
<p></p>

<ul>
<li>Integrate F-RTO (#544, #409)</li>
<li>Add congestion control (#545, #395)</li>
<li>Require connection abort if a skipped packet was acknowledged (#415)</li>
<li>Simplify RTO calculations (#142, #417)</li>
</ul>
<h2 id="rfc.appendix.A.14">
<a href="#rfc.appendix.A.14">A.14.</a> <a href="#since-draft-ietf-quic-recovery-01" id="since-draft-ietf-quic-recovery-01">Since draft-ietf-quic-recovery-01</a>
</h2>
<p></p>

<ul>
<li>Overview added to loss detection</li>
<li>Changes initial default RTT to 100ms</li>
<li>Added time-based loss detection and fixes early retransmit</li>
<li>Clarified loss recovery for handshake packets</li>
<li>Fixed references and made TCP references informative</li>
</ul>
<h2 id="rfc.appendix.A.15">
<a href="#rfc.appendix.A.15">A.15.</a> <a href="#since-draft-ietf-quic-recovery-00" id="since-draft-ietf-quic-recovery-00">Since draft-ietf-quic-recovery-00</a>
</h2>
<p></p>

<ul><li>Improved description of constants and ACK behavior</li></ul>
<h2 id="rfc.appendix.A.16">
<a href="#rfc.appendix.A.16">A.16.</a> <a href="#since-draft-iyengar-quic-loss-recovery-01" id="since-draft-iyengar-quic-loss-recovery-01">Since draft-iyengar-quic-loss-recovery-01</a>
</h2>
<p></p>

<ul>
<li>Adopted as base for draft-ietf-quic-recovery</li>
<li>Updated authors/editors list</li>
<li>Added table of contents</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Fastly</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri.ietf@gmail.com">jri.ietf@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Swett</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Swett</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ianswett@google.com">ianswett@google.com</a></span>

  </address>
</div>

</body>
</html>
