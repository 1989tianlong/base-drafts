<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Notational Conventions"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions"/>
<link href="#rfc.section.3" rel="Chapter" title="3 A QUIC Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Low-Latency Version Negotiation"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Low-Latency Connection Establishment"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Stream Multiplexing"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Rich Signaling for Congestion Control and Loss Recovery"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Stream and Connection Flow Control"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Authenticated and Encrypted Header and Payload"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Connection Migration and Resilience to NAT Rebinding"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Packet Types and Formats"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Common Header"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Regular Packets"/>
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Packet Number Compression and Reconstruction"/>
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Frames and Frame Types"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Version Negotiation Packet"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Public Reset Packet"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="7 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Hamilton, R., Iyengar, J., Swett, I., and A. Wilk" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-transport-protocol-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-11-22" />
  <meta name="dct.abstract" content="QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss recovery and congestion control, and the use of TLS 1.3 for key negotiation." />
  <meta name="description" content="QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss recovery and congestion control, and the use of TLS 1.3 for key negotiation." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">R. Hamilton</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">J. Iyengar</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">I. Swett</td>
</tr>
<tr>
  <td class="left">Expires: May 26, 2017</td>
  <td class="right">A. Wilk</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">November 22, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC: A UDP-Based Multiplexed and Secure Transport<br />
  <span class="filename">draft-ietf-quic-transport-protocol-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss recovery and congestion control, and the use of TLS 1.3 for key negotiation.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 26, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Notational Conventions</a></li>
</ul><li>2.   <a href="#rfc.section.2">Conventions and Definitions</a></li>
<li>3.   <a href="#rfc.section.3">A QUIC Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Low-Latency Version Negotiation</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Low-Latency Connection Establishment</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Stream Multiplexing</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Rich Signaling for Congestion Control and Loss Recovery</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Stream and Connection Flow Control</a></li>
<li>3.6.   <a href="#rfc.section.3.6">Authenticated and Encrypted Header and Payload</a></li>
<li>3.7.   <a href="#rfc.section.3.7">Connection Migration and Resilience to NAT Rebinding</a></li>
</ul><li>4.   <a href="#rfc.section.4">Packet Types and Formats</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Common Header</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Regular Packets</a></li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Packet Number Compression and Reconstruction</a></li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Frames and Frame Types</a></li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Version Negotiation Packet</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Public Reset Packet</a></li>
</ul><li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<li>7.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the substrate, QUIC seeks to be compatible with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing middleboxes and other third parties from changing them, and encrypts most of its headers, limiting protocol evolution largely to QUIC endpoints only.</p>
<p id="rfc.section.1.p.2">This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss detection and congestion control <a href="#I-D.iyengar-quic-loss-recovery">[I-D.iyengar-quic-loss-recovery]</a>, and the use of TLS 1.3 for key negotiation <a href="#I-D.thomson-quic-tls">[I-D.thomson-quic-tls]</a>.</p>
<h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h2>
<p id="rfc.section.1.1.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a></h1>
<p id="rfc.section.2.p.1">Definitions of terms that are used in this document:</p>
<p/>

<ul>
  <li>Client: The endpoint initiating a QUIC connection.</li>
  <li>Server: The endpoint accepting incoming QUIC connections.</li>
  <li>Endpoint: The client or server end of a connection.</li>
  <li>Stream: A logical, bi-directional channel of ordered bytes within a QUIC connection.</li>
  <li>Connection: A conversation between two QUIC endpoints with a single encryption context that multiplexes streams within it.</li>
  <li>Connection ID: The identifier for a QUIC connection.</li>
  <li>QUIC packet: A well-formed UDP payload that can be parsed by a QUIC receiver.  QUIC packet size in this document refers to the UDP payload size.</li>
</ul>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#a-quic-overview" id="a-quic-overview">A QUIC Overview</a></h1>
<p id="rfc.section.3.p.1">This section briefly describes QUIC&#8217;s key mechanisms and benefits.  Key strengths of QUIC include:</p>
<p/>

<ul>
  <li>Low-latency Version Negotiation</li>
  <li>Low-latency connection establishment</li>
  <li>Multiplexing without head-of-line blocking</li>
  <li>Authenticated and encrypted header and payload</li>
  <li>Rich signaling for congestion control and loss recovery</li>
  <li>Stream and connection flow control</li>
  <li>Connection Migration and Resilience to NAT rebinding</li>
</ul>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#low-latency-version-negotiation" id="low-latency-version-negotiation">Low-Latency Version Negotiation</a></h2>
<p id="rfc.section.3.1.p.1">QUIC combines version negotiation with the rest of connection establishment to avoid unnecessary roundtrip delays.  A QUIC client proposes a version to use for the connection, and encodes the rest of the handshake using the proposed version.  If the server does not speak the client-chosen version, it forces version negotiation by sending back a Version Negotiation packet to the client, causing a roundtrip of delay before connection establishment.</p>
<p id="rfc.section.3.1.p.2">This mechanism eliminates roundtrip latency when the client&#8217;s optimistically-chosen version is spoken by the server, and incentivizes servers to not lag behind clients in deployment of newer versions. Additionally, an application may negotiate QUIC versions out-of-band to increase chances of success in the first roundtrip and to obviate the additional roundtrip in the case of version mismatch.</p>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#low-latency-connection-establishment" id="low-latency-connection-establishment">Low-Latency Connection Establishment</a></h2>
<p id="rfc.section.3.2.p.1">QUIC relies on a combined crypto and transport handshake for setting up a secure transport connection.  QUIC connections are expected to commonly use 0-RTT handshakes, meaning that for most QUIC connections, data can be sent immediately following the client handshake packet, without waiting for a reply from the server.  QUIC provides a dedicated stream (Stream ID 1) to be used for performing the crypto handshake and QUIC options negotiation.  The format of the QUIC options and parameters used during negotiation are described in this document, but the handshake protocol that runs on Stream ID 1 is described in the accompanying crypto handshake draft {{!I-D.thomson- quic-tls}}.</p>
<h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#stream-multiplexing" id="stream-multiplexing">Stream Multiplexing</a></h2>
<p id="rfc.section.3.3.p.1">When application messages are transported over TCP, independent application messages can suffer from head-of-line blocking.  When an application multiplexes many streams atop TCP&#8217;s single-bytestream abstraction, a loss of a TCP segment results in blocking of all subsequent segments until a retransmission arrives, irrespective of the application streams that are encapsulated in subsequent segments.  QUIC ensures that lost packets carrying data for an individual stream only impact that specific stream.  Data received on other streams can continue to be reassembled and delivered to the application.</p>
<h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#rich-signaling-for-congestion-control-and-loss-recovery" id="rich-signaling-for-congestion-control-and-loss-recovery">Rich Signaling for Congestion Control and Loss Recovery</a></h2>
<p id="rfc.section.3.4.p.1">QUIC&#8217;s packet framing and acknowledgments carry rich information that help both congestion control and loss recovery in fundamental ways.  Each QUIC packet carries a new packet number, including those carrying retransmitted data.  This obviates the need for a separate mechanism to distinguish acks for retransmissions from those for original transmissions, avoiding TCP&#8217;s retransmission ambiguity problem.  QUIC acknowledgments also explicitly encode the delay between the receipt of a packet and its acknowledgment being sent, and together with the monotonically-increasing packet numbers, this allows for precise network roundtrip-time (RTT) calculation.  QUIC&#8217;s ACK frames support up to 256 ack blocks, so QUIC is more resilient to reordering than TCP with SACK support, as well as able to keep more bytes on the wire when there is reordering or loss.</p>
<h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#stream-and-connection-flow-control" id="stream-and-connection-flow-control">Stream and Connection Flow Control</a></h2>
<p id="rfc.section.3.5.p.1">QUIC implements stream- and connection-level flow control, closely following HTTP/2&#8217;s flow control mechanisms.  At a high level, a QUIC receiver advertises the absolute byte offset within each stream up to which the receiver is willing to receive data.  As data is sent, received, and delivered on a particular stream, the receiver sends WINDOW_UPDATE frames that increase the advertised offset limit for that stream, allowing the peer to send more data on that stream.  In addition to this stream-level flow control, QUIC implements connection-level flow control to limit the aggregate buffer that a QUIC receiver is willing to allocate to all streams on a connection.  Connection-level flow control works in the same way as stream-level flow control, but the bytes delivered and highest received offset are all aggregates across all streams.</p>
<h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#authenticated-and-encrypted-header-and-payload" id="authenticated-and-encrypted-header-and-payload">Authenticated and Encrypted Header and Payload</a></h2>
<p id="rfc.section.3.6.p.1">TCP headers appear in plaintext on the wire and are not authenticated, causing a plethora of injection and header manipulation issues for TCP, such as receive-window manipulation and sequence-number overwriting.  While some of these are mechanisms used by middleboxes to improve TCP performance, others are active attacks.  Even &#8220;performance-enhancing&#8221; middleboxes that routinely interpose on the transport state machine end up limiting the evolvability of the transport protocol, as has been observed in the design of MPTCP and in its subsequent deployability issues.</p>
<p id="rfc.section.3.6.p.2">Generally, QUIC packets are always authenticated and the payload is typically fully encrypted.  The parts of the packet header which are not encrypted are still authenticated by the receiver, so as to thwart any packet injection or manipulation by third parties.  Some early handshake packets, such as the Version Negotiation packet, are not encrypted, but information sent in these unencrypted handshake packets is later verified under crypto cover.</p>
<p id="rfc.section.3.6.p.3">PUBLIC_RESET packets that reset a connection are currently not authenticated.</p>
<h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#connection-migration-and-resilience-to-nat-rebinding" id="connection-migration-and-resilience-to-nat-rebinding">Connection Migration and Resilience to NAT Rebinding</a></h2>
<p id="rfc.section.3.7.p.1">QUIC connections are identified by a 64-bit Connection ID, randomly generated by the client.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and port, such as those caused by NAT rebindings or by the client changing network connectivity to a new address.  QUIC provides automatic cryptographic verification of a rebound client, since the client continues to use the same session key for encrypting and decrypting packets.  The consistent connection ID can be used to allow migration of the connection to a new server IP address as well, since the Connection ID remains consistent across changes in the client&#8217;s and the server&#8217;s network addresses.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#packet-types-and-formats" id="packet-types-and-formats">Packet Types and Formats</a></h1>
<p id="rfc.section.4.p.1">We first describe QUIC&#8217;s packet types and their formats, since some are referenced in subsequent mechanisms.  Note that unless otherwise noted, all values specified in this document are in little-endian format and all field sizes are in bits.</p>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#common-header" id="common-header">Common Header</a></h2>
<p id="rfc.section.4.1.p.1">All QUIC packets begin with a QUIC Common header, as shown below.</p>
<pre>
   +------------+---------------------------------+
   |  Flags(8)  |  Connection ID (64) (optional)  |
   +------------+---------------------------------+
</pre>
<p id="rfc.section.4.1.p.2">The fields in the Common Header are the following:</p>
<p/>

<ul>
  <li>Flags: <ul><li>0x01 = VERSION.  The semantics of this flag depends on whether the packet is sent by the server or the client.  A client MAY set this flag and include exactly one proposed version.  A server may set this flag when the client-proposed version was unsupported, and may then provide a list (0 or more) of acceptable versions as a part of version negotiation (described in Section XXX.)</li><li>0x02 = PUBLIC_RESET.  Set to indicate that the packet is a Public Reset packet.</li><li>0x04 = DIVERSIFICATION_NONCE.  Set to indicate the presence of a 32-byte diversification nonce in the header.  (DISCUSS_AND_MODIFY: This flag should be removed along with the Diversification Nonce bits, as discussed further below.)</li><li>0x08 = CONNECTION_ID.  Indicates the Connection ID is present in the packet.  This must be set in all packets until negotiated to a different value for a given direction.  For instance, if a client indicates that the 5-tuple fully identifies the connection at the client, the connection ID is optional in the server-to-client direction.</li><li>0x30 = PACKET_NUMBER_SIZE.  These two bits indicate the number of low-order-bytes of the packet number that are present in each packet.  <ul><li>11 indicates that 6 bytes of the packet number are present</li><li>10 indicates that 4 bytes of the packet number are present</li><li>01 indicates that 2 bytes of the packet number are present</li><li>00 indicates that 1 byte of the packet number is present</li></ul></li><li>0x40 = MULTIPATH.  This bit is reserved for multipath use.</li><li>0x80 is currently unused, and must be set to 0.</li></ul></li>
  <li>Connection ID: An unsigned 64-bit random number chosen by the client, used as the identifier of the connection.  Connection ID is tied to a QUIC connection, and remains consistent across client and/or server IP and port changes.</li>
</ul>
<p id="rfc.section.4.1.p.4">While all QUIC packets have the same common header, there are three types of packets: Regular packets, Version Negotiation packets, and Public Reset packets.  The flowchart below shows how a packet is classified into one of these three packet types:</p>
<div id="rfc.figure.1"/>
<div id="packet-types"/>
<pre>
Check the flags in the common header
                 |
                 |
                 V
           +--------------+
           | PUBLIC_RESET |  YES
           | flag set?    |-------&gt; Public Reset packet
           +--------------+
                 |
                 | NO
                 V
           +------------+         +-------------+
           | VERSION    |  YES    | Packet sent |  YES
           | flag set?  |--------&gt;| by server?  |--------&gt; Version Negotiation
           +------------+         +-------------+               packet
                 |                       |
                 | NO                    | NO
                 V                       V
         Regular packet with       Regular packet with
     no QUIC Version in header    QUIC Version in header
</pre>
<p class="figure">Figure 1: Types of QUIC Packets</p>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#regular-packets" id="regular-packets">Regular Packets</a></h2>
<p id="rfc.section.4.2.p.1">Each Regular packet&#8217;s header consists of a Common Header followed by fields specific to Regular packets, as shown below:</p>
<div id="rfc.figure.2"/>
<div id="regular-packet-format"/>
<pre>
+------------+---------------------------------+
|  Flags(8)  |  Connection ID (64) (optional)  | -&gt;
+------------+---------------------------------+
+---------------------------------------+-------------------------------+
|  Version (32) (client-only, optional) |  Diversification Nonce (256)  | -&gt;
+---------------------------------------+-------------------------------+
+------------------------------------+
|  Packet Number (8, 16, 32, or 48)  | -&gt;
+------------------------------------+
+------------+
|  AEAD Data |
+------------+

Decrypted AEAD Data:
+------------+-----------+     +-----------+
|   Frame 1  |  Frame 2  | ... |  Frame N  |
+------------+-----------+     +-----------+
</pre>
<p class="figure">Figure 2: Regular Packet</p>
<p id="rfc.section.4.2.p.2">The fields in a Regular packet past the Common Header are the following:</p>
<p/>

<ul>
  <li>QUIC Version: A 32-bit opaque tag that represents the version of the QUIC protocol.  Only present in the client-to-server direction, and if the VERSION flag is set.  Version Negotiation is described in Section XXX.</li>
  <li>DISCUSS_AND_REPLACE: Diversification Nonce: A 32-byte nonce generated by the server and used only in the Server-&gt;Client direction to ensure that the server is able to generate unique keys per connection.  Specifically, when using QUIC&#8217;s 0-RTT crypto handshake, a repeated CHLO with the exact same connection ID and CHLO can lead to the same (intermediate) initial-encryption keys being derived for the connection.  A server-generated nonce disallows a client from causing the same keys to be derived for two distinct connections.  Once the connection is forward-secure, this nonce is no longer present in packets.  This nonce can be removed from the packet header if a requirement can be added for the crypto handshake to ensure key uniqueness.  The expectation is that TLS1.3 meets this requirement.  Upon working group adoption of this document, this requirement should be added to the crypto handshake requirements, and the nonce should be removed from the packet format.</li>
  <li>Packet Number: The lower 8, 16, 32, or 48 bits of the packet number, based on the PACKET_NUMBER_SIZE flag.  Each Regular packet is assigned a packet number by the sender.  The first packet sent by an endpoint MUST have a packet number of 1.</li>
  <li>AEAD Data: A Regular packet&#8217;s header, which includes the Common Header, and the Version, Diversification Nonce, and Packet Number fields, is authenticated but not encrypted.  The rest of a Regular packet, starting with the first frame, is both authenticated and encrypted.  Immediately following the header, Regular packets contain AEAD (Authenticated Encryption with Associated Data) data.  This data must be decrypted in order for the contents to be interpreted.  After decryption, the plaintext consists of a sequence of frames, as shown (frames are described in Section XXX).</li>
</ul>
<h3 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#packet-number-compression-and-reconstruction" id="packet-number-compression-and-reconstruction">Packet Number Compression and Reconstruction</a></h3>
<p id="rfc.section.4.2.1.p.1">The complete packet number is a 64-bit unsigned number and is used as part of a cryptographic nonce for packet encryption.  To reduce the number of bits required to represent the packet number over the wire, at most 48 bits of the packet number are transmitted over the wire.  A QUIC endpoint MUST NOT reuse a complete packet number within the same connection (that is, under the same cryptographic keys).  If the total number of packets transmitted in this connection reaches 2^64 - 1, the sender MUST close the connection by sending a CONNECTION_CLOSE frame with the error code QUIC_SEQUENCE_NUMBER_LIMIT_REACHED (connection termination is described in Section XXX.)  For unambiguous reconstruction of the complete packet number by a receiver from the lower-order bits, a QUIC sender MUST NOT have more than 2^(packet_number_size - 2) in flight at any point in the connection.  In other words,</p>
<p/>

<ul>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 11, it MUST NOT have more than (2^46) packets in flight.</li>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 10, it MUST NOT have more than (2^30) packets in flight.</li>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 01, it MUST NOT have more than (2^14) packets in flight.</li>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 00, it MUST NOT have more than (2^6) packets in flight.  <br/><br/> DISCUSS: Should the receiver be required to enforce this rule that the sender MUST NOT exceed the inflight limit?  Specifically, should the receiver drop packets that are received outside this window?  <br/><br/> Any truncated packet number received from a peer MUST be reconstructed as the value closest to the next expected packet number from that peer.</li>
</ul>
<p id="rfc.section.4.2.1.p.3">(TODO: Clarify how packet number size can change mid-connection.)</p>
<h3 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#frames-and-frame-types" id="frames-and-frame-types">Frames and Frame Types</a></h3>
<p id="rfc.section.4.2.2.p.1">A Regular packet MUST contain at least one frame, and MAY contain multiple frames and multiple frame types.  Frames MUST fit within a single QUIC packet and MUST NOT span a QUIC packet boundary.  Each frame begins with a Frame Type byte, indicating its type, followed by type-dependent headers, and variable-length data, as follows:</p>
<pre>
   +-----------+---------------------------+-------------------------+
   |  Type (8) |  Headers (type-dependent) |  Data (type-dependent)  |
   +-----------+---------------------------+-------------------------+
</pre>
<p id="rfc.section.4.2.2.p.2">The following table lists currently defined frame types.  Note that the Frame Type byte in STREAM and ACK frames is used to carry other frame-specific flags.  For all other frames, the Frame Type byte simply identifies the frame.  These frames are explained in more detail as they are referenced later in the document.</p>
<div id="rfc.figure.3"/>
<div id="frame-types"/>
<pre>
      +------------------+--------------------+
      | Type-field value |     Frame type     |
      +------------------+--------------------+
      | 1FDOOOSS         |  STREAM            |
      | 01NTLLMM         |  ACK               |
      | 00000000 (0x00)  |  PADDING           |
      | 00000001 (0x01)  |  RST_STREAM        |
      | 00000010 (0x02)  |  CONNECTION_CLOSE  |
      | 00000011 (0x03)  |  GOAWAY            |
      | 00000100 (0x04)  |  WINDOW_UPDATE     |
      | 00000101 (0x05)  |  BLOCKED           |
      | 00000110 (0x06)  |  STOP_WAITING      |
      | 00000111 (0x07)  |  PING              |
      +------------------+--------------------+
</pre>
<p class="figure">Figure 3: Types of QUIC Frames</p>
<h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#version-negotiation-packet" id="version-negotiation-packet">Version Negotiation Packet</a></h2>
<p id="rfc.section.4.3.p.1">A Version Negotiation packet is only sent by the server, MUST have the VERSION flag set, and MUST include the full 64-bit Connection ID.  The rest of the Version Negotiation packet is a list of 4-byte versions which the server supports, as shown below.</p>
<div id="rfc.figure.4"/>
<div id="version-negotiation-format"/>
<pre>
+-----------------------------------+
|  Flags(8)  |  Connection ID (64)  | -&gt;
+-----------------------------------+
+------------------------------+----------------------------------------+
|  1st Supported Version (32)  |  2nd Supported Version (32) supported  | ...
+------------------------------+----------------------------------------+
</pre>
<p class="figure">Figure 4: Version Negotiation Packet</p>
<h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#public-reset-packet" id="public-reset-packet">Public Reset Packet</a></h2>
<p id="rfc.section.4.4.p.1">A Public Reset packet MUST have the PUBLIC_RESET flag set, and MUST include the full 64-bit connection ID.  The rest of the Public Reset packet is encoded as if it were a crypto handshake message of the tag PRST, as shown below.</p>
<div id="rfc.figure.5"/>
<div id="public-reset-format"/>
<pre>
   +-----------------------------------+
   |  Flags(8)  |  Connection ID (64)  | -&gt;
   +-----------------------------------+
   +-------------------------------------+
   |  Quic Tag (PRST) and tag value map  |
   +-------------------------------------+
</pre>
<p class="figure">Figure 5: Public Reset Packet</p>
<p id="rfc.section.4.4.p.2">The tag value map contains the following tag-values:</p>
<p/>

<ul>
  <li>RNON (public reset nonce proof) - a 64-bit unsigned integer.</li>
  <li>RSEQ (rejected packet number) - a 64-bit packet number.</li>
  <li>CADR (client address) - the observed client IP address and port number.  This is currently for debugging purposes only and hence is optional.</li>
</ul>
<p id="rfc.section.4.4.p.4">DISCUSS_AND_REPLACE: The crypto handshake message format is described in the QUIC crypto document, and should be replaced with something simpler when this document is adopted.  The purpose of the tag-value map following the PRST tag is to enable the receiver of the Public Reset packet to reasonably authenticate the packet.  This map is an extensible map format that allows specification of various tags, which should again be replaced by something simpler.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">This document has no IANA actions yet.</p>
<h1 id="rfc.references"><a href="#rfc.references">7.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.iyengar-quic-loss-recovery">[I-D.iyengar-quic-loss-recovery]</b>
      </td>
      <td class="top"><a>Iyengar, J.</a> and <a>I. Swett</a>, "<a href="http://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-01">QUIC Congestion Control And Loss Recovery</a>", Internet-Draft draft-iyengar-quic-loss-recovery-01, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.thomson-quic-tls">[I-D.thomson-quic-tls]</b>
      </td>
      <td class="top"><a>Thomson, M.</a> and <a>R. Hamilton</a>, "<a href="http://tools.ietf.org/html/draft-thomson-quic-tls-01">Using Transport Layer Security (TLS) to Secure QUIC</a>", Internet-Draft draft-thomson-quic-tls-01, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ryan Hamilton</span> 
	  <span class="n hidden">
		<span class="family-name">Hamilton</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rch@google.com">rch@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> 
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri@google.com">jri@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ian Swett</span> 
	  <span class="n hidden">
		<span class="family-name">Swett</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ianswett@google.com">ianswett@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alyssa Wilk</span> 
	  <span class="n hidden">
		<span class="family-name">Wilk</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:alyssar@google.com">alyssar@google.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/quicwg/base-drafts">Fork me on GitHub</a></div></div>
</body>
</html>
