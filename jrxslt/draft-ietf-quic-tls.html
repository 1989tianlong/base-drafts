<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Using Transport Layer Security (TLS) to Secure QUIC</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Protocol Overview" href="#rfc.section.2"><link rel="Chapter" title="3 TLS in Stream 1" href="#rfc.section.3"><link rel="Chapter" title="4 QUIC Packet Protection" href="#rfc.section.4"><link rel="Chapter" title="5 Pre-handshake QUIC Messages" href="#rfc.section.5"><link rel="Chapter" title="6 QUIC-Specific Additions to the TLS Handshake" href="#rfc.section.6"><link rel="Chapter" title="7 Security Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 IANA Considerations" href="#rfc.section.8"><link rel="Chapter" href="#rfc.section.9" title="9 References"><link rel="Appendix" title="A Contributors" href="#rfc.section.A"><link rel="Appendix" title="B Acknowledgments" href="#rfc.section.B"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.840, 2016/11/16 05:32:10, XSLT vendor: libxslt http://xmlsoft.org/XSLT/"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Thomson, M."><meta name="dcterms.creator" content="Turner, Ed, S."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-quic-tls-latest"><meta name="dcterms.issued" content="2016-11-28"><meta name="dcterms.abstract" content="This document describes how Transport Layer Security (TLS) can be used to secure QUIC."><meta name="description" content="This document describes how Transport Layer Security (TLS) can be used to secure QUIC."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">QUIC Working Group</td><td class="right">M. Thomson</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Mozilla</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">S. Turner, Ed, Editor</td></tr><tr><td class="left">Expires: June 1, 2017</td><td class="right">sn3rd</td></tr><tr><td class="left"></td><td class="right">November 28, 2016</td></tr></tbody></table><div id="rfc.title"><h1>Using Transport Layer Security (TLS) to Secure QUIC</h1><div class="filename">draft-ietf-quic-tls-latest</div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><p>This document describes how Transport Layer Security (TLS) can be used to secure QUIC.</p></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on June 1, 2017.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2016 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#protocol-overview">Protocol Overview</a><ul><li><a href="#rfc.section.2.1">2.1</a>   <a href="#handshake-overview">Handshake Overview</a></li></ul></li><li><a href="#rfc.section.3">3.</a>   <a href="#tls-in-stream-1">TLS in Stream 1</a><ul><li><a href="#rfc.section.3.1">3.1</a>   <a href="#handshake-and-setup-sequence">Handshake and Setup Sequence</a></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#packet-protection">QUIC Packet Protection</a><ul><li><a href="#rfc.section.4.1">4.1</a>   <a href="#key-phases">Key Phases</a><ul><li><a href="#rfc.section.4.1.1">4.1.1</a>   <a href="#hs-retransmit">Retransmission of TLS Handshake Messages</a></li><li><a href="#rfc.section.4.1.2">4.1.2</a>   <a href="#zero-transition">Distinguishing 0-RTT and 1-RTT Packets</a></li></ul></li><li><a href="#rfc.section.4.2">4.2</a>   <a href="#key-expansion">QUIC Key Expansion</a><ul><li><a href="#rfc.section.4.2.1">4.2.1</a>   <a href="#rtt-secret">0-RTT Secret</a></li><li><a href="#rfc.section.4.2.2">4.2.2</a>   <a href="#rtt-secrets">1-RTT Secrets</a></li><li><a href="#rfc.section.4.2.3">4.2.3</a>   <a href="#packet-protection-key-and-iv">Packet Protection Key and IV</a></li></ul></li><li><a href="#rfc.section.4.3">4.3</a>   <a href="#aead">QUIC AEAD Usage</a></li><li><a href="#rfc.section.4.4">4.4</a>   <a href="#key-update">Key Update</a></li><li><a href="#rfc.section.4.5">4.5</a>   <a href="#packet-number">Packet Numbers</a></li></ul></li><li><a href="#rfc.section.5">5.</a>   <a href="#pre-handshake">Pre-handshake QUIC Messages</a><ul><li><a href="#rfc.section.5.1">5.1</a>   <a href="#pre-handshake-unprotected">Unprotected Frames Prior to Handshake Completion</a><ul><li><a href="#rfc.section.5.1.1">5.1.1</a>   <a href="#stream-frames">STREAM Frames</a></li><li><a href="#rfc.section.5.1.2">5.1.2</a>   <a href="#ack-frames">ACK Frames</a></li><li><a href="#rfc.section.5.1.3">5.1.3</a>   <a href="#windowupdate-frames">WINDOW_UPDATE Frames</a></li><li><a href="#rfc.section.5.1.4">5.1.4</a>   <a href="#denial-of-service-with-unprotected-packets">Denial of Service with Unprotected Packets</a></li></ul></li><li><a href="#rfc.section.5.2">5.2</a>   <a href="#using-early-data">Use of 0-RTT Keys</a></li><li><a href="#rfc.section.5.3">5.3</a>   <a href="#pre-handshake-protected">Protected Frames Prior to Handshake Completion</a></li></ul></li><li><a href="#rfc.section.6">6.</a>   <a href="#quic-specific-additions-to-the-tls-handshake">QUIC-Specific Additions to the TLS Handshake</a><ul><li><a href="#rfc.section.6.1">6.1</a>   <a href="#version-negotiation">Protocol and Version Negotiation</a></li><li><a href="#rfc.section.6.2">6.2</a>   <a href="#quic_parameters">QUIC Extension</a></li><li><a href="#rfc.section.6.3">6.3</a>   <a href="#source-address">Source Address Validation</a></li><li><a href="#rfc.section.6.4">6.4</a>   <a href="#priming-0-rtt">Priming 0-RTT</a></li></ul></li><li><a href="#rfc.section.7">7.</a>   <a href="#security-considerations">Security Considerations</a><ul><li><a href="#rfc.section.7.1">7.1</a>   <a href="#reflection">Packet Reflection Attack Mitigation</a></li><li><a href="#rfc.section.7.2">7.2</a>   <a href="#useless">Peer Denial of Service</a></li></ul></li><li><a href="#rfc.section.8">8.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.9">9.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.9.1">9.1</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.9.2">9.2</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>   <a href="#contributors">Contributors</a></li><li><a href="#rfc.section.B">B.</a>   <a href="#acknowledgments">Acknowledgments</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><ul class="toc"><li>Figures
        <ul><li><a href="#rfc.figure.1">Figure 1: QUIC Structure</a></li><li><a href="#rfc.figure.2">Figure 2: TLS Handshake with 0-RTT</a></li><li><a href="#rfc.figure.3">Figure 3: QUIC over TLS Handshake</a></li><li><a href="#rfc.figure.4">Figure 4: Key Update</a></li></ul></li></ul><hr class="noprint"><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>QUIC <a href="#QUIC-TRANSPORT"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC-TRANSPORT]</cite></a> provides a multiplexed transport. When used for HTTP <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> semantics <a href="#QUIC-HTTP"><cite title="HTTP/2 Semantics Using The QUIC Transport Protocol">[QUIC-HTTP]</cite></a> it provides several key advantages over HTTP/1.1 <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> or HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> over TCP <a href="#RFC0793"><cite title="Transmission Control Protocol">[RFC0793]</cite></a>.</p></div><div id="rfc.section.1.p.2"><p>This document describes how QUIC can be secured using Transport Layer Security (TLS) version 1.3 <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>. TLS 1.3 provides critical latency improvements for connection establishment over previous versions. Absent packet loss, most new connections can be established and secured within a single round trip; on subsequent connections between the same client and server, the client can often send application data immediately, that is, zero round trip setup.</p></div><div id="rfc.section.1.p.3"><p>This document describes how the standardized TLS 1.3 can act a security component of QUIC. The same design could work for TLS 1.2, though few of the benefits QUIC provides would be realized due to the handshake latency in versions of TLS prior to 1.3.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The words “MUST”, “MUST NOT”, “SHOULD”, and “MAY” are used in this document. It’s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><hr class="noprint"><section id="protocol-overview"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a> <a href="#protocol-overview">Protocol Overview</a></h2><div id="rfc.section.2.p.1" class="avoidbreakafter"><p>QUIC <a href="#QUIC-TRANSPORT"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC-TRANSPORT]</cite></a> can be separated into several modules:</p></div><div id="rfc.section.2.p.2"><ol><li>The basic frame envelope describes the common packet layout. This layer includes connection identification, version negotiation, and includes markers that allow the framing and public reset to be identified.</li><li>The public reset is an unprotected packet that allows an intermediary (an entity that is not part of the security context) to request the termination of a QUIC connection.</li><li>Version negotiation frames are used to agree on a common version of QUIC to use.</li><li>Framing comprises most of the QUIC protocol. Framing provides a number of different types of frame, each with a specific purpose. Framing supports frames for both congestion management and stream multiplexing. Framing additionally provides a liveness testing capability (the PING frame).</li><li>Encryption provides confidentiality and integrity protection for frames. All frames are protected based on keying material derived from the TLS connection running on stream 1. Prior to this, data is protected with the 0-RTT keys.</li><li>Multiplexed streams are the primary payload of QUIC. These provide reliable, in-order delivery of data and are used to carry the encryption handshake and transport parameters (stream 1), HTTP header fields (stream 3), and HTTP requests and responses. Frames for managing multiplexing include those for creating and destroying streams as well as flow control and priority frames.</li><li>Congestion management includes packet acknowledgment and other signal required to ensure effective use of available link capacity.</li><li>A complete TLS connection is run on stream 1. This includes the entire TLS record layer. As the TLS connection reaches certain states, keying material is provided to the QUIC encryption layer for protecting the remainder of the QUIC traffic.</li><li>The HTTP mapping <a href="#QUIC-HTTP"><cite title="HTTP/2 Semantics Using The QUIC Transport Protocol">[QUIC-HTTP]</cite></a> provides an adaptation to HTTP semantics that is based on HTTP/2.</li></ol></div><div id="rfc.section.2.p.3"><p>The relative relationship of these components are pictorally represented in <a href="#quic-structure">Figure 1</a>.</p></div><div id="quic-structure"></div><div id="rfc.figure.1"><pre>
   +-----+------+
   | TLS | HTTP |
   +-----+------+------------+
   |  Streams   | Congestion |
   +------------+------------+
   |         Frames          +--------+---------+
   +   +---------------------+ Public | Version |
   |   |     Encryption      | Reset  |  Nego.  |
   +---+---------------------+--------+---------+
   |                   Envelope                 |
   +--------------------------------------------+
   |                     UDP                    |
   +--------------------------------------------+
</pre></div><p class="figure">Figure 1: QUIC Structure</p><div id="rfc.section.2.p.4"><p>This document defines the cryptographic parts of QUIC. This includes the handshake messages that are exchanged on stream 1, plus the record protection that is used to encrypt and authenticate all other frames.</p></div><section id="handshake-overview"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a> <a href="#handshake-overview">Handshake Overview</a></h3><div id="rfc.section.2.1.p.1" class="avoidbreakafter"><p>TLS 1.3 provides two basic handshake modes of interest to QUIC:</p></div><div id="rfc.section.2.1.p.2"><ul><li>A full handshake in which the client is able to send application data after one round trip and the server immediately after receiving the first message from the client.</li><li>A 0-RTT handshake in which the client uses information about the server to send immediately. This data can be replayed by an attacker so it MUST NOT carry a self-contained trigger for any non-idempotent action.</li></ul></div><div id="rfc.section.2.1.p.3"><p>A simplified TLS 1.3 handshake with 0-RTT application data is shown in <a href="#tls-full">Figure 2</a>, see <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a> for more options and details.</p></div><div id="tls-full"></div><div id="rfc.figure.2"><pre>
    Client                                             Server

    ClientHello
   (0-RTT Application Data)
   (end_of_early_data)        --------&gt;
                                                  ServerHello
                                         {EncryptedExtensions}
                                         {ServerConfiguration}
                                                 {Certificate}
                                           {CertificateVerify}
                                                    {Finished}
                             &lt;--------      [Application Data]
   {Finished}                --------&gt;

   [Application Data]        &lt;-------&gt;      [Application Data]
</pre></div><p class="figure">Figure 2: TLS Handshake with 0-RTT</p><div id="rfc.section.2.1.p.4" class="avoidbreakafter"><p>Two additional variations on this basic handshake exchange are relevant to this document:</p></div><div id="rfc.section.2.1.p.5"><ul><li>The server can respond to a ClientHello with a HelloRetryRequest, which adds an additional round trip prior to the basic exchange. This is needed if the server wishes to request a different key exchange key from the client. HelloRetryRequest is also used to verify that the client is correctly able to receive packets on the address it claims to have (see <a href="#source-address" title="Source Address Validation">Section 6.3</a>).</li><li>A pre-shared key mode can be used for subsequent handshakes to avoid public key operations. This is the basis for 0-RTT data, even if the remainder of the connection is protected by a new Diffie-Hellman exchange.</li></ul></div></section></section><hr class="noprint"><section id="tls-in-stream-1"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a> <a href="#tls-in-stream-1">TLS in Stream 1</a></h2><div id="rfc.section.3.p.1"><p>QUIC completes its cryptographic handshake on stream 1, which means that the negotiation of keying material happens after the QUIC protocol has started. This simplifies the use of TLS since QUIC is able to ensure that the TLS handshake packets are delivered reliably and in order.</p></div><div id="rfc.section.3.p.2"><p>QUIC Stream 1 carries a complete TLS connection. This includes the TLS record layer in its entirety. QUIC provides for reliable and in-order delivery of the TLS handshake messages on this stream.</p></div><div id="rfc.section.3.p.3"><p>Prior to the completion of the TLS handshake, QUIC frames can be exchanged. However, these frames are not authenticated or confidentiality protected. <a href="#pre-handshake" title="Pre-handshake QUIC Messages">Section 5</a> covers some of the implications of this design and limitations on QUIC operation during this phase.</p></div><div id="rfc.section.3.p.4"><p>Once the TLS handshake completes, QUIC frames are protected using QUIC record protection, see <a href="#packet-protection" title="QUIC Packet Protection">Section 4</a>. If 0-RTT is possible, QUIC frames sent by the client can be protected with 0-RTT keys; these packets are subject to replay.</p></div><section id="handshake-and-setup-sequence"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a> <a href="#handshake-and-setup-sequence">Handshake and Setup Sequence</a></h3><div id="rfc.section.3.1.p.1"><p>The integration of QUIC with a TLS handshake is shown in more detail in <a href="#quic-tls-handshake">Figure 3</a>. QUIC <span class="tt">STREAM</span> frames on stream 1 carry the TLS handshake. QUIC performs loss recovery <a href="#QUIC-RECOVERY"><cite title="QUIC Loss Detection and Congestion Control">[QUIC-RECOVERY]</cite></a> for this stream and ensures that TLS handshake messages are delivered in the correct order.</p></div><div id="quic-tls-handshake"></div><div id="rfc.figure.3"><pre>
    Client                                             Server

@A QUIC STREAM Frame(s) &lt;1&gt;:
     ClientHello
       + QUIC Setup Parameters
                            --------&gt;
                        0-RTT Key =&gt; @B

@B QUIC STREAM Frame(s) &lt;any stream&gt;:
   Replayable QUIC Frames
                            --------&gt;

                                      QUIC STREAM Frame &lt;1&gt;: @A
                                               ServerHello
                                      {Handshake Messages}
                            &lt;--------
                        1-RTT Key =&gt; @C

                                           QUIC Frames &lt;any&gt; @C
                            &lt;--------
@A QUIC STREAM Frame(s) &lt;1&gt;:
     (end_of_early_data)
     {Finished}
                            --------&gt;

@C QUIC Frames &lt;any&gt;        &lt;-------&gt;      QUIC Frames &lt;any&gt; @C
</pre></div><p class="figure">Figure 3: QUIC over TLS Handshake</p><div id="rfc.section.3.1.p.2" class="avoidbreakafter"><p>In <a href="#quic-tls-handshake">Figure 3</a>, symbols mean:</p></div><div id="rfc.section.3.1.p.3"><ul><li>”&lt;” and “&gt;” enclose stream numbers.</li><li>”@” indicates the key phase that is currently used for protecting QUIC packets.</li><li>”(“ and “)” enclose messages that are protected with TLS 0-RTT handshake or application keys.</li><li>”{“ and “}” enclose messages that are protected by the TLS Handshake keys.</li></ul></div><div id="rfc.section.3.1.p.4"><p>If 0-RTT is not possible, then the client does not send frames protected by the 0-RTT key (@B). In that case, the only key transition on the client is from cleartext (@A) to 1-RTT protection (@C).</p></div><div id="rfc.section.3.1.p.5"><p>The server sends TLS handshake messages without protection (@A). The server transitions from no protection (@A) to full 1-RTT protection (@C) after it sends the last of its handshake messages.</p></div><div id="rfc.section.3.1.p.6"><p>Some TLS handshake messages are protected by the TLS handshake record protection. However, keys derived at this stage are not exported for use in QUIC. QUIC frames from the server are sent in the clear until the final transition to 1-RTT keys.</p></div><div id="rfc.section.3.1.p.7"><p>The client transitions from @A to @B when sending 0-RTT data, but it transitions back to @A when sending its second flight of TLS handshake messages. This introduces a potential for confusion between packets with 0-RTT protection (@B) and those with 1-RTT protection (@C) at the server if there is loss or reordering of the handshake packets. See <a href="#zero-transition" title="Distinguishing 0-RTT and 1-RTT Packets">Section 4.1.2</a> for details on how this is addressed.</p></div></section></section><hr class="noprint"><section id="packet-protection"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a> <a href="#packet-protection">QUIC Packet Protection</a></h2><div id="rfc.section.4.p.1"><p>QUIC provides a packet protection layer that is responsible for authenticated encryption of packets. The packet protection layer uses keys provided by the TLS connection and authenticated encryption to provide confidentiality and integrity protection for the content of packets (see <a href="#aead" title="QUIC AEAD Usage">Section 4.3</a>).</p></div><div id="rfc.section.4.p.2"><p>Different keys are used for QUIC packet protection and TLS record protection. Having separate QUIC and TLS record protection means that TLS records can be protected by two different keys. This redundancy is limited to a only a few TLS records, and is maintained for the sake of simplicity.</p></div><div id="rfc.section.4.p.3"><p>Keying material for new keys is exported from TLS using TLS exporters. These exported values are used to produce the keying material used to protect packets (see <a href="#key-expansion" title="QUIC Key Expansion">Section 4.2</a>).</p></div><section id="key-phases"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a> <a href="#key-phases">Key Phases</a></h3><div id="rfc.section.4.1.p.1"><p>At several stages during the handshake, new keying material can be exported from TLS and used for QUIC packet protection. At each transition during the handshake a new secret is exported from TLS and keying material is derived from that secret.</p></div><div id="rfc.section.4.1.p.2"><p>Every time that a new set of keys is used for protecting outbound packets, the KEY_PHASE bit in the public flags is toggled. The KEY_PHASE bit starts out with a value of 0 and is set to 1 when the first encrypted packets are sent. Once the connection is fully enabled, the KEY_PHASE bit can toggle between 0 and 1 as keys are updated (see <a href="#key-update" title="Key Update">Section 4.4</a>).</p></div><div id="rfc.section.4.1.p.3"><p>The KEY_PHASE bit on the public flags is the most significant bit (0x80).</p></div><div id="rfc.section.4.1.p.4"><p>The KEY_PHASE bit allows a recipient to detect a change in keying material without necessarily needing to receive the first packet that triggered the change. An endpoint that notices a changed KEY_PHASE bit can update keys and decrypt the packet that contains the changed bit. This isn’t possible during the handshake, because the entire first flight of TLS handshake messages is used as input to key derivation.</p></div><div id="rfc.section.4.1.p.5" class="avoidbreakafter"><p>The following transitions are possible:</p></div><div id="rfc.section.4.1.p.6"><ul><li>When using 0-RTT, the client transitions to using 0-RTT keys after sending the ClientHello. The KEY_PHASE bit on 0-RTT packets sent by the client is set to 1.</li><li>The server sends messages in the clear until the TLS handshake completes. The KEY_PHASE bit on packets sent by the server is set to 0 when the handshake is in progress. Note that TLS handshake messages will still be protected by TLS record protection based on the TLS handshake traffic keys.</li><li>The server transitions to using 1-RTT keys after sending its Finished message. This causes the KEY_PHASE bit on packets sent by the server to be set to 1.</li><li>The client transitions back to cleartext when sending its second flight of TLS handshake messages. KEY_PHASE on the client’s second flight of handshake messages is set back to 0. This includes a TLS end_of_early_data alert, which is protected with TLS (not QUIC) 0-RTT keys.</li><li>The client transitions to sending with 1-RTT keys and a KEY_PHASE of 1 after sending its Finished message.</li><li>Once the handshake is complete and all TLS handshake messages have been sent and acknowledged, either endpoint can send packets with a new set of keys. This is signaled by toggling the value of the KEY_PHASE bit, see <a href="#key-update" title="Key Update">Section 4.4</a>.</li></ul></div><div id="rfc.section.4.1.p.7"><p>At each transition point, both keying material (see <a href="#key-expansion" title="QUIC Key Expansion">Section 4.2</a>) and the AEAD function used by TLS is interchanged with the values that are currently in use for protecting outbound packets. Once a change of keys has been made, packets with higher sequence numbers MUST use the new keying material until a newer set of keys (and AEAD) are used. The exception to this is that retransmissions of TLS handshake packets MUST use the keys that they were originally protected with (see <a href="#hs-retransmit" title="Retransmission of TLS Handshake Messages">Section 4.1.1</a>).</p></div><section id="hs-retransmit"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1</a> <a href="#hs-retransmit">Retransmission of TLS Handshake Messages</a></h4><div id="rfc.section.4.1.1.p.1"><p>TLS handshake messages need to be retransmitted with the same level of cryptographic protection that was originally used to protect them. Newer keys cannot be used to protect QUIC packets that carry TLS messages.</p></div><div id="rfc.section.4.1.1.p.2"><p>A client would be unable to decrypt retransmissions of a server’s handshake messages that are protected using the 1-RTT keys, since the calculation of the 1-RTT keys depends on the contents of the handshake messages.</p></div><div id="rfc.section.4.1.1.p.3"><p>This restriction means the creation of an exception to the requirement to always use new keys for sending once they are available. A server MUST mark the retransmitted handshake messages with the same KEY_PHASE as the original messages to allow a recipient to distinguish retransmitted messages.</p></div><div id="rfc.section.4.1.1.p.4"><p>This rule also prevents a key update from being initiated while there are any outstanding handshake messages, see <a href="#key-update" title="Key Update">Section 4.4</a>.</p></div></section><section id="zero-transition"><h4 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2</a> <a href="#zero-transition">Distinguishing 0-RTT and 1-RTT Packets</a></h4><div id="rfc.section.4.1.2.p.1"><p>Loss or reordering of the client’s second flight of TLS handshake messages can cause 0-RTT packet and 1-RTT packets to become indistinguishable from each other when they arrive at the server. Both 0-RTT packets use a KEY_PHASE of 1.</p></div><div id="rfc.section.4.1.2.p.2"><p>A server does not need to receive the client’s second flight of TLS handshake messages in order to derive the secrets needed to decrypt 1-RTT messages. Thus, a server is able to decrypt 1-RTT messages that arrive prior to receiving the client’s Finished message. Of course, any decision that might be made based on client authentication needs to be delayed until the client’s authentication messages have been received and validated.</p></div><div id="rfc.section.4.1.2.p.3"><p>A server can distinguish between 0-RTT and 1-RTT packets by TBDTBDTBD.</p></div></section></section><section id="key-expansion"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a> <a href="#key-expansion">QUIC Key Expansion</a></h3><div id="rfc.section.4.2.p.1"><p>QUIC uses a system of packet protection secrets, keys and IVs that are modelled on the system used in TLS <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>. The secrets that QUIC uses as the basis of its key schedule are obtained using TLS exporters (see Section 7.3.3 of <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>).</p></div><div id="rfc.section.4.2.p.2"><p>QUIC uses the Pseudo-Random Function (PRF) hash function negotiated by TLS for key derivation. For example, if TLS is using the TLS_AES_128_GCM_SHA256, the SHA-256 hash function is used.</p></div><section id="rtt-secret"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1</a> <a href="#rtt-secret">0-RTT Secret</a></h4><div id="rfc.section.4.2.1.p.1"><p>0-RTT keys are those keys that are used in resumed connections prior to the completion of the TLS handshake. Data sent using 0-RTT keys might be replayed and so has some restrictions on its use, see <a href="#using-early-data" title="Use of 0-RTT Keys">Section 5.2</a>. 0-RTT keys are used after sending or receiving a ClientHello.</p></div><div id="rfc.section.4.2.1.p.2"><p>The secret is exported from TLS using the exporter label “EXPORTER-QUIC 0-RTT Secret” and an empty context. The size of the secret MUST be the size of the hash output for the PRF hash function negotiated by TLS. This uses the TLS early_exporter_secret. The QUIC 0-RTT secret is only used for protection of packets sent by the client.</p></div><div id="rfc.figure.u.1"><pre>
   client_0rtt_secret
       = TLS-Exporter("EXPORTER-QUIC 0-RTT Secret"
                      "", Hash.length)
</pre></div></section><section id="rtt-secrets"><h4 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2</a> <a href="#rtt-secrets">1-RTT Secrets</a></h4><div id="rfc.section.4.2.2.p.1"><p>1-RTT keys are used by both client and server after the TLS handshake completes. There are two secrets used at any time: one is used to derive packet protection keys for packets sent by the client, the other for protecting packets sent by the server.</p></div><div id="rfc.section.4.2.2.p.2"><p>The initial client packet protection secret is exported from TLS using the exporter label “EXPORTER-QUIC client 1-RTT Secret”; the initial server packet protection secret uses the exporter label “EXPORTER-QUIC server 1-RTT Secret”. Both exporters use an empty context. The size of the secret MUST be the size of the hash output for the PRF hash function negotiated by TLS.</p></div><div id="rfc.figure.u.2"><pre>
   client_pp_secret_0
       = TLS-Exporter("EXPORTER-QUIC client 1-RTT Secret"
                      "", Hash.length)
   server_pp_secret_0
       = TLS-Exporter("EXPORTER-QUIC server 1-RTT Secret"
                      "", Hash.length)
</pre></div><div id="rfc.section.4.2.2.p.3"><p>After a key update (see <a href="#key-update" title="Key Update">Section 4.4</a>), these secrets are updated using the HKDF-Expand-Label function defined in Section 7.1 of <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>, using the PRF hash function negotiated by TLS. The replacement secret is derived using the existing Secret, a Label of “QUIC client 1-RTT Secret” for the client and “QUIC server 1-RTT Secret”, an empty HashValue, and the same output Length as the hash function selected by TLS for its PRF.</p></div><div id="rfc.figure.u.3"><pre>
   client_pp_secret_&lt;N+1&gt;
       = HKDF-Expand-Label(client_pp_secret_&lt;N&gt;,
                           "QUIC client 1-RTT Secret",
                           "", Hash.length)
   server_pp_secret_&lt;N+1&gt;
       = HKDF-Expand-Label(server_pp_secret_&lt;N&gt;,
                           "QUIC server 1-RTT Secret",
                           "", Hash.length)
</pre></div><div id="rfc.section.4.2.2.p.4" class="avoidbreakafter"><p>For example, the client secret is updated using HKDF-Expand <a href="#RFC5869"><cite title="HMAC-based Extract-and-Expand Key Derivation Function (HKDF)">[RFC5869]</cite></a> with an info parameter that includes the PRF hash length encoded on two octets, the string “TLS 1.3, QUIC client 1-RTT secret” and a zero octet. This equates to a single use of HMAC <a href="#RFC2104"><cite title="HMAC: Keyed-Hashing for Message Authentication">[RFC2104]</cite></a> with the negotiated PRF hash function:</p></div><div id="rfc.figure.u.4"><pre>
   info = Hash.length / 256 || Hash.length % 256 ||
          "TLS 1.3, QUIC client 1-RTT secret" || 0x00
   client_pp_secret_&lt;N+1&gt;
       = HMAC-Hash(client_pp_secret_&lt;N&gt;, info || 0x01)
</pre></div></section><section id="packet-protection-key-and-iv"><h4 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3</a> <a href="#packet-protection-key-and-iv">Packet Protection Key and IV</a></h4><div id="rfc.section.4.2.3.p.1"><p>The complete key expansion uses an identical process for key expansion as defined in Section 7.3 of <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>, using different values for the input secret. QUIC uses the AEAD function negotiated by TLS.</p></div><div id="rfc.section.4.2.3.p.2"><p>The key and IV used to protect the 0-RTT packets sent by a client use the QUIC 0-RTT secret. This uses the HKDF-Expand-Label with the PRF hash function negotiated by TLS. The length of the output is determined by the requirements of the AEAD function selected by TLS.</p></div><div id="rfc.figure.u.5"><pre>
   client_0rtt_key = HKDF-Expand-Label(client_0rtt_secret,
                                       "key", "", key_length)
   client_0rtt_iv = HKDF-Expand-Label(client_0rtt_secret,
                                      "iv", "", iv_length)
</pre></div><div id="rfc.section.4.2.3.p.3"><p>Similarly, the key and IV used to protect 1-RTT packets sent by both client and server use the current packet protection secret.</p></div><div id="rfc.figure.u.6"><pre>
   client_pp_key_&lt;N&gt; = HKDF-Expand-Label(client_pp_secret_&lt;N&gt;,
                                         "key", "", key_length)
   client_pp_iv_&lt;N&gt; = HKDF-Expand-Label(client_pp_secret_&lt;N&gt;,
                                        "iv", "", iv_length)
   server_pp_key_&lt;N&gt; = HKDF-Expand-Label(server_pp_secret_&lt;N&gt;,
                                         "key", "", key_length)
   server_pp_iv_&lt;N&gt; = HKDF-Expand-Label(server_pp_secret_&lt;N&gt;,
                                        "iv", "", iv_length)
</pre></div><div id="rfc.section.4.2.3.p.4"><p>The QUIC record protection initially starts without keying material. When the TLS state machine reports that the ClientHello has been sent, the 0-RTT keys can be generated and installed for writing. When the TLS state machine reports completion of the handshake, the 1-RTT keys can be generated and installed for writing.</p></div></section></section><section id="aead"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a> <a href="#aead">QUIC AEAD Usage</a></h3><div id="rfc.section.4.3.p.1"><p>The Authentication Encryption with Associated Data (AEAD) <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a> function used for QUIC packet protection is AEAD that is negotiated for use with the TLS connection. For example, if TLS is using the TLS_AES_128_GCM_SHA256, the AEAD_AES_128_GCM function is used.</p></div><div id="rfc.section.4.3.p.2"><p>Regular QUIC packets are protected by an AEAD <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a>. Version negotiation and public reset packets are not protected.</p></div><div id="rfc.section.4.3.p.3"><p>Once TLS has provided a key, the contents of regular QUIC packets immediately after any TLS messages have been sent are protected by the AEAD selected by TLS.</p></div><div id="rfc.section.4.3.p.4"><p>The key, K, for the AEAD is either the Client Write Key or the Server Write Key, derived as defined in <a href="#key-expansion" title="QUIC Key Expansion">Section 4.2</a>.</p></div><div id="rfc.section.4.3.p.5"><p>The nonce, N, for the AEAD is formed by combining either the Client Write IV or Server Write IV with packet numbers. The 64 bits of the reconstructed QUIC packet number in network byte order is left-padded with zeros to the N_MAX parameter of the AEAD (see Section 4 of <a href="#RFC5116"><cite title="An Interface and Algorithms for Authenticated Encryption">[RFC5116]</cite></a>). The exclusive OR of the padded packet number and the IV forms the AEAD nonce.</p></div><div id="rfc.section.4.3.p.6"><p>The associated data, A, for the AEAD is an empty sequence.</p></div><div id="rfc.section.4.3.p.7"><p>The input plaintext, P, for the AEAD is the contents of the QUIC frame following the packet number, as described in <a href="#QUIC-TRANSPORT"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC-TRANSPORT]</cite></a>.</p></div><div id="rfc.section.4.3.p.8"><p>The output ciphertext, C, of the AEAD is transmitted in place of P.</p></div><div id="rfc.section.4.3.p.9"><p>Prior to TLS providing keys, no record protection is performed and the plaintext, P, is transmitted unmodified.</p></div></section><section id="key-update"><h3 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4</a> <a href="#key-update">Key Update</a></h3><div id="rfc.section.4.4.p.1"><p>Once the TLS handshake is complete, the KEY_PHASE bit allows for refreshes of keying material by either peer. Endpoints start using updated keys immediately without additional signaling; the change in the KEY_PHASE bit indicates that a new key is in use.</p></div><div id="rfc.section.4.4.p.2"><p>An endpoint MUST NOT initiate more than one key update at a time. A new key cannot be used until the endpoint has received and successfully decrypted a packet with a matching KEY_PHASE.</p></div><div id="rfc.section.4.4.p.3"><p>A receiving endpoint detects an update when the KEY_PHASE bit doesn’t match what it is expecting. It creates a new secret (see <a href="#key-expansion" title="QUIC Key Expansion">Section 4.2</a>) and the corresponding read key and IV. If the packet can be decrypted and authenticated using these values, then a write keys and IV are generated and the active keys are replaced. The next packet sent by the endpoint will then use the new keys.</p></div><div id="rfc.section.4.4.p.4"><p>An endpoint doesn’t need to send packets immediately when it detects that its peer has updated keys. The next packets that it sends will simply use the new keys. If an endpoint detects a second update before it has sent any packets with updated keys it indicates that its peer has updated keys twice without awaiting a reciprocal update. An endpoint MUST treat consecutive key updates as a fatal error and abort the connection.</p></div><div id="rfc.section.4.4.p.5"><p>An endpoint SHOULD retain old keys for a short period to allow it to decrypt packets with smaller packet numbers than the packet that triggered the key update. This allows an endpoint to consume packets that are reordered around the transition between keys. Packets with higher packet numbers always use the updated keys and MUST NOT be decrypted with old keys.</p></div><div id="rfc.section.4.4.p.6"><p>Keys and their corresponding secrets SHOULD be discarded when an endpoints has received all packets with sequence numbers lower than the lowest sequence number used for the new key, or when it determines that the length of the delay to affected packets is excessive.</p></div><div id="rfc.section.4.4.p.7"><p>This ensures that once the handshake is complete, there are at most two keys to distinguish between at any one time, for which the KEY_PHASE bit is sufficient.</p></div><div id="ex-key-update"></div><div id="rfc.figure.4"><pre>
   Initiating Peer                    Responding Peer

@M QUIC Frames
                    New Keys -&gt; @N
@N QUIC Frames
                      --------&gt;
                                          QUIC Frames @M
                    New Keys -&gt; @N
                                          QUIC Frames @N
                      &lt;--------
</pre></div><p class="figure">Figure 4: Key Update</p><div id="rfc.section.4.4.p.8"><p>As shown in <a href="#quic-tls-handshake">Figure 3</a> and <a href="#ex-key-update">Figure 4</a>, there is never a situation where there are more than two different sets of keying material that might be received by a peer. Once both sending and receiving keys have been updated,</p></div><div id="rfc.section.4.4.p.9"><p>A server cannot initiate a key update until it has received the client’s Finished message. Otherwise, packets protected by the updated keys could be confused for retransmissions of handshake messages. A client cannot initiate a key update until all of its handshake messages have been acknowledged by the server.</p></div></section><section id="packet-number"><h3 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5</a> <a href="#packet-number">Packet Numbers</a></h3><div id="rfc.section.4.5.p.1"><p>QUIC has a single, contiguous packet number space. In comparison, TLS restarts its sequence number each time that record protection keys are changed. The sequence number restart in TLS ensures that a compromise of the current traffic keys does not allow an attacker to truncate the data that is sent after a key update by sending additional packets under the old key (causing new packets to be discarded).</p></div><div id="rfc.section.4.5.p.2"><p>QUIC does not assume a reliable transport and is therefore required to handle attacks where packets are dropped in other ways.</p></div><div id="rfc.section.4.5.p.3"><p>The packet number is not reset and it is not permitted to go higher than its maximum value of 2^64-1. This establishes a hard limit on the number of packets that can be sent. Before this limit is reached, some AEAD functions have limits for how many packets can be encrypted under the same key and IV (see for example <a href="#AEBounds"><cite title="Limits on Authenticated Encryption Use in TLS">[AEBounds]</cite></a>). An endpoint MUST initiate a key update (<a href="#key-update" title="Key Update">Section 4.4</a>) prior to exceeding any limit set for the AEAD that is in use.</p></div><div id="rfc.section.4.5.p.4"><p>TLS maintains a separate sequence number that is used for record protection on the connection that is hosted on stream 1. This sequence number is reset according to the rules in the TLS protocol.</p></div></section></section><hr class="noprint"><section id="pre-handshake"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a> <a href="#pre-handshake">Pre-handshake QUIC Messages</a></h2><div id="rfc.section.5.p.1"><p>Implementations MUST NOT exchange data on any stream other than stream 1 prior to the completion of the TLS handshake. However, QUIC requires the use of several types of frame for managing loss detection and recovery. In addition, it might be useful to use the data acquired during the exchange of unauthenticated messages for congestion management.</p></div><div id="rfc.section.5.p.2"><p>This section generally only applies to TLS handshake messages from both peers and acknowledgments of the packets carrying those messages. In many cases, the need for servers to provide acknowledgments is minimal, since the messages that clients send are small and implicitly acknowledged by the server’s responses.</p></div><div id="rfc.section.5.p.3"><p>The actions that a peer takes as a result of receiving an unauthenticated packet needs to be limited. In particular, state established by these packets cannot be retained once record protection commences.</p></div><div id="rfc.section.5.p.4" class="avoidbreakafter"><p>There are several approaches possible for dealing with unauthenticated packets prior to handshake completion:</p></div><div id="rfc.section.5.p.5"><ul><li>discard and ignore them</li><li>use them, but reset any state that is established once the handshake completes</li><li>use them and authenticate them afterwards; failing the handshake if they can’t be authenticated</li><li>save them and use them when they can be properly authenticated</li><li>treat them as a fatal error</li></ul></div><div id="rfc.section.5.p.6"><p>Different strategies are appropriate for different types of data. This document proposes that all strategies are possible depending on the type of message.</p></div><div id="rfc.section.5.p.7"><ul><li>Transport parameters and options are made usable and authenticated as part of the TLS handshake (see <a href="#quic_parameters" title="QUIC Extension">Section 6.2</a>).</li><li>Most unprotected messages are treated as fatal errors when received except for the small number necessary to permit the handshake to complete (see <a href="#pre-handshake-unprotected" title="Unprotected Frames Prior to Handshake Completion">Section 5.1</a>).</li><li>Protected packets can either be discarded or saved and later used (see <a href="#pre-handshake-protected" title="Protected Frames Prior to Handshake Completion">Section 5.3</a>).</li></ul></div><section id="pre-handshake-unprotected"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a> <a href="#pre-handshake-unprotected">Unprotected Frames Prior to Handshake Completion</a></h3><div id="rfc.section.5.1.p.1"><p>This section describes the handling of messages that are sent and received prior to the completion of the TLS handshake.</p></div><div id="rfc.section.5.1.p.2"><p>Sending and receiving unprotected messages is hazardous. Unless expressly permitted, receipt of an unprotected message of any kind MUST be treated as a fatal error.</p></div><section id="stream-frames"><h4 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1</a> <a href="#stream-frames">STREAM Frames</a></h4><div id="rfc.section.5.1.1.p.1"><p><span class="tt">STREAM</span> frames for stream 1 are permitted. These carry the TLS handshake messages.</p></div><div id="rfc.section.5.1.1.p.2"><p>Receiving unprotected <span class="tt">STREAM</span> frames for other streams MUST be treated as a fatal error.</p></div></section><section id="ack-frames"><h4 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2</a> <a href="#ack-frames">ACK Frames</a></h4><div id="rfc.section.5.1.2.p.1"><p><span class="tt">ACK</span> frames are permitted prior to the handshake being complete. Information learned from <span class="tt">ACK</span> frames cannot be entirely relied upon, since an attacker is able to inject these packets. Timing and packet retransmission information from <span class="tt">ACK</span> frames is critical to the functioning of the protocol, but these frames might be spoofed or altered.</p></div><div id="rfc.section.5.1.2.p.2"><p>Endpoints MUST NOT use an unprotected <span class="tt">ACK</span> frame to acknowledge data that was protected by 0-RTT or 1-RTT keys. An endpoint MUST ignore an unprotected <span class="tt">ACK</span> frame if it claims to acknowledge data that was protected data. Such an acknowledgement can only serve as a denial of service, since an endpoint that can read protected data is always permitted to send protected data.</p></div><div id="rfc.section.5.1.2.p.3"><p>An endpoint SHOULD use data from unprotected or 0-RTT-protected <span class="tt">ACK</span> frames only during the initial handshake and while they have insufficient information from 1-RTT-protected <span class="tt">ACK</span> frames. Once sufficient information has been obtained from protected messages, information obtained from less reliable sources can be discarded.</p></div></section><section id="windowupdate-frames"><h4 id="rfc.section.5.1.3"><a href="#rfc.section.5.1.3">5.1.3</a> <a href="#windowupdate-frames">WINDOW_UPDATE Frames</a></h4><div id="rfc.section.5.1.3.p.1"><p><span class="tt">WINDOW_UPDATE</span> frames MUST NOT be sent unprotected.</p></div><div id="rfc.section.5.1.3.p.2"><p>Though data is exchanged on stream 1, the initial flow control window is is sufficiently large to allow the TLS handshake to complete. This limits the maximum size of the TLS handshake and would prevent a server or client from using an abnormally large certificate chain.</p></div><div id="rfc.section.5.1.3.p.3"><p>Stream 1 is exempt from the connection-level flow control window.</p></div></section><section id="denial-of-service-with-unprotected-packets"><h4 id="rfc.section.5.1.4"><a href="#rfc.section.5.1.4">5.1.4</a> <a href="#denial-of-service-with-unprotected-packets">Denial of Service with Unprotected Packets</a></h4><div id="rfc.section.5.1.4.p.1"><p>Accepting unprotected - specifically unauthenticated - packets presents a denial of service risk to endpoints. An attacker that is able to inject unprotected packets can cause a recipient to drop even protected packets with a matching sequence number. The spurious packet shadows the genuine packet, causing the genuine packet to be ignored as redundant.</p></div><div id="rfc.section.5.1.4.p.2"><p>Once the TLS handshake is complete, both peers MUST ignore unprotected packets. The handshake is complete when the server receives a client’s Finished message and when a client receives an acknowledgement that their Finished message was received. From that point onward, unprotected messages can be safely dropped. Note that the client could retransmit its Finished message to the server, so the server cannot reject such a message.</p></div><div id="rfc.section.5.1.4.p.3"><p>Since only TLS handshake packets and acknowledgments are sent in the clear, an attacker is able to force implementations to rely on retransmission for packets that are lost or shadowed. Thus, an attacker that intends to deny service to an endpoint has to drop or shadow protected packets in order to ensure that their victim continues to accept unprotected packets. The ability to shadow packets means that an attacker does not need to be on path.</p></div><div id="rfc.section.5.1.4.p.4"><dl><dt>ISSUE:</dt><dd>This would not be an issue if QUIC had a randomized starting sequence number. If we choose to randomize, we fix this problem and reduce the denial of service exposure to on-path attackers. The only possible problem is in authenticating the initial value, so that peers can be sure that they haven’t missed an initial message.</dd></dl></div><div id="rfc.section.5.1.4.p.5"><p>In addition to denying endpoints messages, an attacker to generate packets that cause no state change in a recipient. See <a href="#useless" title="Peer Denial of Service">Section 7.2</a> for a discussion of these risks.</p></div><div id="rfc.section.5.1.4.p.6"><p>To avoid receiving TLS packets that contain no useful data, a TLS implementation MUST reject empty TLS handshake records and any record that is not permitted by the TLS state machine. Any TLS application data or alerts - other than a single end_of_early_data at the appropriate time - that is received prior to the end of the handshake MUST be treated as a fatal error.</p></div></section></section><section id="using-early-data"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a> <a href="#using-early-data">Use of 0-RTT Keys</a></h3><div id="rfc.section.5.2.p.1"><p>If 0-RTT keys are available, the lack of replay protection means that restrictions on their use are necessary to avoid replay attacks on the protocol.</p></div><div id="rfc.section.5.2.p.2"><p>A client MUST only use 0-RTT keys to protect data that is idempotent. A client MAY wish to apply additional restrictions on what data it sends prior to the completion of the TLS handshake. A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys.</p></div><div id="rfc.section.5.2.p.3"><p>A client that receives an indication that its 0-RTT data has been accepted by a server can send 0-RTT data until it receives all of the server’s handshake messages. A client SHOULD stop sending 0-RTT data if it receives an indication that 0-RTT data has been rejected. In addition to a ServerHello without an early_data extension, an unprotected handshake message with a KEY_PHASE bit set to 0 indicates that 0-RTT data has been rejected.</p></div><div id="rfc.section.5.2.p.4"><p>A client SHOULD send its end_of_early_data alert only after it has received all of the server’s handshake messages. Alternatively phrased, a client is encouraged to use 0-RTT keys until 1-RTT keys become available. This prevents stalling of the connection and allows the client to send continuously.</p></div><div id="rfc.section.5.2.p.5"><p>A server MUST NOT use 0-RTT keys to protect anything other than TLS handshake messages. Servers therefore treat packets protected with 0-RTT keys as equivalent to unprotected packets in determining what is permissible to send. A server protects handshake messages using the 0-RTT key if it decides to accept a 0-RTT key. A server MUST still include the early_data extension in its ServerHello message.</p></div><div id="rfc.section.5.2.p.6"><p>This restriction prevents a server from responding to a request using frames protected by the 0-RTT keys. This ensures that all application data from the server are always protected with keys that have forward secrecy. However, this results in head-of-line blocking at the client because server responses cannot be decrypted until all the server’s handshake messages are received by the client.</p></div></section><section id="pre-handshake-protected"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a> <a href="#pre-handshake-protected">Protected Frames Prior to Handshake Completion</a></h3><div id="rfc.section.5.3.p.1"><p>Due to reordering and loss, protected packets might be received by an endpoint before the final handshake messages are received. If these can be decrypted successfully, such packets MAY be stored and used once the handshake is complete.</p></div><div id="rfc.section.5.3.p.2"><p>Unless expressly permitted below, encrypted packets MUST NOT be used prior to completing the TLS handshake, in particular the receipt of a valid Finished message and any authentication of the peer. If packets are processed prior to completion of the handshake, an attacker might use the willingness of an implementation to use these packets to mount attacks.</p></div><div id="rfc.section.5.3.p.3"><p>TLS handshake messages are covered by record protection during the handshake, once key agreement has completed. This means that protected messages need to be decrypted to determine if they are TLS handshake messages or not. Similarly, <span class="tt">ACK</span> and <span class="tt">WINDOW_UPDATE</span> frames might be needed to successfully complete the TLS handshake.</p></div><div id="rfc.section.5.3.p.4"><p>Any timestamps present in <span class="tt">ACK</span> frames MUST be ignored rather than causing a fatal error. Timestamps on protected frames MAY be saved and used once the TLS handshake completes successfully.</p></div><div id="rfc.section.5.3.p.5"><p>An endpoint MAY save the last protected <span class="tt">WINDOW_UPDATE</span> frame it receives for each stream and apply the values once the TLS handshake completes. Failing to do this might result in temporary stalling of affected streams.</p></div></section></section><hr class="noprint"><section id="quic-specific-additions-to-the-tls-handshake"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a> <a href="#quic-specific-additions-to-the-tls-handshake">QUIC-Specific Additions to the TLS Handshake</a></h2><div id="rfc.section.6.p.1"><p>QUIC uses the TLS handshake for more than just negotiation of cryptographic parameters. The TLS handshake validates protocol version selection, provides preliminary values for QUIC transport parameters, and allows a server to perform return routeability checks on clients.</p></div><section id="version-negotiation"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a> <a href="#version-negotiation">Protocol and Version Negotiation</a></h3><div id="rfc.section.6.1.p.1"><p>The QUIC version negotiation mechanism is used to negotiate the version of QUIC that is used prior to the completion of the handshake. However, this packet is not authenticated, enabling an active attacker to force a version downgrade.</p></div><div id="rfc.section.6.1.p.2"><p>To ensure that a QUIC version downgrade is not forced by an attacker, version information is copied into the TLS handshake, which provides integrity protection for the QUIC negotiation. This does not prevent version downgrade during the handshake, though it means that such a downgrade causes a handshake failure.</p></div><div id="rfc.section.6.1.p.3"><p>Protocols that use the QUIC transport MUST use Application Layer Protocol Negotiation (ALPN) <a href="#RFC7301"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[RFC7301]</cite></a>. The ALPN identifier for the protocol MUST be specific to the QUIC version that it operates over. When constructing a ClientHello, clients MUST include a list of all the ALPN identifiers that they support, regardless of whether the QUIC version that they have currently selected supports that protocol.</p></div><div id="rfc.section.6.1.p.4"><p>Servers SHOULD select an application protocol based solely on the information in the ClientHello, not using the QUIC version that the client has selected. If the protocol that is selected is not supported with the QUIC version that is in use, the server MAY send a QUIC version negotiation packet to select a compatible version.</p></div><div id="rfc.section.6.1.p.5"><p>If the server cannot select a combination of ALPN identifier and QUIC version it MUST abort the connection. A client MUST abort a connection if the server picks an incompatible version of QUIC version and ALPN.</p></div></section><section id="quic_parameters"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a> <a href="#quic_parameters">QUIC Extension</a></h3><div id="rfc.section.6.2.p.1"><p>QUIC defines an extension for use with TLS. That extension defines transport-related parameters. This provides integrity protection for these values. Including these in the TLS handshake also make the values that a client sets available to a server one-round trip earlier than parameters that are carried in QUIC frames. This document does not define that extension.</p></div></section><section id="source-address"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a> <a href="#source-address">Source Address Validation</a></h3><div id="rfc.section.6.3.p.1"><p>QUIC implementations describe a source address token. This is an opaque blob that a server might provide to clients when they first use a given source address. The client returns this token in subsequent messages as a return routeability check. That is, the client returns this token to prove that it is able to receive packets at the source address that it claims. This prevents the server from being used in packet reflection attacks (see <a href="#reflection" title="Packet Reflection Attack Mitigation">Section 7.1</a>).</p></div><div id="rfc.section.6.3.p.2"><p>A source address token is opaque and consumed only by the server. Therefore it can be included in the TLS 1.3 pre-shared key identifier for 0-RTT handshakes. Servers that use 0-RTT are advised to provide new pre-shared key identifiers after every handshake to avoid linkability of connections by passive observers. Clients MUST use a new pre-shared key identifier for every connection that they initiate; if no pre-shared key identifier is available, then resumption is not possible.</p></div><div id="rfc.section.6.3.p.3"><p>A server that is under load might include a source address token in the cookie extension of a HelloRetryRequest.</p></div></section><section id="priming-0-rtt"><h3 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4</a> <a href="#priming-0-rtt">Priming 0-RTT</a></h3><div id="rfc.section.6.4.p.1"><p>QUIC uses TLS without modification. Therefore, it is possible to use a pre-shared key that was obtained in a TLS connection over TCP to enable 0-RTT in QUIC. Similarly, QUIC can provide a pre-shared key that can be used to enable 0-RTT in TCP.</p></div><div id="rfc.section.6.4.p.2"><p>All the restrictions on the use of 0-RTT apply, with the exception of the ALPN label, which MUST only change to a label that is explicitly designated as being compatible. The client indicates which ALPN label it has chosen by placing that ALPN label first in the ALPN extension.</p></div><div id="rfc.section.6.4.p.3"><p>The certificate that the server uses MUST be considered valid for both connections, which will use different protocol stacks and could use different port numbers. For instance, HTTP/1.1 and HTTP/2 operate over TLS and TCP, whereas QUIC operates over UDP.</p></div><div id="rfc.section.6.4.p.4"><p>Source address validation is not completely portable between different protocol stacks. Even if the source IP address remains constant, the port number is likely to be different. Packet reflection attacks are still possible in this situation, though the set of hosts that can initiate these attacks is greatly reduced. A server might choose to avoid source address validation for such a connection, or allow an increase to the amount of data that it sends toward the client without source validation.</p></div></section></section><hr class="noprint"><section id="security-considerations"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.7.p.1"><p>There are likely to be some real clangers here eventually, but the current set of issues is well captured in the relevant sections of the main text.</p></div><div id="rfc.section.7.p.2"><p>Never assume that because it isn’t in the security considerations section it doesn’t affect security. Most of this document does.</p></div><section id="reflection"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1</a> <a href="#reflection">Packet Reflection Attack Mitigation</a></h3><div id="rfc.section.7.1.p.1"><p>A small ClientHello that results in a large block of handshake messages from a server can be used in packet reflection attacks to amplify the traffic generated by an attacker.</p></div><div id="rfc.section.7.1.p.2"><p>Certificate caching <a href="#RFC7924"><cite title="Transport Layer Security (TLS) Cached Information Extension">[RFC7924]</cite></a> can reduce the size of the server’s handshake messages significantly.</p></div><div id="rfc.section.7.1.p.3"><p>A client SHOULD also pad <a href="#RFC7685"><cite title="A Transport Layer Security (TLS) ClientHello Padding Extension">[RFC7685]</cite></a> its ClientHello to at least 1024 octets. A server is less likely to generate a packet reflection attack if the data it sends is a small multiple of the data it receives. A server SHOULD use a HelloRetryRequest if the size of the handshake messages it sends is likely to exceed the size of the ClientHello.</p></div></section><section id="useless"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2</a> <a href="#useless">Peer Denial of Service</a></h3><div id="rfc.section.7.2.p.1"><p>QUIC, TLS and HTTP/2 all contain a messages that have legitimate uses in some contexts, but that can be abused to cause a peer to expend processing resources without having any observable impact on the state of the connection. If processing is disproportionately large in comparison to the observable effects on bandwidth or state, then this could allow a malicious peer to exhaust processing capacity without consequence.</p></div><div id="rfc.section.7.2.p.2"><p>QUIC prohibits the sending of empty <span class="tt">STREAM</span> frames unless they are marked with the FIN bit. This prevents <span class="tt">STREAM</span> frames from being sent that only waste effort.</p></div><div id="rfc.section.7.2.p.3"><p>TLS records SHOULD always contain at least one octet of a handshake messages or alert. Records containing only padding are permitted during the handshake, but an excessive number might be used to generate unnecessary work. Once the TLS handshake is complete, endpoints SHOULD NOT send TLS application data records unless it is to hide the length of QUIC records. QUIC packet protection does not include any allowance for padding; padded TLS application data records can be used to mask the length of QUIC frames.</p></div><div id="rfc.section.7.2.p.4"><p>While there are legitimate uses for some redundant packets, implementations SHOULD track redundant packets and treat excessive volumes of any non-productive packets as indicative of an attack.</p></div></section></section><hr class="noprint"><section id="iana-considerations"><h2 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.8.p.1"><p>This document has no IANA actions. Yet.</p></div></section><hr class="noprint"><section id="rfc.references" class="np"><h2 id="rfc.section.9"><a href="#rfc.section.9">9.</a> References</h2><section id="rfc.references.1" class="np"><h3 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1</a> Normative References</h3><dl class="reference"><dt id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-18">The Transport Layer Security (TLS) Protocol Version 1.3</a>”, Internet-Draft draft-ietf-tls-tls13-18 (work in progress), October 2016.</dd><dt id="QUIC-RECOVERY">[QUIC-RECOVERY]</dt><dd>Iyengar, J., Ed. and I. Swett, Ed., “QUIC Loss Detection and Congestion Control”, November 2016.</dd><dt id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</dt><dd>Iyengar, J., Ed. and M. Thomson, Ed., “QUIC: A UDP-Based Multiplexed and Secure Transport”, November 2016.</dd><dt id="RFC2104">[RFC2104]</dt><dd>Krawczyk, H., Bellare, M., and R. Canetti, “<a href="https://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>”, RFC 2104, <a href="http://dx.doi.org/10.17487/RFC2104">DOI 10.17487/RFC2104</a>, February 1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2104">http://www.rfc-editor.org/info/rfc2104</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC5116">[RFC5116]</dt><dd>McGrew, D., “<a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>”, RFC 5116, <a href="http://dx.doi.org/10.17487/RFC5116">DOI 10.17487/RFC5116</a>, January 2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5116">http://www.rfc-editor.org/info/rfc5116</a>&gt;.</dd><dt id="RFC5869">[RFC5869]</dt><dd>Krawczyk, H. and P. Eronen, “<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>”, RFC 5869, <a href="http://dx.doi.org/10.17487/RFC5869">DOI 10.17487/RFC5869</a>, May 2010, &lt;<a href="http://www.rfc-editor.org/info/rfc5869">http://www.rfc-editor.org/info/rfc5869</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7301">[RFC7301]</dt><dd>Friedl, S., Popov, A., Langley, A., and E. Stephan, “<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>”, RFC 7301, <a href="http://dx.doi.org/10.17487/RFC7301">DOI 10.17487/RFC7301</a>, July 2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7301">http://www.rfc-editor.org/info/rfc7301</a>&gt;.</dd><dt id="RFC7685">[RFC7685]</dt><dd>Langley, A., “<a href="https://tools.ietf.org/html/rfc7685">A Transport Layer Security (TLS) ClientHello Padding Extension</a>”, RFC 7685, <a href="http://dx.doi.org/10.17487/RFC7685">DOI 10.17487/RFC7685</a>, October 2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7685">http://www.rfc-editor.org/info/rfc7685</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2</a> Informative References</h3><dl class="reference"><dt id="AEBounds">[AEBounds]</dt><dd>Luykx, A. and K. Paterson, “<a href="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">Limits on Authenticated Encryption Use in TLS</a>”, March 2016, &lt;<a href="http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf</a>&gt;.</dd><dt id="QUIC-HTTP">[QUIC-HTTP]</dt><dd>Bishop, M., Ed., “HTTP/2 Semantics Using The QUIC Transport Protocol”, November 2016.</dd><dt id="RFC0793">[RFC0793]</dt><dd>Postel, J., “<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>”, STD 7, RFC 793, <a href="http://dx.doi.org/10.17487/RFC0793">DOI 10.17487/RFC0793</a>, September 1981, &lt;<a href="http://www.rfc-editor.org/info/rfc793">http://www.rfc-editor.org/info/rfc793</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC7924">[RFC7924]</dt><dd>Santesson, S. and H. Tschofenig, “<a href="https://tools.ietf.org/html/rfc7924">Transport Layer Security (TLS) Cached Information Extension</a>”, RFC 7924, <a href="http://dx.doi.org/10.17487/RFC7924">DOI 10.17487/RFC7924</a>, July 2016, &lt;<a href="http://www.rfc-editor.org/info/rfc7924">http://www.rfc-editor.org/info/rfc7924</a>&gt;.</dd></dl></section></section><hr class="noprint"><section id="contributors"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a> <a href="#contributors">Contributors</a></h2><div id="rfc.section.A.p.1"><p>Ryan Hamilton was originally an author of this specification.</p></div></section><hr class="noprint"><section id="acknowledgments"><h2 id="rfc.section.B" class="np"><a href="#rfc.section.B">B.</a> <a href="#acknowledgments">Acknowledgments</a></h2><div id="rfc.section.B.p.1"><p>This document has benefited from input from Christian Huitema, Jana Iyengar, Adam Langley, Roberto Peon, Eric Rescorla, Ian Swett, and many others.</p></div></section><hr class="noprint"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Martin Thomson</b><br>Mozilla<br>EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></address><address><b>Sean Turner</b>
      (editor)
  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/{SLUG}">Fork me on GitHub</a></div></div>
    <br>sn3rd</address></section></body></html>
