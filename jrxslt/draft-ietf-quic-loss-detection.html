<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>QUIC Loss Detection and Congestion Control</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Design of the QUIC Transmission Machinery" href="#rfc.section.2"><link rel="Chapter" title="3 Loss Detection" href="#rfc.section.3"><link rel="Chapter" title="4 Congestion Control" href="#rfc.section.4"><link rel="Chapter" title="5 TCP mechanisms in QUIC" href="#rfc.section.5"><link rel="Chapter" title="6 IANA Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 Normative References"><link rel="Appendix" title="A Acknowledgments" href="#rfc.section.A"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.840, 2016/11/16 05:32:10, XSLT vendor: libxslt http://xmlsoft.org/XSLT/"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Iyengar, J."><meta name="dcterms.creator" content="Swett, I."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-quic-loss-detection"><meta name="dcterms.issued" content="2016-11-28"><meta name="dcterms.abstract" content="QUIC is a new multiplexed and secure transport atop UDP. QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport. QUIC implements the spirit of known TCP loss detection mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation. This document describes QUIC loss detection and congestion control, and attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and TCP implementations."><meta name="description" content="QUIC is a new multiplexed and secure transport atop UDP. QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport. QUIC implements the spirit of known TCP loss detection mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation. This document describes QUIC loss detection and congestion control, and attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and TCP implementations."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">QUIC Working Group</td><td class="right">J. Iyengar, Editor</td></tr><tr><td class="left">Internet-Draft</td><td class="right">I. Swett, Editor</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">Google</td></tr><tr><td class="left">Expires: June 1, 2017</td><td class="right">November 28, 2016</td></tr></tbody></table><div id="rfc.title"><h1>QUIC Loss Detection and Congestion Control</h1><div class="filename">draft-ietf-quic-loss-detection</div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><p>QUIC is a new multiplexed and secure transport atop UDP. QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport. QUIC implements the spirit of known TCP loss detection mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation. This document describes QUIC loss detection and congestion control, and attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and TCP implementations.</p></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on June 1, 2017.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2016 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#design-of-the-quic-transmission-machinery">Design of the QUIC Transmission Machinery</a><ul><li><a href="#rfc.section.2.1">2.1</a>   <a href="#relevant-differences-between-quic-and-tcp">Relevant Differences Between QUIC and TCP</a><ul><li><a href="#rfc.section.2.1.1">2.1.1</a>   <a href="#monotonically-increasing-packet-numbers">Monotonically Increasing Packet Numbers</a></li><li><a href="#rfc.section.2.1.2">2.1.2</a>   <a href="#no-reneging">No Reneging</a></li><li><a href="#rfc.section.2.1.3">2.1.3</a>   <a href="#more-ack-ranges">More ACK Ranges</a></li><li><a href="#rfc.section.2.1.4">2.1.4</a>   <a href="#explicit-correction-for-delayed-acks">Explicit Correction For Delayed Acks</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>   <a href="#loss-detection">Loss Detection</a><ul><li><a href="#rfc.section.3.1">3.1</a>   <a href="#variables-of-interest">Variables of interest</a></li><li><a href="#rfc.section.3.2">3.2</a>   <a href="#initialization">Initialization</a></li><li><a href="#rfc.section.3.3">3.3</a>   <a href="#setting-the-loss-detection-alarm">Setting the Loss Detection Alarm</a></li><li><a href="#rfc.section.3.4">3.4</a>   <a href="#on-sending-a-packet">On Sending a Packet</a></li><li><a href="#rfc.section.3.5">3.5</a>   <a href="#on-packet-acknowledgment">On Packet Acknowledgment</a></li><li><a href="#rfc.section.3.6">3.6</a>   <a href="#on-alarm-firing">On Alarm Firing</a></li><li><a href="#rfc.section.3.7">3.7</a>   <a href="#detecting-lost-packets">Detecting Lost Packets</a></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#congestion-control">Congestion Control</a></li><li><a href="#rfc.section.5">5.</a>   <a href="#tcp-mechanisms-in-quic">TCP mechanisms in QUIC</a><ul><li><a href="#rfc.section.5.1">5.1</a>   <a href="#rfc-6298-rto-computation">RFC 6298 (RTO computation)</a></li><li><a href="#rfc.section.5.2">5.2</a>   <a href="#fack-loss-recovery-paper">FACK Loss Recovery (paper)</a></li><li><a href="#rfc.section.5.3">5.3</a>   <a href="#rfc-3782-rfc-6582-newreno-fast-recovery">RFC 3782, RFC 6582 (NewReno Fast Recovery)</a></li><li><a href="#rfc.section.5.4">5.4</a>   <a href="#tlp-draft">TLP (draft)</a></li><li><a href="#rfc.section.5.5">5.5</a>   <a href="#rfc-5827-early-retransmit-with-delay-timer">RFC 5827 (Early Retransmit) with Delay Timer</a></li><li><a href="#rfc.section.5.6">5.6</a>   <a href="#rfc-5827-f-rto">RFC 5827 (F-RTO)</a></li><li><a href="#rfc.section.5.7">5.7</a>   <a href="#rfc-6937-proportional-rate-reduction">RFC 6937 (Proportional Rate Reduction)</a></li><li><a href="#rfc.section.5.8">5.8</a>   <a href="#tcp-cubic-draft-with-optional-rfc-5681-reno">TCP Cubic (draft) with optional RFC 5681 (Reno)</a></li><li><a href="#rfc.section.5.9">5.9</a>   <a href="#hybrid-slow-start-paper">Hybrid Slow Start (paper)</a></li><li><a href="#rfc.section.5.10">5.10</a>   <a href="#rack-draft">RACK (draft)</a></li></ul></li><li><a href="#rfc.section.6">6.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.7">7.</a>   <a href="#rfc.references">Normative References</a></li><li><a href="#rfc.section.A">A.</a>   <a href="#acknowledgments">Acknowledgments</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><hr class="noprint"><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>QUIC is a new multiplexed and secure transport atop UDP. QUIC builds on decades of transport and security experience, and implements mechanisms that make it attractive as a modern general-purpose transport. The QUIC protocol is described in <a href="#QUIC-TRANSPORT"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC-TRANSPORT]</cite></a>.</p></div><div id="rfc.section.1.p.2"><p>QUIC implements the spirit of known TCP loss recovery mechanisms, described in RFCs, various Internet-drafts, and also those prevalent in the Linux TCP implementation. This document describes QUIC congestion control and loss recovery, and where applicable, attributes the TCP equivalent in RFCs, Internet-drafts, academic papers, and/or TCP implementations.</p></div><div id="rfc.section.1.p.3"><p>This document first describes pre-requisite parts of the QUIC transmission machinery, then discusses QUIC’s default congestion control and loss detection mechanisms, and finally lists the various TCP mechanisms that QUIC loss detection implements (in spirit.)</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The words “MUST”, “MUST NOT”, “SHOULD”, and “MAY” are used in this document. It’s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div></section></section><hr class="noprint"><section id="design-of-the-quic-transmission-machinery"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a> <a href="#design-of-the-quic-transmission-machinery">Design of the QUIC Transmission Machinery</a></h2><div id="rfc.section.2.p.1"><p>All transmissions in QUIC are sent with a packet-level header, which includes a packet sequence number (referred to below as a packet number). These packet numbers never repeat in the lifetime of a connection, and are monotonically increasing, which makes duplicate detection trivial. This fundamental design decision obviates the need for disambiguating between transmissions and retransmissions and eliminates significant complexity from QUIC’s interpretation of TCP loss detection mechanisms.</p></div><div id="rfc.section.2.p.2"><p>Every packet may contain several frames. We outline the frames that are important to the loss detection and congestion control machinery below.</p></div><div id="rfc.section.2.p.3"><ul><li>Retransmittable frames are frames requiring reliable delivery. The most common are STREAM frames, which typically contain application data.</li><li>Crypto handshake data is also sent as STREAM data, and uses the reliability machinery of QUIC underneath.</li><li>ACK frames contain acknowledgment information. QUIC uses a SACK- based scheme, where acks express up to 256 ranges. The ACK frame also includes a receive timestamp for each packet newly acked.</li></ul></div><section id="relevant-differences-between-quic-and-tcp"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a> <a href="#relevant-differences-between-quic-and-tcp">Relevant Differences Between QUIC and TCP</a></h3><div id="rfc.section.2.1.p.1"><p>There are some notable differences between QUIC and TCP which are important for reasoning about the differences between the loss recovery mechanisms employed by the two protocols. We briefly describe these differences below.</p></div><section id="monotonically-increasing-packet-numbers"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1</a> <a href="#monotonically-increasing-packet-numbers">Monotonically Increasing Packet Numbers</a></h4><div id="rfc.section.2.1.1.p.1"><p>TCP conflates transmission sequence number at the sender with delivery sequence number at the receiver, which results in retransmissions of the same data carrying the same sequence number, and consequently to problems caused by “retransmission ambiguity”. QUIC separates the two: QUIC uses a packet sequence number (referred to as the “packet number”) for transmissions, and any data that is to be delivered to the receiving application(s) is sent in one or more streams, with stream offsets encoded within STREAM frames inside of packets that determine delivery order.</p></div><div id="rfc.section.2.1.1.p.2"><p>QUIC’s packet number is strictly increasing, and directly encodes transmission order. A higher QUIC packet number signifies that the packet was sent later, and a lower QUIC packet number signifies that the packet was sent earlier. When a packet containing frames is deemed lost, QUIC rebundles necessary frames in a new packet with a new packet number, removing ambiguity about which packet is acknowledged when an ACK is received. Consequently, more accurate RTT measurements can be made, spurious retransmissions are trivially detected, and mechanisms such as Fast Retransmit can be applied universally, based only on packet number.</p></div><div id="rfc.section.2.1.1.p.3"><p>This design point significantly simplifies loss detection mechanisms for QUIC. Most TCP mechanisms implicitly attempt to infer transmission ordering based on TCP sequence numbers - a non-trivial task, especially when TCP timestamps are not available.</p></div></section><section id="no-reneging"><h4 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2</a> <a href="#no-reneging">No Reneging</a></h4><div id="rfc.section.2.1.2.p.1"><p>QUIC ACKs contain information that is equivalent to TCP SACK, but QUIC does not allow any acked packet to be reneged, greatly simplifying implementations on both sides and reducing memory pressure on the sender.</p></div></section><section id="more-ack-ranges"><h4 id="rfc.section.2.1.3"><a href="#rfc.section.2.1.3">2.1.3</a> <a href="#more-ack-ranges">More ACK Ranges</a></h4><div id="rfc.section.2.1.3.p.1"><p>QUIC supports up to 256 ACK ranges, opposed to TCP’s 3 SACK ranges. In high loss environments, this speeds recovery.</p></div></section><section id="explicit-correction-for-delayed-acks"><h4 id="rfc.section.2.1.4"><a href="#rfc.section.2.1.4">2.1.4</a> <a href="#explicit-correction-for-delayed-acks">Explicit Correction For Delayed Acks</a></h4><div id="rfc.section.2.1.4.p.1"><p>QUIC ACKs explicitly encode the delay incurred at the receiver between when a packet is received and when the corresponding ACK is sent. This allows the receiver of the ACK to adjust for receiver delays, specifically the delayed ack timer, when estimating the path RTT. This mechanism also allows a receiver to measure and report the delay from when a packet was received by the OS kernel, which is useful in receivers which may incur delays such as context-switch latency before a userspace QUIC receiver processes a received packet.</p></div></section></section></section><hr class="noprint"><section id="loss-detection"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a> <a href="#loss-detection">Loss Detection</a></h2><div id="rfc.section.3.p.1"><p>We now describe QUIC’s loss detection as functions that should be called on packet transmission, when a packet is acked, and timer expiration events.</p></div><section id="variables-of-interest"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a> <a href="#variables-of-interest">Variables of interest</a></h3><div id="rfc.section.3.1.p.1"><p>We first describe the variables required to implement the loss detection mechanisms described in this section.</p></div><div id="rfc.section.3.1.p.2"><ul><li>loss_detection_alarm: Multi-modal alarm used for loss detection.</li><li>alarm_mode: QUIC maintains a single loss detection alarm, which switches between various modes. This mode is used to determine the duration of the alarm.</li><li>handshake_count: The number of times the handshake packets have been retransmitted without receiving an ack.</li><li>tlp_count: The number of times a tail loss probe has been sent without receiving an ack.</li><li>rto_count: The number of times an rto has been sent without receiving an ack.</li><li>smoothed_rtt: The smoothed RTT of the connection, computed as described in <a href="#RFC6298"><cite title="Computing TCP's Retransmission Timer">[RFC6298]</cite></a>. TODO: Describe RTT computations.</li><li>reordering_threshold: The largest delta between the largest acked retransmittable packet and a packet containing retransmittable frames before it’s declared lost.</li><li>time_loss: When true, loss detection operates solely based on reordering threshold in time, rather than in packet number gaps.</li></ul></div></section><section id="initialization"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a> <a href="#initialization">Initialization</a></h3><div id="rfc.section.3.2.p.1" class="avoidbreakafter"><p>At the beginning of the connection, initialize the loss detection variables as follows:</p></div><div id="rfc.figure.u.1"><pre>
   loss_detection_alarm.reset();
   handshake_count = 0;
   tlp_count = 0;
   rto_count = 0;
   smoothed_rtt = 0;
   reordering_threshold = 3;
   time_loss = false;
</pre></div></section><section id="setting-the-loss-detection-alarm"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a> <a href="#setting-the-loss-detection-alarm">Setting the Loss Detection Alarm</a></h3><div id="rfc.section.3.3.p.1"><p>QUIC loss detection uses a single alarm for all timer-based loss detection. The duration of the alarm is based on the alarm’s mode, which is set in the packet and timer events further below. The function SetLossDetectionAlarm defined below shows how the single timer is set based on the alarm mode.</p></div><div id="rfc.section.3.3.p.2" class="avoidbreakafter"><p>Pseudocode for SetLossDetectionAlarm follows:</p></div><div id="rfc.figure.u.2"><pre>
 SetLossDetectionAlarm():
    if (retransmittable packets are not outstanding):
      loss_detection_alarm.cancel();
      return;
    if (handshake packets are outstanding):
      alarm_duration = max(1.5 * smoothed_rtt, 10ms) &lt;&lt; handshake_count;
      handshake_count++;
    else if (largest sent packet is acked):
      // Set alarm based on short timer for early retransmit.
      alarm_duration = 0.25 x smoothed_rtt;
    else if (tlp_count &lt; 2):
      if (retransmittable_packets_outstanding = 1):
        alarm_duration = max(1.5 x smoothed_rtt + delayed_ack_timer,
                             2 x smoothed_rtt);
      else:
        alarm_duration = max (10ms, 2 x smoothed_rtt);
      tlp_count++;
    else:
      if (rto_count = 0):
        alarm_duration = max(200ms, smoothed_rtt + 4 x rttvar);
      else:
        alarm_duration = loss_detection_alarm.get_delay() &lt;&lt; 1;
      rto_count++;

    loss_detection_alarm.set(now + alarm_duration);
</pre></div></section><section id="on-sending-a-packet"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a> <a href="#on-sending-a-packet">On Sending a Packet</a></h3><div id="rfc.section.3.4.p.1" class="avoidbreakafter"><p>After any packet is sent, be it a new transmission or a rebundled transmission, the following OnPacketSent function is called. The parameters to OnPacketSent are as follows:</p></div><div id="rfc.section.3.4.p.2"><ul><li>packet_number: The packet number of the sent packet.</li><li>is_retransmittble: A boolean that indicates whether the packet contains at least one frame requiring reliable deliver. The retransmittability of various QUIC frames is described in <a href="#QUIC-TRANSPORT"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[QUIC-TRANSPORT]</cite></a>. If false, it is still acceptable for an ack to be received for this packet. However, a caller MUST NOT set is_retransmittable to true if an ack is not expected.</li></ul></div><div id="rfc.section.3.4.p.3" class="avoidbreakafter"><p>Pseudocode for OnPacketSent follows:</p></div><div id="rfc.figure.u.3"><pre>
 OnPacketSent(packet_number, is_retransmittable):
     if is_retransmittable:
       SetLossDetectionAlarm()
</pre></div></section><section id="on-packet-acknowledgment"><h3 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a> <a href="#on-packet-acknowledgment">On Packet Acknowledgment</a></h3><div id="rfc.section.3.5.p.1"><p>When a packet is acked for the first time, the following OnPacketAcked function is called. Note that a single ACK frame may newly acknowledge several packets. OnPacketAcked must be called once for each of these newly acked packets.</p></div><div id="rfc.section.3.5.p.2"><p>OnPacketAcked takes one parameter, acked_packet, which is the packet number of the newly acked packet, and returns a list of packet numbers that are detected as lost.</p></div><div id="rfc.section.3.5.p.3" class="avoidbreakafter"><p>Pseudocode for OnPacketAcked follows:</p></div><div id="rfc.figure.u.4"><pre>
   OnPacketAcked(acked_packet):
     handshake_count = 0;
     tlp_count = 0;
     rto_count = 0;
     UpdateRtt(); // TODO: document RTT estimator.
     DetectLostPackets(acked_packet);
     SetLossDetectionAlarm();
</pre></div></section><section id="on-alarm-firing"><h3 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a> <a href="#on-alarm-firing">On Alarm Firing</a></h3><div id="rfc.section.3.6.p.1"><p>QUIC uses one loss recovery alarm, which when set, can be in one of several modes. When the alarm fires, the mode determines the action to be performed. OnAlarm returns a list of packet numbers that are detected as lost.</p></div><div id="rfc.section.3.6.p.2" class="avoidbreakafter"><p>Pseudocode for OnAlarm follows:</p></div><div id="rfc.figure.u.5"><pre>
   OnAlarm(acked_packet):
     lost_packets = DetectLostPackets(acked_packet);
     MaybeRetransmitLostPackets();
     SetLossDetectionAlarm();
</pre></div></section><section id="detecting-lost-packets"><h3 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7</a> <a href="#detecting-lost-packets">Detecting Lost Packets</a></h3><div id="rfc.section.3.7.p.1"><p>Packets in QUIC are only considered lost once a larger packet number is acknowledged. DetectLostPackets is called every time there is a new largest packet or if the loss detection alarm fires the previous largest acked packet is supplied.</p></div><div id="rfc.section.3.7.p.2"><p>DetectLostPackets takes one parameter, acked_packet, which is the packet number of the largest acked packet, and returns a list of packet numbers detected as lost.</p></div><div id="rfc.section.3.7.p.3" class="avoidbreakafter"><p>Pseudocode for DetectLostPackets follows:</p></div><div id="rfc.figure.u.6"><pre>
   DetectLostPackets(acked_packet):
     lost_packets = {};
     foreach (unacked_packet less than acked_packet):
         if (unacked_packet.time_sent &lt;
             acked_packet.time_sent - 1/8 * smoothed_rtt):
           lost_packets.insert(unacked_packet.packet_number);
       else if (unacked_packet.packet_number &lt;
                acked_packet.packet_number - reordering_threshold)
         lost_packets.insert(unacked_packet.packet_number);
     return lost_packets;
</pre></div></section></section><hr class="noprint"><section id="congestion-control"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a> <a href="#congestion-control">Congestion Control</a></h2><div id="rfc.section.4.p.1"><p>(describe NewReno-style congestion control for QUIC.)</p></div></section><hr class="noprint"><section id="tcp-mechanisms-in-quic"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a> <a href="#tcp-mechanisms-in-quic">TCP mechanisms in QUIC</a></h2><div id="rfc.section.5.p.1"><p>QUIC implements the spirit of a variety of RFCs, Internet drafts, and other well-known TCP loss recovery mechanisms, though the implementation details differ from the TCP implementations.</p></div><section id="rfc-6298-rto-computation"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a> <a href="#rfc-6298-rto-computation">RFC 6298 (RTO computation)</a></h3><div id="rfc.section.5.1.p.1"><p>QUIC calculates SRTT and RTTVAR according to the standard formulas. An RTT sample is only taken if the delayed ack correction is smaller than the measured RTT (otherwise a negative RTT would result), and the ack’s contains a new, larger largest observed packet number. min_rtt is only based on the observed RTT, but SRTT uses the delayed ack correction delta.</p></div><div id="rfc.section.5.1.p.2"><p>As described above, QUIC implements RTO with the standard timeout and CWND reduction. However, QUIC retransmits the earliest outstanding packets rather than the latest, because QUIC doesn’t have retransmission ambiguity. QUIC uses the commonly accepted min RTO of 200ms instead of the 1s the RFC specifies.</p></div></section><section id="fack-loss-recovery-paper"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a> <a href="#fack-loss-recovery-paper">FACK Loss Recovery (paper)</a></h3><div id="rfc.section.5.2.p.1"><p>QUIC implements the algorithm for early loss recovery described in the FACK paper (and implemented in the Linux kernel.) QUIC uses the packet number to measure the FACK reordering threshold. Currently QUIC does not implement an adaptive threshold as many TCP implementations (i.e., the Linux kernel) do.</p></div></section><section id="rfc-3782-rfc-6582-newreno-fast-recovery"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a> <a href="#rfc-3782-rfc-6582-newreno-fast-recovery">RFC 3782, RFC 6582 (NewReno Fast Recovery)</a></h3><div id="rfc.section.5.3.p.1"><p>QUIC only reduces its CWND once per congestion window, in keeping with the NewReno RFC. It tracks the largest outstanding packet at the time the loss is declared and any losses which occur before that packet number are considered part of the same loss event. It’s worth noting that some TCP implementations may do this on a sequence number basis, and hence consider multiple losses of the same packet a single loss event.</p></div></section><section id="tlp-draft"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a> <a href="#tlp-draft">TLP (draft)</a></h3><div id="rfc.section.5.4.p.1"><p>QUIC always sends two tail loss probes before RTO is triggered. QUIC invokes tail loss probe even when a loss is outstanding, which is different than some TCP implementations.</p></div></section><section id="rfc-5827-early-retransmit-with-delay-timer"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5</a> <a href="#rfc-5827-early-retransmit-with-delay-timer">RFC 5827 (Early Retransmit) with Delay Timer</a></h3><div id="rfc.section.5.5.p.1"><p>QUIC implements early retransmit with a timer in order to minimize spurious retransmits. The timer is set to 1/4 SRTT after the final outstanding packet is acked.</p></div></section><section id="rfc-5827-f-rto"><h3 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6</a> <a href="#rfc-5827-f-rto">RFC 5827 (F-RTO)</a></h3><div id="rfc.section.5.6.p.1"><p>QUIC implements F-RTO by not reducing the CWND and SSThresh until a subsequent ack is received and it’s sure the RTO was not spurious. Conceptually this is similar, but it makes for a much cleaner implementation with fewer edge cases.</p></div></section><section id="rfc-6937-proportional-rate-reduction"><h3 id="rfc.section.5.7"><a href="#rfc.section.5.7">5.7</a> <a href="#rfc-6937-proportional-rate-reduction">RFC 6937 (Proportional Rate Reduction)</a></h3><div id="rfc.section.5.7.p.1"><p>PRR-SSRB is implemented by QUIC in the epoch when recovering from a loss.</p></div></section><section id="tcp-cubic-draft-with-optional-rfc-5681-reno"><h3 id="rfc.section.5.8"><a href="#rfc.section.5.8">5.8</a> <a href="#tcp-cubic-draft-with-optional-rfc-5681-reno">TCP Cubic (draft) with optional RFC 5681 (Reno)</a></h3><div id="rfc.section.5.8.p.1"><p>TCP Cubic is the default congestion control algorithm in QUIC. Reno is also an easily available option which may be requested via connection options and is fully implemented.</p></div></section><section id="hybrid-slow-start-paper"><h3 id="rfc.section.5.9"><a href="#rfc.section.5.9">5.9</a> <a href="#hybrid-slow-start-paper">Hybrid Slow Start (paper)</a></h3><div id="rfc.section.5.9.p.1"><p>QUIC implements hybrid slow start, but disables ack train detection, because it has shown to falsely trigger when coupled with packet pacing, which is also on by default in QUIC. Currently the minimum delay increase is 4ms, the maximum is 16ms, and within that range QUIC exits slow start if the min_rtt within a round increases by more than ⅛ of the connection mi</p></div></section><section id="rack-draft"><h3 id="rfc.section.5.10"><a href="#rfc.section.5.10">5.10</a> <a href="#rack-draft">RACK (draft)</a></h3><div id="rfc.section.5.10.p.1"><p>QUIC’s loss detection is by it’s time-ordered nature, very similar to RACK. Though QUIC defaults to loss detection based on reordering threshold in packets, it could just as easily be based on fractions of an rtt, as RACK does.</p></div></section></section><hr class="noprint"><section id="iana-considerations"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.6.p.1"><p>This document has no IANA actions. Yet.</p></div></section><section id="rfc.references" class="np"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Normative References</h2><dl class="reference"><dt id="QUIC-TLS">[QUIC-TLS]</dt><dd>Thomson, M., Ed. and S. Turner, Ed, Ed., “Using Transport Layer Security (TLS) to Secure QUIC”, November 2016.</dd><dt id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</dt><dd>Iyengar, J., Ed. and M. Thomson, Ed., “QUIC: A UDP-Based Multiplexed and Secure Transport”, November 2016.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC6298">[RFC6298]</dt><dd>Paxson, V., Allman, M., Chu, J., and M. Sargent, “<a href="https://tools.ietf.org/html/rfc6298">Computing TCP's Retransmission Timer</a>”, RFC 6298, <a href="http://dx.doi.org/10.17487/RFC6298">DOI 10.17487/RFC6298</a>, June 2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6298">http://www.rfc-editor.org/info/rfc6298</a>&gt;.</dd></dl></section><hr class="noprint"><section id="acknowledgments"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a> <a href="#acknowledgments">Acknowledgments</a></h2></section><hr class="noprint"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Jana Iyengar</b>
      (editor)
    <br>Google<br>EMail: <a href="mailto:jri@google.com">jri@google.com</a></address><address><b>Ian Swett</b>
      (editor)
  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/{SLUG}">Fork me on GitHub</a></div></div>
    <br>Google<br>EMail: <a href="mailto:ianswett@google.com">ianswett@google.com</a></address></section></body></html>
