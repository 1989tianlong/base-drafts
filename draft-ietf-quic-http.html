<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Hypertext Transfer Protocol (HTTP) over QUIC</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Helvetica Neue","Roboto Condensed","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 1024px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Connection Setup and Management">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Discovering an HTTP/QUIC Endpoint">
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 QUIC Version Hints">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Connection Establishment">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Draft Version Identification">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Connection Reuse">
<link href="#rfc.section.3" rel="Chapter" title="3 Stream Mapping and Usage">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Control Streams">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 HTTP Message Exchanges">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Header Compression">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 The CONNECT Method">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Request Cancellation">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Request Prioritization">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Server Push">
<link href="#rfc.section.4" rel="Chapter" title="4 HTTP Framing Layer">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Frame Layout">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Frame Definitions">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 DATA">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 HEADERS">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 PRIORITY">
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 CANCEL_PUSH">
<link href="#rfc.section.4.2.5" rel="Chapter" title="4.2.5 SETTINGS">
<link href="#rfc.section.4.2.6" rel="Chapter" title="4.2.6 PUSH_PROMISE">
<link href="#rfc.section.4.2.7" rel="Chapter" title="4.2.7 GOAWAY">
<link href="#rfc.section.4.2.8" rel="Chapter" title="4.2.8 HEADER_ACK">
<link href="#rfc.section.4.2.9" rel="Chapter" title="4.2.9 MAX_PUSH_ID">
<link href="#rfc.section.5" rel="Chapter" title="5 Connection Management">
<link href="#rfc.section.6" rel="Chapter" title="6 Error Handling">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 HTTP/QUIC Error Codes">
<link href="#rfc.section.7" rel="Chapter" title="7 Considerations for Transitioning from HTTP/2">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Streams">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 HTTP Frame Types">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 HTTP/2 SETTINGS Parameters">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 HTTP/2 Error Codes">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Registration of HTTP/QUIC Identification String">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Registration of QUIC Version Hint Alt-Svc Parameter">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Frame Types">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Settings Parameters">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Error Codes">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Contributors">
<link href="#rfc.appendix.B" rel="Chapter" title="B Change Log">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Since draft-ietf-quic-http-09">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Since draft-ietf-quic-http-08">
<link href="#rfc.appendix.B.3" rel="Chapter" title="B.3 Since draft-ietf-quic-http-07">
<link href="#rfc.appendix.B.4" rel="Chapter" title="B.4 Since draft-ietf-quic-http-06">
<link href="#rfc.appendix.B.5" rel="Chapter" title="B.5 Since draft-ietf-quic-http-05">
<link href="#rfc.appendix.B.6" rel="Chapter" title="B.6 Since draft-ietf-quic-http-04">
<link href="#rfc.appendix.B.7" rel="Chapter" title="B.7 Since draft-ietf-quic-http-03">
<link href="#rfc.appendix.B.8" rel="Chapter" title="B.8 Since draft-ietf-quic-http-02">
<link href="#rfc.appendix.B.9" rel="Chapter" title="B.9 Since draft-ietf-quic-http-01">
<link href="#rfc.appendix.B.10" rel="Chapter" title="B.10 Since draft-ietf-quic-http-00">
<link href="#rfc.appendix.B.11" rel="Chapter" title="B.11 Since draft-shade-quic-http2-mapping-00">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Bishop, M., Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-http-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-04-15" />
  <meta name="dct.abstract" content="The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC, and describes how HTTP/2 extensions can be ported to QUIC." />
  <meta name="description" content="The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC, and describes how HTTP/2 extensions can be ported to QUIC." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">M. Bishop, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Akamai</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">April 15, 2018</td>
</tr>
<tr>
<td class="left">Expires: October 17, 2018</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Hypertext Transfer Protocol (HTTP) over QUIC<br />
  <span class="filename">draft-ietf-quic-http-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment.  This document describes a mapping of HTTP semantics over QUIC.  This document also identifies HTTP/2 features that are subsumed by QUIC, and describes how HTTP/2 extensions can be ported to QUIC.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-http">https://github.com/quicwg/base-drafts/labels/-http</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 17, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Notational Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Connection Setup and Management</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Discovering an HTTP/QUIC Endpoint</a>
</li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">QUIC Version Hints</a>
</li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Connection Establishment</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Draft Version Identification</a>
</li>
</ul><li>2.3.   <a href="#rfc.section.2.3">Connection Reuse</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Stream Mapping and Usage</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Control Streams</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">HTTP Message Exchanges</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Header Compression</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">The CONNECT Method</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Request Cancellation</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Request Prioritization</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Server Push</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">HTTP Framing Layer</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Frame Layout</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Frame Definitions</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">DATA</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">HEADERS</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">PRIORITY</a>
</li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">CANCEL_PUSH</a>
</li>
<li>4.2.5.   <a href="#rfc.section.4.2.5">SETTINGS</a>
</li>
<li>4.2.6.   <a href="#rfc.section.4.2.6">PUSH_PROMISE</a>
</li>
<li>4.2.7.   <a href="#rfc.section.4.2.7">GOAWAY</a>
</li>
<li>4.2.8.   <a href="#rfc.section.4.2.8">HEADER_ACK</a>
</li>
<li>4.2.9.   <a href="#rfc.section.4.2.9">MAX_PUSH_ID</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Connection Management</a>
</li>
<li>6.   <a href="#rfc.section.6">Error Handling</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">HTTP/QUIC Error Codes</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Considerations for Transitioning from HTTP/2</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Streams</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">HTTP Frame Types</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">HTTP/2 SETTINGS Parameters</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">HTTP/2 Error Codes</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Registration of HTTP/QUIC Identification String</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Registration of QUIC Version Hint Alt-Svc Parameter</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Frame Types</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Settings Parameters</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Error Codes</a>
</li>
</ul><li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Contributors</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Change Log</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Since draft-ietf-quic-http-09</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Since draft-ietf-quic-http-08</a>
</li>
<li>B.3.   <a href="#rfc.appendix.B.3">Since draft-ietf-quic-http-07</a>
</li>
<li>B.4.   <a href="#rfc.appendix.B.4">Since draft-ietf-quic-http-06</a>
</li>
<li>B.5.   <a href="#rfc.appendix.B.5">Since draft-ietf-quic-http-05</a>
</li>
<li>B.6.   <a href="#rfc.appendix.B.6">Since draft-ietf-quic-http-04</a>
</li>
<li>B.7.   <a href="#rfc.appendix.B.7">Since draft-ietf-quic-http-03</a>
</li>
<li>B.8.   <a href="#rfc.appendix.B.8">Since draft-ietf-quic-http-02</a>
</li>
<li>B.9.   <a href="#rfc.appendix.B.9">Since draft-ietf-quic-http-01</a>
</li>
<li>B.10.   <a href="#rfc.appendix.B.10">Since draft-ietf-quic-http-00</a>
</li>
<li>B.11.   <a href="#rfc.appendix.B.11">Since draft-shade-quic-http2-mapping-00</a>
</li>
</ul><li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The QUIC transport protocol has several features that are desirable in a transport for HTTP, such as stream multiplexing, per-stream flow control, and low-latency connection establishment. This document describes a mapping of HTTP semantics over QUIC, drawing heavily on the existing TCP mapping, HTTP/2.  Specifically, this document identifies HTTP/2 features that are subsumed by QUIC, and describes how the other features can be implemented atop QUIC.</p>
<p id="rfc.section.1.p.2">QUIC is described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  For a full description of HTTP/2, see <a href="#RFC7540" class="xref">[RFC7540]</a>.</p>
<h2 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h2>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.1.p.2">Field definitions are given in Augmented Backus-Naur Form (ABNF), as defined in <a href="#RFC5234" class="xref">[RFC5234]</a>.</p>
<p id="rfc.section.1.1.p.3">This document uses the variable-length integer encoding from <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.1.1.p.4">Protocol elements called &#8220;frames&#8221; exist in both this document and <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>. Where frames from <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a> are referenced, the frame name will be prefaced with &#8220;QUIC.&#8221;  For example, &#8220;QUIC APPLICATION_CLOSE frames.&#8221;  References without this preface refer to frames defined in <a href="#frames" class="xref">Section 4.2</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#connection-setup-and-management" id="connection-setup-and-management">Connection Setup and Management</a>
</h1>
<h2 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#discovering-an-httpquic-endpoint" id="discovering-an-httpquic-endpoint">Discovering an HTTP/QUIC Endpoint</a>
</h2>
<p id="rfc.section.2.1.p.1">An HTTP origin advertises the availability of an equivalent HTTP/QUIC endpoint via the Alt-Svc HTTP response header or the HTTP/2 ALTSVC frame (<a href="#RFC7838" class="xref">[RFC7838]</a>), using the ALPN token defined in <a href="#connection-establishment" class="xref">Section 2.2</a>.</p>
<p id="rfc.section.2.1.p.2">For example, an origin could indicate in an HTTP/1.1 or HTTP/2 response that HTTP/QUIC was available on UDP port 50781 at the same hostname by including the following header in any response:</p>
<pre>
Alt-Svc: hq=":50781"
</pre>
<p id="rfc.section.2.1.p.3">On receipt of an Alt-Svc record indicating HTTP/QUIC support, a client MAY attempt to establish a QUIC connection to the indicated host and port and, if successful, send HTTP requests using the mapping described in this document.</p>
<p id="rfc.section.2.1.p.4">Connectivity problems (e.g. firewall blocking UDP) can result in QUIC connection establishment failure, in which case the client SHOULD continue using the existing connection or try another alternative endpoint offered by the origin.</p>
<p id="rfc.section.2.1.p.5">Servers MAY serve HTTP/QUIC on any UDP port, since an alternative always includes an explicit port.</p>
<h3 id="rfc.section.2.1.1">
<a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#alt-svc-version-hint" id="alt-svc-version-hint">QUIC Version Hints</a>
</h3>
<p id="rfc.section.2.1.1.p.1">This document defines the &#8220;quic&#8221; parameter for Alt-Svc, which MAY be used to provide version-negotiation hints to HTTP/QUIC clients. QUIC versions are four-octet sequences with no additional constraints on format.  Leading zeros SHOULD be omitted for brevity.</p>
<p id="rfc.section.2.1.1.p.2">Syntax:</p>
<pre>
quic = DQUOTE version-number [ "," version-number ] * DQUOTE
version-number = 1*8HEXDIG; hex-encoded QUIC version
</pre>
<p id="rfc.section.2.1.1.p.3">Where multiple versions are listed, the order of the values reflects the server&#8217;s preference (with the first value being the most preferred version).  Reserved versions MAY be listed, but unreserved versions which are not supported by the alternative SHOULD NOT be present in the list. Origins MAY omit supported versions for any reason.</p>
<p id="rfc.section.2.1.1.p.4">Clients MUST ignore any included versions which they do not support.  The &#8220;quic&#8221; parameter MUST NOT occur more than once; clients SHOULD process only the first occurrence.</p>
<p id="rfc.section.2.1.1.p.5">For example, suppose a server supported both version 0x00000001 and the version rendered in ASCII as &#8220;Q034&#8221;.  If it opted to include the reserved versions (from Section 4 of <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>) 0x0 and 0x1abadaba, it could specify the following header:</p>
<pre>
Alt-Svc: hq=":49288";quic="1,1abadaba,51303334,0"
</pre>
<p id="rfc.section.2.1.1.p.6">A client acting on this header would drop the reserved versions (because it does not support them), then attempt to connect to the alternative using the first version in the list which it does support.</p>
<h2 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#connection-establishment" id="connection-establishment">Connection Establishment</a>
</h2>
<p id="rfc.section.2.2.p.1">HTTP/QUIC relies on QUIC as the underlying transport.  The QUIC version being used MUST use TLS version 1.3 or greater as its handshake protocol.  The Server Name Indication (SNI) extension <a href="#RFC6066" class="xref">[RFC6066]</a> MUST be included in the TLS handshake.</p>
<p id="rfc.section.2.2.p.2">QUIC connections are established as described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>. During connection establishment, HTTP/QUIC support is indicated by selecting the ALPN token &#8220;hq&#8221; in the TLS handshake.  Support for other application-layer protocols MAY be offered in the same handshake.</p>
<p id="rfc.section.2.2.p.3">While connection-level options pertaining to the core QUIC protocol are set in the initial crypto handshake, HTTP-specific settings are conveyed in the SETTINGS frame. After the QUIC connection is established, a SETTINGS frame (<a href="#frame-settings" class="xref">Section 4.2.5</a>) MUST be sent by each endpoint as the initial frame of their respective HTTP control stream (Stream ID 2 or 3, see <a href="#stream-mapping" class="xref">Section 3</a>). The server MUST NOT send data on any other stream until the client&#8217;s SETTINGS frame has been received.</p>
<h3 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#draft-version-identification" id="draft-version-identification">Draft Version Identification</a>
</h3>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li></ul>
<p id="rfc.section.2.2.1.p.2">Only implementations of the final, published RFC can identify themselves as &#8220;hq&#8221;. Until such an RFC exists, implementations MUST NOT identify themselves using this string.</p>
<p id="rfc.section.2.2.1.p.3">Implementations of draft versions of the protocol MUST add the string &#8220;-&#8220; and the corresponding draft number to the identifier. For example, draft-ietf-quic-http-01 is identified using the string &#8220;hq-01&#8221;.</p>
<p id="rfc.section.2.2.1.p.4">Non-compatible experiments that are based on these draft versions MUST append the string &#8220;-&#8220; and an experiment name to the identifier. For example, an experimental implementation based on draft-ietf-quic-http-09 which reserves an extra stream for unsolicited transmission of 1980s pop music might identify itself as &#8220;hq-09-rickroll&#8221;. Note that any label MUST conform to the &#8220;token&#8221; syntax defined in Section 3.2.6 of <a href="#RFC7230" class="xref">[RFC7230]</a>. Experimenters are encouraged to coordinate their experiments on the quic@ietf.org mailing list.</p>
<h2 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#connection-reuse" id="connection-reuse">Connection Reuse</a>
</h2>
<p id="rfc.section.2.3.p.1">Once a connection exists to a server endpoint, this connection MAY be reused for requests with multiple different URI authority components.  The client MAY send any requests for which the client considers the server authoritative.</p>
<p id="rfc.section.2.3.p.2">An authoritative HTTP/QUIC endpoint is typically discovered because the client has received an Alt-Svc record from the request&#8217;s origin which nominates the endpoint as a valid HTTP Alternative Service for that origin.  As required by <a href="#RFC7838" class="xref">[RFC7838]</a>, clients MUST check that the nominated server can present a valid certificate for the origin before considering it authoritative. Clients MUST NOT assume that an HTTP/QUIC endpoint is authoritative for other origins without an explicit signal.</p>
<p id="rfc.section.2.3.p.3">A server that does not wish clients to reuse connections for a particular origin can indicate that it is not authoritative for a request by sending a 421 (Misdirected Request) status code in response to the request (see Section 9.1.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>).</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#stream-mapping" id="stream-mapping">Stream Mapping and Usage</a>
</h1>
<p id="rfc.section.3.p.1">A QUIC stream provides reliable in-order delivery of bytes, but makes no guarantees about order of delivery with regard to bytes on other streams. On the wire, data is framed into QUIC STREAM frames, but this framing is invisible to the HTTP framing layer. A QUIC receiver buffers and orders received STREAM frames, exposing the data contained within as a reliable byte stream to the application.</p>
<p id="rfc.section.3.p.2">QUIC reserves the first client-initiated, bidirectional stream (Stream 0) for cryptographic operations. HTTP over QUIC reserves the first unidirectional stream sent by either peer (Streams 2 and 3) for sending and receiving HTTP control frames.  This pair of unidirectional streams is analogous to HTTP/2&#8217;s Stream 0.  The data sent on these streams is critical to the HTTP connection.  If either control stream is closed for any reason, this MUST be treated as a connection error of type QUIC_CLOSED_CRITICAL_STREAM.</p>
<p id="rfc.section.3.p.3">When HTTP headers and data are sent over QUIC, the QUIC layer handles most of the stream management.</p>
<p id="rfc.section.3.p.4">An HTTP request/response consumes a single client-initiated, bidirectional stream.  A bidirectional stream ensures that the response can be readily correlated with the request. This means that the client&#8217;s first request occurs on QUIC stream 4, with subsequent requests on stream 8, 12, and so on.</p>
<p id="rfc.section.3.p.5">Server push uses server-initiated, unidirectional streams.  Thus, the server&#8217;s first push consumes stream 7 and subsequent pushes use stream 11, 15, and so on.</p>
<p id="rfc.section.3.p.6">These streams carry frames related to the request/response (see <a href="#frames" class="xref">Section 4.2</a>).  When a stream terminates cleanly, if the last frame on the stream was truncated, this MUST be treated as a connection error (see HTTP_MALFORMED_FRAME in <a href="#http-error-codes" class="xref">Section 6.1</a>).  Streams which terminate abruptly may be reset at any point in the frame.</p>
<p id="rfc.section.3.p.7">Streams SHOULD be used sequentially, with no gaps.</p>
<p id="rfc.section.3.p.8">HTTP does not need to do any separate multiplexing when using QUIC - data sent over a QUIC stream always maps to a particular HTTP transaction. Requests and responses are considered complete when the corresponding QUIC stream is closed in the appropriate direction.</p>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#control-streams" id="control-streams">Control Streams</a>
</h2>
<p id="rfc.section.3.1.p.1">Since most connection-level concerns will be managed by QUIC, the primary use of Streams 2 and 3 will be for the SETTINGS frame when the connection opens and for PRIORITY frames subsequently.</p>
<p id="rfc.section.3.1.p.2">A pair of unidirectional streams is used rather than a single bidirectional stream.  This allows either peer to send data as soon they are able.  Depending on whether 0-RTT is enabled on the connection, either client or server might be able to send stream data first after the cryptographic handshake completes.</p>
<h2 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#request-response" id="request-response">HTTP Message Exchanges</a>
</h2>
<p id="rfc.section.3.2.p.1">A client sends an HTTP request on a client-initiated, bidirectional QUIC stream. A server sends an HTTP response on the same stream as the request.</p>
<p id="rfc.section.3.2.p.2">An HTTP message (request or response) consists of:</p>
<p></p>

<ol>
<li>one header block (see <a href="#frame-headers" class="xref">Section 4.2.2</a>) containing the message headers (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 3.2),</li>
<li>the payload body (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 3.3), sent as a series of DATA frames (see <a href="#frame-data" class="xref">Section 4.2.1</a>),</li>
<li>optionally, one header block containing the trailer-part, if present (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 4.1.2).</li>
</ol>
<p id="rfc.section.3.2.p.4">In addition, prior to sending the message header block indicated above, a response may contain zero or more header blocks containing the message headers of informational (1xx) HTTP responses (see <a href="#RFC7230" class="xref">[RFC7230]</a>, Section 3.2 and <a href="#RFC7231" class="xref">[RFC7231]</a>, Section 6.2).</p>
<p id="rfc.section.3.2.p.5">PUSH_PROMISE frames MAY be interleaved with the frames of a response message indicating a pushed resource related to the response. These PUSH_PROMISE frames are not part of the response, but carry the headers of a separate HTTP request message.  See <a href="#server-push" class="xref">Section 3.4</a> for more details.</p>
<p id="rfc.section.3.2.p.6">The &#8220;chunked&#8221; transfer encoding defined in Section 4.1 of <a href="#RFC7230" class="xref">[RFC7230]</a> MUST NOT be used.</p>
<p id="rfc.section.3.2.p.7">Trailing header fields are carried in an additional header block following the body. Such a header block is a sequence of HEADERS frames with End Header Block set on the last frame. Senders MUST send only one header block in the trailers section; receivers MUST discard any subsequent header blocks.</p>
<p id="rfc.section.3.2.p.8">An HTTP request/response exchange fully consumes a QUIC stream. After sending a request, a client closes the stream for sending; after sending a response, the server closes the stream for sending and the QUIC stream is fully closed.</p>
<p id="rfc.section.3.2.p.9">A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server MAY request that the client abort transmission of a request without error by triggering a QUIC STOP_SENDING with error code HTTP_EARLY_RESPONSE, sending a complete response, and cleanly closing its streams. Clients MUST NOT discard complete responses as a result of having their request terminated abruptly, though clients can always discard responses at their discretion for other reasons.  Servers MUST NOT abort a response in progress as a result of receiving a solicited RST_STREAM.</p>
<h3 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#header-compression" id="header-compression">Header Compression</a>
</h3>
<p id="rfc.section.3.2.1.p.1">HTTP/QUIC uses QPACK header compression as described in <a href="#QPACK" class="xref">[QPACK]</a>, a variation of HPACK which allows the flexibility to avoid header-compression-induced head-of-line blocking.  See that document for additional details.</p>
<h3 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#the-connect-method" id="the-connect-method">The CONNECT Method</a>
</h3>
<p id="rfc.section.3.2.2.p.1">The pseudo-method CONNECT (<a href="#RFC7231" class="xref">[RFC7231]</a>, Section 4.3.6) is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with &#8220;https&#8221; resources. In HTTP/1.x, CONNECT is used to convert an entire HTTP connection into a tunnel to a remote host. In HTTP/2, the CONNECT method is used to establish a tunnel over a single HTTP/2 stream to a remote host for similar purposes.</p>
<p id="rfc.section.3.2.2.p.2">A CONNECT request in HTTP/QUIC functions in the same manner as in HTTP/2. The request MUST be formatted as described in <a href="#RFC7540" class="xref">[RFC7540]</a>, Section 8.3. A CONNECT request that does not conform to these restrictions is malformed. The request stream MUST NOT be half-closed at the end of the request.</p>
<p id="rfc.section.3.2.2.p.3">A proxy that supports CONNECT establishes a TCP connection (<a href="#RFC0793" class="xref">[RFC0793]</a>) to the server identified in the &#8220;:authority&#8221; pseudo-header field. Once this connection is successfully established, the proxy sends a HEADERS frame containing a 2xx series status code to the client, as defined in <a href="#RFC7231" class="xref">[RFC7231]</a>, Section 4.3.6.</p>
<p id="rfc.section.3.2.2.p.4">All DATA frames on the request stream correspond to data sent on the TCP connection. Any DATA frame sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is packaged into DATA frames by the proxy. Note that the size and number of TCP segments is not guaranteed to map predictably to the size and number of HTTP DATA or QUIC STREAM frames.</p>
<p id="rfc.section.3.2.2.p.5">The TCP connection can be closed by either peer. When the client ends the request stream (that is, the receive stream at the proxy enters the &#8220;Data Recvd&#8221; state), the proxy will set the FIN bit on its connection to the TCP server. When the proxy receives a packet with the FIN bit set, it will terminate the send stream that it sends to client. TCP connections which remain half-closed in a single direction are not invalid, but are often handled poorly by servers, so clients SHOULD NOT cause send a STREAM frame with a FIN bit for connections on which they are still expecting data.</p>
<p id="rfc.section.3.2.2.p.6">A TCP connection error is signaled with RST_STREAM. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error of type HTTP_CONNECT_ERROR (<a href="#http-error-codes" class="xref">Section 6.1</a>).  Correspondingly, a proxy MUST send a TCP segment with the RST bit set if it detects an error with the stream or the QUIC connection.</p>
<h3 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#request-cancellation" id="request-cancellation">Request Cancellation</a>
</h3>
<p id="rfc.section.3.2.3.p.1">Either client or server can cancel requests by closing the stream (QUIC RST_STREAM or STOP_SENDING frames, as appropriate) with an error type of HTTP_REQUEST_CANCELLED (<a href="#http-error-codes" class="xref">Section 6.1</a>).  When the client cancels a request or response, it indicates that the response is no longer of interest.</p>
<p id="rfc.section.3.2.3.p.2">When the server cancels either direction of the request stream using HTTP_REQUEST_CANCELLED, it indicates that no application processing was performed.  The client can treat requests cancelled by the server as though they had never been sent at all, thereby allowing them to be retried later on a new connection.  Servers MUST NOT use the HTTP_REQUEST_CANCELLED status for requests which were partially or fully processed.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">In this context, &#8220;processed&#8221; means that some data from the stream was passed to some higher layer of software that might have taken some action as a result.</dd>
</dl>
<p id="rfc.section.3.2.3.p.4">If a stream is cancelled after receiving a complete response, the client MAY ignore the cancellation and use the response.  However, if a stream is cancelled after receiving a partial response, the response SHOULD NOT be used.  Automatically retrying such requests is not possible, unless this is otherwise permitted (e.g., idempotent actions like GET, PUT, or DELETE).</p>
<h2 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#priority" id="priority">Request Prioritization</a>
</h2>
<p id="rfc.section.3.3.p.1">HTTP/QUIC uses the priority scheme described in <a href="#RFC7540" class="xref">[RFC7540]</a>, Section 5.3. In this priority scheme, a given request can be designated as dependent upon another request, which expresses the preference that the latter stream (the &#8220;parent&#8221; request) be allocated resources before the former stream (the &#8220;dependent&#8221; request). Taken together, the dependencies across all requests in a connection form a dependency tree. The structure of the dependency tree changes as PRIORITY frames add, remove, or change the dependency links between requests.</p>
<p id="rfc.section.3.3.p.2">The PRIORITY frame <a href="#frame-priority" class="xref">Section 4.2.3</a> identifies a request either by identifying the stream that carries a request or by using a Push ID (<a href="#frame-push-promise" class="xref">Section 4.2.6</a>).</p>
<p id="rfc.section.3.3.p.3">Only a client can send PRIORITY frames.  A server MUST NOT send a PRIORITY frame.</p>
<h2 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#server-push" id="server-push">Server Push</a>
</h2>
<p id="rfc.section.3.4.p.1">HTTP/QUIC supports server push in a similar manner to <a href="#RFC7540" class="xref">[RFC7540]</a>, but uses different mechanisms. During connection establishment, the client enables server push by sending a MAX_PUSH_ID frame (see <a href="#frame-max-push-id" class="xref">Section 4.2.9</a>). A server cannot use server push until it receives a MAX_PUSH_ID frame.</p>
<p id="rfc.section.3.4.p.2">As with server push for HTTP/2, the server initiates a server push by sending a PUSH_PROMISE frame (see <a href="#frame-push-promise" class="xref">Section 4.2.6</a>) that includes request headers for the promised request.  Promised requests MUST conform to the requirements in Section 8.2 of <a href="#RFC7540" class="xref">[RFC7540]</a>.</p>
<p id="rfc.section.3.4.p.3">The PUSH_PROMISE frame is sent on the client-initiated, bidirectional stream that carried the request that generated the push.  This allows the server push to be associated with a request.  Ordering of a PUSH_PROMISE in relation to certain parts of the response is important (see Section 8.2.1 of <a href="#RFC7540" class="xref">[RFC7540]</a>).</p>
<p id="rfc.section.3.4.p.4">Unlike HTTP/2, the PUSH_PROMISE does not reference a stream; it contains a Push ID. The Push ID uniquely identifies a server push. This allows a server to fulfill promises in the order that best suits its needs.</p>
<p id="rfc.section.3.4.p.5">When a server later fulfills a promise, the server push response is conveyed on a push stream.  A push stream is a server-initiated, unidirectional stream.  A push stream identifies the Push ID of the promise that it fulfills, encoded as a variable-length integer.</p>
<p id="rfc.section.3.4.p.6">A server SHOULD use Push IDs sequentially, starting at 0.  A client uses the MAX_PUSH_ID frame (<a href="#frame-max-push-id" class="xref">Section 4.2.9</a>) to limit the number of pushes that a server can promise.  A client MUST treat receipt of a push stream with a Push ID that is greater than the maximum Push ID as a connection error of type HTTP_PUSH_LIMIT_EXCEEDED.</p>
<p id="rfc.section.3.4.p.7">If a promised server push is not needed by the client, the client SHOULD send a CANCEL_PUSH frame; if the push stream is already open, a QUIC STOP_SENDING frame with an appropriate error code can be used instead (e.g., HTTP_PUSH_REFUSED, HTTP_PUSH_ALREADY_IN_CACHE; see <a href="#errors" class="xref">Section 6</a>).  This asks the server not to transfer the data and indicates that it will be discarded upon receipt.</p>
<div id="rfc.figure.1"></div>
<div id="fig-push-stream-header"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Push ID (i)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 1: Push Stream Header</p>
<p id="rfc.section.3.4.p.8">Push streams always begin with a header containing the Push ID.  Each Push ID MUST only be used once in a push stream header.  If a push stream header includes a Push ID that was used in another push stream header, the client MUST treat this as a connection error of type HTTP_DUPLICATE_PUSH.  The same Push ID can be used in multiple PUSH_PROMISE frames (see <a href="#frame-push-promise" class="xref">Section 4.2.6</a>).</p>
<p id="rfc.section.3.4.p.9">After the header, a push stream contains a response (<a href="#request-response" class="xref">Section 3.2</a>), with response headers, a response body (if any) carried by DATA frames, then trailers (if any) carried by HEADERS frames.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#http-framing-layer" id="http-framing-layer">HTTP Framing Layer</a>
</h1>
<p id="rfc.section.4.p.1">Frames are used on each stream.  This section describes HTTP framing in QUIC and highlights some differences from HTTP/2 framing.  For more detail on differences from HTTP/2, see <a href="#h2-frames" class="xref">Section 7.2</a>.</p>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#frame-layout" id="frame-layout">Frame Layout</a>
</h2>
<p id="rfc.section.4.1.p.1">All frames have the following format:</p>
<div id="rfc.figure.2"></div>
<div id="fig-frame"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Length (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Type (8)   |   Flags (8)   |       Frame Payload (*)     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 2: HTTP/QUIC frame format</p>
<p id="rfc.section.4.1.p.2">A frame includes the following fields:</p>
<p></p>

<dl>
<dt>Length:</dt>
<dd style="margin-left: 8">A variable-length integer that describes the length of the Frame Payload.  This length does not include the frame header.</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">An 8-bit type for the frame.</dd>
<dt>Flags:</dt>
<dd style="margin-left: 8">An 8-bit field containing flags.  The Type field determines the semantics of flags.</dd>
<dt>Frame Payload:</dt>
<dd style="margin-left: 8">A payload, the semantics of which are determined by the Type field.</dd>
</dl>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#frames" id="frames">Frame Definitions</a>
</h2>
<h3 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#frame-data" id="frame-data">DATA</a>
</h3>
<p id="rfc.section.4.2.1.p.1">DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with an HTTP request or response payload.</p>
<p id="rfc.section.4.2.1.p.2">The DATA frame defines no flags.</p>
<p id="rfc.section.4.2.1.p.3">DATA frames MUST be associated with an HTTP request or response.  If a DATA frame is received on either control stream, the recipient MUST respond with a connection error (<a href="#errors" class="xref">Section 6</a>) of type HTTP_WRONG_STREAM.</p>
<div id="rfc.figure.3"></div>
<div id="fig-data"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Payload (*)                         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 3: DATA frame payload</p>
<p id="rfc.section.4.2.1.p.4">DATA frames MUST contain a non-zero-length payload.  If a DATA frame is received with a payload length of zero, the recipient MUST respond with a stream error (<a href="#errors" class="xref">Section 6</a>) of type HTTP_MALFORMED_FRAME.</p>
<h3 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#frame-headers" id="frame-headers">HEADERS</a>
</h3>
<p id="rfc.section.4.2.2.p.1">The HEADERS frame (type=0x1) is used to carry a header block, compressed using QPACK. See <a href="#QPACK" class="xref">[QPACK]</a> for more details.</p>
<p id="rfc.section.4.2.2.p.2">The HEADERS frame defines a single flag:</p>
<p></p>

<dl>
<dt>BLOCKING (0x01):</dt>
<dd style="margin-left: 8">Indicates the stream might need to wait for dependent headers before processing.  If 0, the frame can be processed immediately upon receipt.</dd>
</dl>
<div id="rfc.figure.4"></div>
<div id="fig-headers"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Header Block (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 4: HEADERS frame payload</p>
<p id="rfc.section.4.2.2.p.4">HEADERS frames can be sent on the Control Stream as well as on request / push streams.  The value of BLOCKING MUST be 0 for HEADERS frames on the Control Stream, since they can only depend on previous HEADERS on the same stream.</p>
<h3 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#frame-priority" id="frame-priority">PRIORITY</a>
</h3>
<p id="rfc.section.4.2.3.p.1">The PRIORITY (type=0x02) frame specifies the sender-advised priority of a stream and is substantially different in format from <a href="#RFC7540" class="xref">[RFC7540]</a>.  In order to ensure that prioritization is processed in a consistent order, PRIORITY frames MUST be sent on the control stream.  A PRIORITY frame sent on any other stream MUST be treated as a HTTP_WRONG_STREAM error.</p>
<p id="rfc.section.4.2.3.p.2">The format has been modified to accommodate not being sent on a request stream, to allow for identification of server pushes, and the larger stream ID space of QUIC.  The semantics of the Stream Dependency, Weight, and E flag are otherwise the same as in HTTP/2.</p>
<p id="rfc.section.4.2.3.p.3">The flags defined are:</p>
<p></p>

<dl>
<dt>PUSH_PRIORITIZED (0x04):</dt>
<dd style="margin-left: 8">Indicates that the Prioritized Stream is a server push rather than a request.</dd>
<dt>PUSH_DEPENDENT (0x02):</dt>
<dd style="margin-left: 8">Indicates a dependency on a server push.</dd>
<dt>E (0x01):</dt>
<dd style="margin-left: 8">Indicates that the stream dependency is exclusive (see <a href="#RFC7540" class="xref">[RFC7540]</a>, Section 5.3).</dd>
</dl>
<div id="rfc.figure.5"></div>
<div id="fig-priority"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Prioritized Request ID (i)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Stream Dependency ID (i)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Weight (8)  |
+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 5: PRIORITY frame payload</p>
<p id="rfc.section.4.2.3.p.5">The PRIORITY frame payload has the following fields:</p>
<p></p>

<dl>
<dt>Prioritized Request ID:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies a request.  This contains the Stream ID of a request stream when the PUSH_PRIORITIZED flag is clear, or a Push ID when the PUSH_PRIORITIZED flag is set.</dd>
<dt>Stream Dependency ID:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies a dependent request.  This contains the Stream ID of a request stream when the PUSH_DEPENDENT flag is clear, or a Push ID when the PUSH_DEPENDENT flag is set.  A request Stream ID of 0 indicates a dependency on the root stream. For details of dependencies, see <a href="#priority" class="xref">Section 3.3</a> and <a href="#RFC7540" class="xref">[RFC7540]</a>, Section 5.3.</dd>
<dt>Weight:</dt>
<dd style="margin-left: 8">An unsigned 8-bit integer representing a priority weight for the stream (see <a href="#RFC7540" class="xref">[RFC7540]</a>, Section 5.3). Add one to the value to obtain a weight between 1 and 256.</dd>
</dl>
<p id="rfc.section.4.2.3.p.7">A PRIORITY frame identifies a request to prioritize, and a request upon which that request is dependent.  A Prioritized Request ID or Stream Dependency ID identifies a client-initiated request using the corresponding stream ID when the corresponding PUSH_PRIORITIZED or PUSH_DEPENDENT flag is not set.  Setting the PUSH_PRIORITIZED or PUSH_DEPENDENT flag causes the Prioritized Request ID or Stream Dependency ID (respectively) to identify a server push using a Push ID (see <a href="#frame-push-promise" class="xref">Section 4.2.6</a> for details).</p>
<p id="rfc.section.4.2.3.p.8">A PRIORITY frame MAY identify a Stream Dependency ID using a Stream ID of 0; as in <a href="#RFC7540" class="xref">[RFC7540]</a>, this makes the request dependent on the root of the dependency tree.</p>
<p id="rfc.section.4.2.3.p.9">A PRIORITY frame MUST identify a client-initiated, bidirectional stream.  A server MUST treat receipt of PRIORITY frame with a Stream ID of any other type as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.3.p.10">Stream ID 0 cannot be reprioritized. A Prioritized Request ID that identifies Stream 0 MUST be treated as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.3.p.11">A PRIORITY frame that does not reference a request MUST be treated as a HTTP_MALFORMED_FRAME error, unless it references Stream ID 0.  A PRIORITY that sets a PUSH_PRIORITIZED or PUSH_DEPENDENT flag, but then references a non-existent Push ID MUST be treated as a HTTP_MALFORMED_FRAME error.</p>
<p id="rfc.section.4.2.3.p.12">A PRIORITY frame MUST contain only the identified fields.  A PRIORITY frame that contains more or fewer fields, or a PRIORITY frame that includes a truncated integer encoding MUST be treated as a connection error of type HTTP_MALFORMED_FRAME.</p>
<h3 id="rfc.section.4.2.4">
<a href="#rfc.section.4.2.4">4.2.4.</a> <a href="#frame-cancel-push" id="frame-cancel-push">CANCEL_PUSH</a>
</h3>
<p id="rfc.section.4.2.4.p.1">The CANCEL_PUSH frame (type=0x3) is used to request cancellation of server push prior to the push stream being created.  The CANCEL_PUSH frame identifies a server push request by Push ID (see <a href="#frame-push-promise" class="xref">Section 4.2.6</a>) using a variable-length integer.</p>
<p id="rfc.section.4.2.4.p.2">When a server receives this frame, it aborts sending the response for the identified server push.  If the server has not yet started to send the server push, it can use the receipt of a CANCEL_PUSH frame to avoid opening a stream.  If the push stream has been opened by the server, the server SHOULD sent a QUIC RST_STREAM frame on those streams and cease transmission of the response.</p>
<p id="rfc.section.4.2.4.p.3">A server can send this frame to indicate that it won&#8217;t be sending a response prior to creation of a push stream.  Once the push stream has been created, sending CANCEL_PUSH has no effect on the state of the push stream.  A QUIC RST_STREAM frame SHOULD be used instead to cancel transmission of the server push response.</p>
<p id="rfc.section.4.2.4.p.4">A CANCEL_PUSH frame is sent on the control stream.  Sending a CANCEL_PUSH frame on a stream other than the control stream MUST be treated as a stream error of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.4.2.4.p.5">The CANCEL_PUSH frame has no defined flags.</p>
<div id="rfc.figure.6"></div>
<div id="fig-cancel-push"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 6: CANCEL_PUSH frame payload</p>
<p id="rfc.section.4.2.4.p.6">The CANCEL_PUSH frame carries a Push ID encoded as a variable-length integer.  The Push ID identifies the server push that is being cancelled (see <a href="#frame-push-promise" class="xref">Section 4.2.6</a>).</p>
<p id="rfc.section.4.2.4.p.7">If the client receives a CANCEL_PUSH frame, that frame might identify a Push ID that has not yet been mentioned by a PUSH_PROMISE frame.</p>
<p id="rfc.section.4.2.4.p.8">An endpoint MUST treat a CANCEL_PUSH frame which does not contain exactly one properly-formatted variable-length integer as a connection error of type HTTP_MALFORMED_FRAME.</p>
<h3 id="rfc.section.4.2.5">
<a href="#rfc.section.4.2.5">4.2.5.</a> <a href="#frame-settings" id="frame-settings">SETTINGS</a>
</h3>
<p id="rfc.section.4.2.5.p.1">The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior, and is different from <a href="#RFC7540" class="xref">[RFC7540]</a>. Individually, a SETTINGS parameter can also be referred to as a &#8220;setting&#8221;.</p>
<p id="rfc.section.4.2.5.p.2">SETTINGS parameters are not negotiated; they describe characteristics of the sending peer, which can be used by the receiving peer. However, a negotiation can be implied by the use of SETTINGS &#8211; a peer uses SETTINGS to advertise a set of supported values. The recipient can then choose which entries from this list are also acceptable and proceed with the value it has chosen. (This choice could be announced in a field of an extension frame, or in its own value in SETTINGS.)</p>
<p id="rfc.section.4.2.5.p.3">Different values for the same parameter can be advertised by each peer. For example, a client might be willing to consume very large response headers, while servers are more cautious about request size.</p>
<p id="rfc.section.4.2.5.p.4">Parameters MUST NOT occur more than once.  A receiver MAY treat the presence of the same parameter more than once as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.5.p.5">The SETTINGS frame defines no flags.</p>
<p id="rfc.section.4.2.5.p.6">The payload of a SETTINGS frame consists of zero or more parameters, each consisting of an unsigned 16-bit setting identifier and a length-prefixed binary value.</p>
<div id="rfc.figure.7"></div>
<div id="fig-ext-settings"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identifier (16)       |            Length (i)       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Contents (?)                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 7: SETTINGS value format</p>
<p id="rfc.section.4.2.5.p.7">A zero-length content indicates that the setting value is a Boolean and true.  False is indicated by the absence of the setting.</p>
<p id="rfc.section.4.2.5.p.8">Non-zero-length values MUST be compared against the remaining length of the SETTINGS frame.  Any value which purports to cross the end of the frame MUST cause the SETTINGS frame to be considered malformed and trigger a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.5.p.9">An implementation MUST ignore the contents for any SETTINGS identifier it does not understand.</p>
<p id="rfc.section.4.2.5.p.10">SETTINGS frames always apply to a connection, never a single stream.  A SETTINGS frame MUST be sent as the first frame of either control stream (see <a href="#stream-mapping" class="xref">Section 3</a>) by each peer, and MUST NOT be sent subsequently or on any other stream. If an endpoint receives an SETTINGS frame on a different stream, the endpoint MUST respond with a connection error of type HTTP_WRONG_STREAM.  If an endpoint receives a second SETTINGS frame, the endpoint MUST respond with a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.5.p.11">The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame MUST be treated as a connection error (<a href="#errors" class="xref">Section 6</a>) of type HTTP_MALFORMED_FRAME.</p>
<h4 id="rfc.section.4.2.5.1">
<a href="#rfc.section.4.2.5.1">4.2.5.1.</a> <a href="#integer-encoding" id="integer-encoding">Integer encoding</a>
</h4>
<p id="rfc.section.4.2.5.1.p.1">Settings which are integers use the QUIC variable-length integer encoding.</p>
<h4 id="rfc.section.4.2.5.2">
<a href="#rfc.section.4.2.5.2">4.2.5.2.</a> <a href="#settings-parameters" id="settings-parameters">Defined SETTINGS Parameters</a>
</h4>
<p id="rfc.section.4.2.5.2.p.1">The following settings are defined in HTTP/QUIC:</p>
<p></p>

<dl>
<dt>SETTINGS_HEADER_TABLE_SIZE (0x1):</dt>
<dd style="margin-left: 8">An integer with a maximum value of 2^30 - 1.</dd>
<dt>SETTINGS_MAX_HEADER_LIST_SIZE (0x6):</dt>
<dd style="margin-left: 8">An integer with a maximum value of 2^30 - 1</dd>
</dl>
<h4 id="rfc.section.4.2.5.3">
<a href="#rfc.section.4.2.5.3">4.2.5.3.</a> <a href="#initial-settings-values" id="initial-settings-values">Initial SETTINGS Values</a>
</h4>
<p id="rfc.section.4.2.5.3.p.1">When a 0-RTT QUIC connection is being used, the client&#8217;s initial requests will be sent before the arrival of the server&#8217;s SETTINGS frame.  Clients MUST store the settings the server provided in the session being resumed and MUST comply with stored settings until the server&#8217;s current settings are received.</p>
<p id="rfc.section.4.2.5.3.p.2">Servers MAY continue processing data from clients which exceed its current configuration during the initial flight.  In this case, the client MUST apply the new settings immediately upon receipt.</p>
<p id="rfc.section.4.2.5.3.p.3">When a 1-RTT QUIC connection is being used, the client MUST NOT send requests prior to receiving and processing the server&#8217;s SETTINGS frame.</p>
<h3 id="rfc.section.4.2.6">
<a href="#rfc.section.4.2.6">4.2.6.</a> <a href="#frame-push-promise" id="frame-push-promise">PUSH_PROMISE</a>
</h3>
<p id="rfc.section.4.2.6.p.1">The PUSH_PROMISE frame (type=0x05) is used to carry a request header set from server to client, as in HTTP/2.  The PUSH_PROMISE frame defines a single flag:</p>
<p></p>

<dl>
<dt>BLOCKING (0x01):</dt>
<dd style="margin-left: 8">Indicates the stream might need to wait for dependent headers before processing.  If 0, the frame can be processed immediately upon receipt.</dd>
</dl>
<div id="rfc.figure.8"></div>
<div id="fig-push-promise"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Header Block (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 8: PUSH_PROMISE frame payload</p>
<p id="rfc.section.4.2.6.p.3">The payload consists of:</p>
<p></p>

<dl>
<dt>Push ID:</dt>
<dd style="margin-left: 8">A variable-length integer that identifies the server push request.  A push ID is used in push stream header (<a href="#server-push" class="xref">Section 3.4</a>), CANCEL_PUSH frames (<a href="#frame-cancel-push" class="xref">Section 4.2.4</a>), and PRIORITY frames (<a href="#frame-priority" class="xref">Section 4.2.3</a>).</dd>
<dt>Header Block:</dt>
<dd style="margin-left: 8">QPACK-compressed request headers for the promised response.  See <a href="#QPACK" class="xref">[QPACK]</a> for more details.</dd>
</dl>
<p id="rfc.section.4.2.6.p.5">A server MUST NOT use a Push ID that is larger than the client has provided in a MAX_PUSH_ID frame (<a href="#frame-max-push-id" class="xref">Section 4.2.9</a>).  A client MUST treat receipt of a PUSH_PROMISE that contains a larger Push ID than the client has advertised as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.6.p.6">A server MAY use the same Push ID in multiple PUSH_PROMISE frames.  This allows the server to use the same server push in response to multiple concurrent requests.  Referencing the same server push ensures that a PUSH_PROMISE can be made in relation to every response in which server push might be needed without duplicating pushes.</p>
<p id="rfc.section.4.2.6.p.7">A server that uses the same Push ID in multiple PUSH_PROMISE frames MUST include the same header fields each time.  The octets of the header block MAY be different due to differing encoding, but the header fields and their values MUST be identical.  Note that ordering of header fields is significant.  A client MUST treat receipt of a PUSH_PROMISE with conflicting header field values for the same Push ID as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.6.p.8">Allowing duplicate references to the same Push ID is primarily to reduce duplication caused by concurrent requests.  A server SHOULD avoid reusing a Push ID over a long period.  Clients are likely to consume server push responses and not retain them for reuse over time.  Clients that see a PUSH_PROMISE that uses a Push ID that they have since consumed and discarded are forced to ignore the PUSH_PROMISE.</p>
<h3 id="rfc.section.4.2.7">
<a href="#rfc.section.4.2.7">4.2.7.</a> <a href="#frame-goaway" id="frame-goaway">GOAWAY</a>
</h3>
<p id="rfc.section.4.2.7.p.1">The GOAWAY frame (type=0x7) is used to initiate graceful shutdown of a connection by a server.  GOAWAY allows a server to stop accepting new requests while still finishing processing of previously received requests.  This enables administrative actions, like server maintenance.  GOAWAY by itself does not close a connection.</p>
<p id="rfc.section.4.2.7.p.2">The GOAWAY frame does not define any flags.</p>
<div id="rfc.figure.9"></div>
<div id="fig-goaway"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Stream ID (i)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 9: GOAWAY frame payload</p>
<p id="rfc.section.4.2.7.p.3">The GOAWAY frame carries a QUIC Stream ID for a client-initiated, bidirectional stream encoded as a variable-length integer.  A client MUST treat receipt of a GOAWAY frame containing a Stream ID of any other type as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.7.p.4">Clients do not need to send GOAWAY to initiate a graceful shutdown; they simply stop making new requests.  A server MUST treat receipt of a GOAWAY frame as a connection error (<a href="#errors" class="xref">Section 6</a>) of type HTTP_UNEXPECTED_GOAWAY.</p>
<p id="rfc.section.4.2.7.p.5">The GOAWAY frame applies to the connection, not a specific stream.  An endpoint MUST treat a GOAWAY frame on a stream other than the control stream as a connection error (<a href="#errors" class="xref">Section 6</a>) of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.4.2.7.p.6">New client requests might already have been sent before the client receives the server&#8217;s GOAWAY frame.  The GOAWAY frame contains the Stream ID of the last client-initiated request that was or might be processed in this connection, which enables client and server to agree on which requests were accepted prior to the connection shutdown.  This identifier MAY be lower than the stream limit identified by a QUIC MAX_STREAM_ID frame, and MAY be zero if no requests were processed.  Servers SHOULD NOT increase the MAX_STREAM_ID limit after sending a GOAWAY frame.</p>
<p id="rfc.section.4.2.7.p.7">Once sent, the server MUST cancel requests sent on streams with an identifier higher than the included last Stream ID.  Clients MUST NOT send new requests on the connection after receiving GOAWAY, although requests might already be in transit. A new connection can be established for new requests.</p>
<p id="rfc.section.4.2.7.p.8">If the client has sent requests on streams with a higher Stream ID than indicated in the GOAWAY frame, those requests are considered cancelled (<a href="#request-cancellation" class="xref">Section 3.2.3</a>).  Clients SHOULD reset any streams above this ID with the error code HTTP_REQUEST_CANCELLED.  Servers MAY also cancel requests on streams below the indicated ID if these requests were not processed.</p>
<p id="rfc.section.4.2.7.p.9">Requests on Stream IDs less than or equal to the Stream ID in the GOAWAY frame might have been processed; their status cannot be known until they are completed successfully, reset individually, or the connection terminates.</p>
<p id="rfc.section.4.2.7.p.10">Servers SHOULD send a GOAWAY frame when the closing of a connection is known in advance, even if the advance notice is small, so that the remote peer can know whether a stream has been partially processed or not.  For example, if an HTTP client sends a POST at the same time that a server closes a QUIC connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate what streams it might have acted on.</p>
<p id="rfc.section.4.2.7.p.11">For unexpected closures caused by error conditions, a QUIC CONNECTION_CLOSE or APPLICATION_CLOSE frame MUST be used.  However, a GOAWAY MAY be sent first to provide additional detail to clients and to allow the client to retry requests.  Including the GOAWAY frame in the same packet as the QUIC CONNECTION_CLOSE or APPLICATION_CLOSE frame improves the chances of the frame being received by clients.</p>
<p id="rfc.section.4.2.7.p.12">If a connection terminates without a GOAWAY frame, the last Stream ID is effectively the highest possible Stream ID (as determined by QUIC&#8217;s MAX_STREAM_ID).</p>
<p id="rfc.section.4.2.7.p.13">An endpoint MAY send multiple GOAWAY frames if circumstances change. For instance, an endpoint that sends GOAWAY without an error code during graceful shutdown could subsequently encounter an error condition.  The last stream identifier from the last GOAWAY frame received indicates which streams could have been acted upon.  A server MUST NOT increase the value they send in the last Stream ID, since clients might already have retried unprocessed requests on another connection.</p>
<p id="rfc.section.4.2.7.p.14">A client that is unable to retry requests loses all requests that are in flight when the server closes the connection.  A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last Stream ID set to the current value of QUIC&#8217;s MAX_STREAM_ID and SHOULD NOT increase the MAX_STREAM_ID thereafter.  This signals to the client that a shutdown is imminent and that initiating further requests is prohibited.  After allowing time for any in-flight requests (at least one round-trip time), the server MAY send another GOAWAY frame with an updated last Stream ID.  This ensures that a connection can be cleanly shut down without losing requests.</p>
<p id="rfc.section.4.2.7.p.15">Once all requests on streams at or below the identified stream number have been completed or cancelled, and all promised server push responses associated with those requests have been completed or cancelled, the connection can be closed using an Immediate Close (see <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>).  An endpoint that completes a graceful shutdown SHOULD use the QUIC APPLICATION_CLOSE frame with the HTTP_NO_ERROR code.</p>
<h3 id="rfc.section.4.2.8">
<a href="#rfc.section.4.2.8">4.2.8.</a> <a href="#frame-header-ack" id="frame-header-ack">HEADER_ACK</a>
</h3>
<p id="rfc.section.4.2.8.p.1">The HEADER_ACK frame (type=0x8) is used by header compression to ensure consistency. The frames are sent from the QPACK decoder to the QPACK encoder; that is, the server sends them to the client to acknowledge processing of the client&#8217;s header blocks, and the client sends them to the server to acknowledge processing of the server&#8217;s header blocks.</p>
<p id="rfc.section.4.2.8.p.2">The HEADER_ACK frame is sent on the Control Stream when the QPACK decoder has fully processed a header block.  It is used by the peer&#8217;s QPACK encoder to determine whether subsequent indexed representations that might reference that block are vulnerable to head-of-line blocking, and to prevent eviction races.  See <a href="#QPACK" class="xref">[QPACK]</a> for more details on the use of this information.</p>
<p id="rfc.section.4.2.8.p.3">The HEADER_ACK frame indicates the stream on which the header block was processed by encoding the Stream ID as a variable-length integer. The same Stream ID can be identified multiple times, as multiple header-containing blocks can be sent on a single stream in the case of intermediate responses, trailers, pushed requests, etc. as well as on the Control Streams.  Since header frames on each stream are received and processed in order, this gives the encoder precise feedback on which header blocks within a stream have been fully processed.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|        Stream ID (i)        ...
+---+---+---+---+---+---+---+---+
</pre>
<p class="figure">HEADER_ACK frame</p>
<p id="rfc.section.4.2.8.p.4">The HEADER_ACK frame does not define any flags.</p>
<h3 id="rfc.section.4.2.9">
<a href="#rfc.section.4.2.9">4.2.9.</a> <a href="#frame-max-push-id" id="frame-max-push-id">MAX_PUSH_ID</a>
</h3>
<p id="rfc.section.4.2.9.p.1">The MAX_PUSH_ID frame (type=0xD) is used by clients to control the number of server pushes that the server can initiate.  This sets the maximum value for a Push ID that the server can use in a PUSH_PROMISE frame.  Consequently, this also limits the number of push streams that the server can initiate in addition to the limit set by the QUIC MAX_STREAM_ID frame.</p>
<p id="rfc.section.4.2.9.p.2">The MAX_PUSH_ID frame is always sent on a control stream.  Receipt of a MAX_PUSH_ID frame on any other stream MUST be treated as a connection error of type HTTP_WRONG_STREAM.</p>
<p id="rfc.section.4.2.9.p.3">A server MUST NOT send a MAX_PUSH_ID frame.  A client MUST treat the receipt of a MAX_PUSH_ID frame as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.9.p.4">The maximum Push ID is unset when a connection is created, meaning that a server cannot push until it receives a MAX_PUSH_ID frame.  A client that wishes to manage the number of promised server pushes can increase the maximum Push ID by sending a MAX_PUSH_ID frame as the server fulfills or cancels server pushes.</p>
<p id="rfc.section.4.2.9.p.5">The MAX_PUSH_ID frame has no defined flags.</p>
<div id="rfc.figure.10"></div>
<div id="fig-max-push"></div>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Push ID (i)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 10: MAX_PUSH_ID frame payload</p>
<p id="rfc.section.4.2.9.p.6">The MAX_PUSH_ID frame carries a single variable-length integer that identifies the maximum value for a Push ID that the server can use (see <a href="#frame-push-promise" class="xref">Section 4.2.6</a>).  A MAX_PUSH_ID frame cannot reduce the maximum Push ID; receipt of a MAX_PUSH_ID that contains a smaller value than previously received MUST be treated as a connection error of type HTTP_MALFORMED_FRAME.</p>
<p id="rfc.section.4.2.9.p.7">A server MUST treat a MAX_PUSH_ID frame payload that does not contain a single variable-length integer as a connection error of type HTTP_MALFORMED_FRAME.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#connection-management" id="connection-management">Connection Management</a>
</h1>
<p id="rfc.section.5.p.1">QUIC connections are persistent.  All of the considerations in Section 9.1 of <a href="#RFC7540" class="xref">[RFC7540]</a> apply to the management of QUIC connections.</p>
<p id="rfc.section.5.p.2">HTTP clients are expected to use QUIC PING frames to keep connections open.  Servers SHOULD NOT use PING frames to keep a connection open.  A client SHOULD NOT use PING frames for this purpose unless there are responses outstanding for requests or server pushes.  If the client is not expecting a response from the server, allowing an idle connection to time out (based on the idle_timeout transport parameter) is preferred over expending effort maintaining a connection that might not be needed.  A gateway MAY use PING to maintain connections in anticipation of need rather than incur the latency cost of connection establishment to servers.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#errors" id="errors">Error Handling</a>
</h1>
<p id="rfc.section.6.p.1">QUIC allows the application to abruptly terminate (reset) individual streams or the entire connection when an error is encountered.  These are referred to as &#8220;stream errors&#8221; or &#8220;connection errors&#8221; and are described in more detail in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.</p>
<p id="rfc.section.6.p.2">This section describes HTTP-specific error codes which can be used to express the cause of a connection or stream error.</p>
<h2 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#http-error-codes" id="http-error-codes">HTTP/QUIC Error Codes</a>
</h2>
<p id="rfc.section.6.1.p.1">The following error codes are defined for use in QUIC RST_STREAM, STOP_SENDING, and CONNECTION_CLOSE frames when using HTTP/QUIC.</p>
<p></p>

<dl>
<dt>STOPPING (0x00):</dt>
<dd style="margin-left: 8">This value is reserved by the transport to be used in response to QUIC STOP_SENDING frames.</dd>
<dt>HTTP_NO_ERROR (0x01):</dt>
<dd style="margin-left: 8">No error.  This is used when the connection or stream needs to be closed, but there is no error to signal.</dd>
<dt>HTTP_PUSH_REFUSED (0x02):</dt>
<dd style="margin-left: 8">The server has attempted to push content which the client will not accept on this connection.</dd>
<dt>HTTP_INTERNAL_ERROR (0x03):</dt>
<dd style="margin-left: 8">An internal error has occurred in the HTTP stack.</dd>
<dt>HTTP_PUSH_ALREADY_IN_CACHE (0x04):</dt>
<dd style="margin-left: 8">The server has attempted to push content which the client has cached.</dd>
<dt>HTTP_REQUEST_CANCELLED (0x05):</dt>
<dd style="margin-left: 8">The client no longer needs the requested data.</dd>
<dt>HTTP_HPACK_DECOMPRESSION_FAILED (0x06):</dt>
<dd style="margin-left: 8">HPACK failed to decompress a frame and cannot continue.</dd>
<dt>HTTP_CONNECT_ERROR (0x07):</dt>
<dd style="margin-left: 8">The connection established in response to a CONNECT request was reset or abnormally closed.</dd>
<dt>HTTP_EXCESSIVE_LOAD (0x08):</dt>
<dd style="margin-left: 8">The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.</dd>
<dt>HTTP_VERSION_FALLBACK (0x09):</dt>
<dd style="margin-left: 8">The requested operation cannot be served over HTTP/QUIC.  The peer should retry over HTTP/2.</dd>
<dt>HTTP_WRONG_STREAM (0x0A):</dt>
<dd style="margin-left: 8">A frame was received on stream where it is not permitted.</dd>
<dt>HTTP_PUSH_LIMIT_EXCEEDED (0x0B):</dt>
<dd style="margin-left: 8">A Push ID greater than the current maximum Push ID was referenced.</dd>
<dt>HTTP_DUPLICATE_PUSH (0x0C):</dt>
<dd style="margin-left: 8">A Push ID was referenced in two different stream headers.</dd>
<dt>HTTP_MALFORMED_FRAME (0x01XX):</dt>
<dd style="margin-left: 8">An error in a specific frame type.  The frame type is included as the last octet of the error code.  For example, an error in a MAX_PUSH_ID frame would be indicated with the code (0x10D).</dd>
</dl>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#considerations-for-transitioning-from-http2" id="considerations-for-transitioning-from-http2">Considerations for Transitioning from HTTP/2</a>
</h1>
<p id="rfc.section.7.p.1">HTTP/QUIC is strongly informed by HTTP/2, and bears many similarities.  This section describes the approach taken to design HTTP/QUIC, points out important differences from HTTP/2, and describes how to map HTTP/2 extensions into HTTP/QUIC.</p>
<p id="rfc.section.7.p.2">HTTP/QUIC begins from the premise that HTTP/2 code reuse is a useful feature, but not a hard requirement.  HTTP/QUIC departs from HTTP/2 primarily where necessary to accommodate the differences in behavior between QUIC and TCP (lack of ordering, support for streams).  We intend to avoid gratuitous changes which make it difficult or impossible to build extensions with the same semantics applicable to both protocols at once.</p>
<p id="rfc.section.7.p.3">These departures are noted in this section.</p>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#h2-streams" id="h2-streams">Streams</a>
</h2>
<p id="rfc.section.7.1.p.1">HTTP/QUIC permits use of a larger number of streams (2^62-1) than HTTP/2.  The considerations about exhaustion of stream identifier space apply, though the space is significantly larger such that it is likely that other limits in QUIC are reached first, such as the limit on the connection flow control window.</p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#h2-frames" id="h2-frames">HTTP Frame Types</a>
</h2>
<p id="rfc.section.7.2.p.1">Many framing concepts from HTTP/2 can be elided away on QUIC, because the transport deals with them. Because frames are already on a stream, they can omit the stream number. Because frames do not block multiplexing (QUIC&#8217;s multiplexing occurs below this layer), the support for variable-maximum-length packets can be removed. Because stream termination is handled by QUIC, an END_STREAM flag is not required.</p>
<p id="rfc.section.7.2.p.2">Frame payloads are largely drawn from <a href="#RFC7540" class="xref">[RFC7540]</a>. However, QUIC includes many features (e.g. flow control) which are also present in HTTP/2. In these cases, the HTTP mapping does not re-implement them. As a result, several HTTP/2 frame types are not required in HTTP/QUIC. Where an HTTP/2-defined frame is no longer used, the frame ID has been reserved in order to maximize portability between HTTP/2 and HTTP/QUIC implementations. However, even equivalent frames between the two mappings are not identical.</p>
<p id="rfc.section.7.2.p.3">Many of the differences arise from the fact that HTTP/2 provides an absolute ordering between frames across all streams, while QUIC provides this guarantee on each stream only.  As a result, if a frame type makes assumptions that frames from different streams will still be received in the order sent, HTTP/QUIC will break them.</p>
<p id="rfc.section.7.2.p.4">For example, implicit in the HTTP/2 prioritization scheme is the notion of in-order delivery of priority changes (i.e., dependency tree mutations): since operations on the dependency tree such as reparenting a subtree are not commutative, both sender and receiver must apply them in the same order to ensure that both sides have a consistent view of the stream dependency tree.  HTTP/2 specifies priority assignments in PRIORITY frames and (optionally) in HEADERS frames. To achieve in-order delivery of priority changes in HTTP/QUIC, PRIORITY frames are sent on the control stream and the PRIORITY section is removed from the HEADERS frame.</p>
<p id="rfc.section.7.2.p.5">Likewise, HPACK was designed with the assumption of in-order delivery. A sequence of encoded header blocks must arrive (and be decoded) at an endpoint in the same order in which they were encoded. This ensures that the dynamic state at the two endpoints remains in sync.  As a result, HTTP/QUIC uses a modified version of HPACK, described in <a href="#QPACK" class="xref">[QPACK]</a>.</p>
<p id="rfc.section.7.2.p.6">Frame type definitions in HTTP/QUIC often use the QUIC variable-length integer encoding.  In particular, Stream IDs use this encoding, which allow for a larger range of possible values than the encoding used in HTTP/2.  Some frames in HTTP/QUIC use an identifier rather than a Stream ID (e.g. Push IDs in PRIORITY frames). Redefinition of the encoding of extension frame types might be necessary if the encoding includes a Stream ID.</p>
<p id="rfc.section.7.2.p.7">Other than this issue, frame type HTTP/2 extensions are typically portable to QUIC simply by replacing Stream 0 in HTTP/2 with Stream 2 or 3 in HTTP/QUIC.  HTTP/QUIC extensions will not assume ordering, but would not be harmed by ordering, and would be portable to HTTP/2 in the same manner.</p>
<p id="rfc.section.7.2.p.8">Below is a listing of how each HTTP/2 frame type is mapped:</p>
<p></p>

<dl>
<dt>DATA (0x0):</dt>
<dd style="margin-left: 8">Padding is not defined in HTTP/QUIC frames.  See <a href="#frame-data" class="xref">Section 4.2.1</a>.</dd>
<dt>HEADERS (0x1):</dt>
<dd style="margin-left: 8">As described above, the PRIORITY region of HEADERS is not supported. A separate PRIORITY frame MUST be used. Padding is not defined in HTTP/QUIC frames.  See <a href="#frame-headers" class="xref">Section 4.2.2</a>.</dd>
<dt>PRIORITY (0x2):</dt>
<dd style="margin-left: 8">As described above, the PRIORITY frame is sent on the control stream and can reference either a Stream ID or a Push ID.  See <a href="#frame-priority" class="xref">Section 4.2.3</a>.</dd>
<dt>RST_STREAM (0x3):</dt>
<dd style="margin-left: 8">RST_STREAM frames do not exist, since QUIC provides stream lifecycle management.  The same code point is used for the CANCEL_PUSH frame (<a href="#frame-cancel-push" class="xref">Section 4.2.4</a>).</dd>
<dt>SETTINGS (0x4):</dt>
<dd style="margin-left: 8">SETTINGS frames are sent only at the beginning of the connection.  See <a href="#frame-settings" class="xref">Section 4.2.5</a> and <a href="#h2-settings" class="xref">Section 7.3</a>.</dd>
<dt>PUSH_PROMISE (0x5):</dt>
<dd style="margin-left: 8">The PUSH_PROMISE does not reference a stream; instead the push stream references the PUSH_PROMISE frame using a Push ID.  See <a href="#frame-push-promise" class="xref">Section 4.2.6</a>.</dd>
<dt>PING (0x6):</dt>
<dd style="margin-left: 8">PING frames do not exist, since QUIC provides equivalent functionality.</dd>
<dt>GOAWAY (0x7):</dt>
<dd style="margin-left: 8">GOAWAY is sent only from server to client and does not contain an error code.  See <a href="#frame-goaway" class="xref">Section 4.2.7</a>.</dd>
<dt>WINDOW_UPDATE (0x8):</dt>
<dd style="margin-left: 8">WINDOW_UPDATE frames do not exist, since QUIC provides flow control.</dd>
<dt>CONTINUATION (0x9):</dt>
<dd style="margin-left: 8">CONTINUATION frames do not exist; instead, larger HEADERS/PUSH_PROMISE frames than HTTP/2 are permitted, and HEADERS frames can be used in series.</dd>
</dl>
<p id="rfc.section.7.2.p.10">Frame types defined by extensions to HTTP/2 need to be separately registered for HTTP/QUIC if still applicable.  The IDs of frames defined in <a href="#RFC7540" class="xref">[RFC7540]</a> have been reserved for simplicity.  See <a href="#iana-frames" class="xref">Section 9.3</a>.</p>
<h2 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#h2-settings" id="h2-settings">HTTP/2 SETTINGS Parameters</a>
</h2>
<p id="rfc.section.7.3.p.1">An important difference from HTTP/2 is that settings are sent once, at the beginning of the connection, and thereafter cannot change.  This eliminates many corner cases around synchronization of changes.</p>
<p id="rfc.section.7.3.p.2">Some transport-level options that HTTP/2 specifies via the SETTINGS frame are superseded by QUIC transport parameters in HTTP/QUIC. The HTTP-level options that are retained in HTTP/QUIC have the same value as in HTTP/2.</p>
<p id="rfc.section.7.3.p.3">Below is a listing of how each HTTP/2 SETTINGS parameter is mapped:</p>
<p></p>

<dl>
<dt>SETTINGS_HEADER_TABLE_SIZE:</dt>
<dd style="margin-left: 8">See <a href="#settings-parameters" class="xref">Section 4.2.5.2</a>.</dd>
<dt>SETTINGS_ENABLE_PUSH:</dt>
<dd style="margin-left: 8">This is removed in favor of the MAX_PUSH_ID which provides a more granular control over server push.</dd>
<dt>SETTINGS_MAX_CONCURRENT_STREAMS:</dt>
<dd style="margin-left: 8">QUIC controls the largest open Stream ID as part of its flow control logic.  Specifying SETTINGS_MAX_CONCURRENT_STREAMS in the SETTINGS frame is an error.</dd>
<dt>SETTINGS_INITIAL_WINDOW_SIZE:</dt>
<dd style="margin-left: 8">QUIC requires both stream and connection flow control window sizes to be specified in the initial transport handshake.  Specifying SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame is an error.</dd>
<dt>SETTINGS_MAX_FRAME_SIZE:</dt>
<dd style="margin-left: 8">This setting has no equivalent in HTTP/QUIC.  Specifying it in the SETTINGS frame is an error.</dd>
<dt>SETTINGS_MAX_HEADER_LIST_SIZE:</dt>
<dd style="margin-left: 8">See <a href="#settings-parameters" class="xref">Section 4.2.5.2</a>.</dd>
</dl>
<p id="rfc.section.7.3.p.5">Settings need to be defined separately for HTTP/2 and HTTP/QUIC.  The IDs of settings defined in <a href="#RFC7540" class="xref">[RFC7540]</a> have been reserved for simplicity.  See <a href="#iana-settings" class="xref">Section 9.4</a>.</p>
<h2 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#http2-error-codes" id="http2-error-codes">HTTP/2 Error Codes</a>
</h2>
<p id="rfc.section.7.4.p.1">QUIC has the same concepts of &#8220;stream&#8221; and &#8220;connection&#8221; errors that HTTP/2 provides. However, because the error code space is shared between multiple components, there is no direct portability of HTTP/2 error codes.</p>
<p id="rfc.section.7.4.p.2">The HTTP/2 error codes defined in Section 7 of <a href="#RFC7540" class="xref">[RFC7540]</a> map to the HTTP over QUIC error codes as follows:</p>
<p></p>

<dl>
<dt>NO_ERROR (0x0):</dt>
<dd style="margin-left: 8">HTTP_NO_ERROR in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>PROTOCOL_ERROR (0x1):</dt>
<dd style="margin-left: 8">No single mapping.  See new HTTP_MALFORMED_FRAME error codes defined in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>INTERNAL_ERROR (0x2):</dt>
<dd style="margin-left: 8">HTTP_INTERNAL_ERROR in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>FLOW_CONTROL_ERROR (0x3):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC handles flow control.  Would provoke a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA from the QUIC layer.</dd>
<dt>SETTINGS_TIMEOUT (0x4):</dt>
<dd style="margin-left: 8">Not applicable, since no acknowledgement of SETTINGS is defined.</dd>
<dt>STREAM_CLOSED (0x5):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC handles stream management.  Would provoke a QUIC_STREAM_DATA_AFTER_TERMINATION from the QUIC layer.</dd>
<dt>FRAME_SIZE_ERROR (0x6)</dt>
<dd style="margin-left: 8">No single mapping.  See new error codes defined in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>REFUSED_STREAM (0x7):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC handles stream management.  Would provoke a QUIC_TOO_MANY_OPEN_STREAMS from the QUIC layer.</dd>
<dt>CANCEL (0x8):</dt>
<dd style="margin-left: 8">HTTP_REQUEST_CANCELLED in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>COMPRESSION_ERROR (0x9):</dt>
<dd style="margin-left: 8">HTTP_HPACK_DECOMPRESSION_FAILED in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>CONNECT_ERROR (0xa):</dt>
<dd style="margin-left: 8">HTTP_CONNECT_ERROR in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>ENHANCE_YOUR_CALM (0xb):</dt>
<dd style="margin-left: 8">HTTP_EXCESSIVE_LOAD in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
<dt>INADEQUATE_SECURITY (0xc):</dt>
<dd style="margin-left: 8">Not applicable, since QUIC is assumed to provide sufficient security on all connections.</dd>
<dt>HTTP_1_1_REQUIRED (0xd):</dt>
<dd style="margin-left: 8">HTTP_VERSION_FALLBACK in <a href="#http-error-codes" class="xref">Section 6.1</a>.</dd>
</dl>
<p id="rfc.section.7.4.p.4">Error codes need to be defined for HTTP/2 and HTTP/QUIC separately.  See <a href="#iana-error-codes" class="xref">Section 9.5</a>.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">The security considerations of HTTP over QUIC should be comparable to those of HTTP/2.</p>
<p id="rfc.section.8.p.2">The modified SETTINGS format contains nested length elements, which could pose a security risk to an uncautious implementer.  A SETTINGS frame parser MUST ensure that the length of the frame exactly matches the length of the settings it contains.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h2 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#registration-of-httpquic-identification-string" id="registration-of-httpquic-identification-string">Registration of HTTP/QUIC Identification String</a>
</h2>
<p id="rfc.section.9.1.p.1">This document creates a new registration for the identification of HTTP/QUIC in the &#8220;Application Layer Protocol Negotiation (ALPN) Protocol IDs&#8221; registry established in <a href="#RFC7301" class="xref">[RFC7301]</a>.</p>
<p id="rfc.section.9.1.p.2">The &#8220;hq&#8221; string identifies HTTP/QUIC:</p>
<p></p>

<dl>
<dt>Protocol:</dt>
<dd style="margin-left: 8">HTTP over QUIC</dd>
<dt>Identification Sequence:</dt>
<dd style="margin-left: 8">0x68 0x71 (&#8220;hq&#8221;)</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">This document</dd>
</dl>
<h2 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#registration-of-quic-version-hint-alt-svc-parameter" id="registration-of-quic-version-hint-alt-svc-parameter">Registration of QUIC Version Hint Alt-Svc Parameter</a>
</h2>
<p id="rfc.section.9.2.p.1">This document creates a new registration for version-negotiation hints in the &#8220;Hypertext Transfer Protocol (HTTP) Alt-Svc Parameter&#8221; registry established in <a href="#RFC7838" class="xref">[RFC7838]</a>.</p>
<p></p>

<dl>
<dt>Parameter:</dt>
<dd style="margin-left: 8">&#8220;quic&#8221;</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">This document, <a href="#alt-svc-version-hint" class="xref">Section 2.1.1</a>
</dd>
</dl>
<h2 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#iana-frames" id="iana-frames">Frame Types</a>
</h2>
<p id="rfc.section.9.3.p.1">This document establishes a registry for HTTP/QUIC frame type codes. The &#8220;HTTP/QUIC Frame Type&#8221; registry manages an 8-bit space.  The &#8220;HTTP/QUIC Frame Type&#8221; registry operates under either of the &#8220;IETF Review&#8221; or &#8220;IESG Approval&#8221; policies <a href="#RFC8126" class="xref">[RFC8126]</a> for values between 0x00 and 0xef, with values between 0xf0 and 0xff being reserved for Experimental Use.</p>
<p id="rfc.section.9.3.p.2">While this registry is separate from the &#8220;HTTP/2 Frame Type&#8221; registry defined in <a href="#RFC7540" class="xref">[RFC7540]</a>, it is preferable that the assignments parallel each other.  If an entry is present in only one registry, every effort SHOULD be made to avoid assigning the corresponding value to an unrelated operation.</p>
<p id="rfc.section.9.3.p.3">New entries in this registry require the following information:</p>
<p></p>

<dl>
<dt>Frame Type:</dt>
<dd style="margin-left: 8">A name or label for the frame type.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 8-bit code assigned to the frame type.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">A reference to a specification that includes a description of the frame layout, its semantics, and flags that the frame type uses, including any parts of the frame that are conditionally present based on the value of flags.</dd>
</dl>
<p id="rfc.section.9.3.p.5">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Frame Type</th>
<th class="center">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">DATA</td>
<td class="center">0x0</td>
<td class="left"><a href="#frame-data" class="xref">Section 4.2.1</a></td>
</tr>
<tr>
<td class="left">HEADERS</td>
<td class="center">0x1</td>
<td class="left"><a href="#frame-headers" class="xref">Section 4.2.2</a></td>
</tr>
<tr>
<td class="left">PRIORITY</td>
<td class="center">0x2</td>
<td class="left"><a href="#frame-priority" class="xref">Section 4.2.3</a></td>
</tr>
<tr>
<td class="left">CANCEL_PUSH</td>
<td class="center">0x3</td>
<td class="left"><a href="#frame-cancel-push" class="xref">Section 4.2.4</a></td>
</tr>
<tr>
<td class="left">SETTINGS</td>
<td class="center">0x4</td>
<td class="left"><a href="#frame-settings" class="xref">Section 4.2.5</a></td>
</tr>
<tr>
<td class="left">PUSH_PROMISE</td>
<td class="center">0x5</td>
<td class="left"><a href="#frame-push-promise" class="xref">Section 4.2.6</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x6</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">GOAWAY</td>
<td class="center">0x7</td>
<td class="left"><a href="#frame-goaway" class="xref">Section 4.2.7</a></td>
</tr>
<tr>
<td class="left">HEADER_ACK</td>
<td class="center">0x8</td>
<td class="left"><a href="#frame-header-ack" class="xref">Section 4.2.8</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x9</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">MAX_PUSH_ID</td>
<td class="center">0xD</td>
<td class="left"><a href="#frame-max-push-id" class="xref">Section 4.2.9</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#iana-settings" id="iana-settings">Settings Parameters</a>
</h2>
<p id="rfc.section.9.4.p.1">This document establishes a registry for HTTP/QUIC settings.  The &#8220;HTTP/QUIC Settings&#8221; registry manages a 16-bit space.  The &#8220;HTTP/QUIC Settings&#8221; registry operates under the &#8220;Expert Review&#8221; policy <a href="#RFC8126" class="xref">[RFC8126]</a> for values in the range from 0x0000 to 0xefff, with values between and 0xf000 and 0xffff being reserved for Experimental Use.  The designated experts are the same as those for the &#8220;HTTP/2 Settings&#8221; registry defined in <a href="#RFC7540" class="xref">[RFC7540]</a>.</p>
<p id="rfc.section.9.4.p.2">While this registry is separate from the &#8220;HTTP/2 Settings&#8221; registry defined in <a href="#RFC7540" class="xref">[RFC7540]</a>, it is preferable that the assignments parallel each other.  If an entry is present in only one registry, every effort SHOULD be made to avoid assigning the corresponding value to an unrelated operation.</p>
<p id="rfc.section.9.4.p.3">New registrations are advised to provide the following information:</p>
<p></p>

<dl>
<dt>Name:</dt>
<dd style="margin-left: 8">A symbolic name for the setting.  Specifying a setting name is optional.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 16-bit code assigned to the setting.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">An optional reference to a specification that describes the use of the setting.</dd>
</dl>
<p id="rfc.section.9.4.p.5">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Setting Name</th>
<th class="center">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">HEADER_TABLE_SIZE</td>
<td class="center">0x1</td>
<td class="left"><a href="#settings-parameters" class="xref">Section 4.2.5.2</a></td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x2</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x3</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x4</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">Reserved</td>
<td class="center">0x5</td>
<td class="left">N/A</td>
</tr>
<tr>
<td class="left">MAX_HEADER_LIST_SIZE</td>
<td class="center">0x6</td>
<td class="left"><a href="#settings-parameters" class="xref">Section 4.2.5.2</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#iana-error-codes" id="iana-error-codes">Error Codes</a>
</h2>
<p id="rfc.section.9.5.p.1">This document establishes a registry for HTTP/QUIC error codes.  The &#8220;HTTP/QUIC Error Code&#8221; registry manages a 16-bit space.  The &#8220;HTTP/QUIC Error Code&#8221; registry operates under the &#8220;Expert Review&#8221; policy <a href="#RFC8126" class="xref">[RFC8126]</a>.</p>
<p id="rfc.section.9.5.p.2">Registrations for error codes are required to include a description of the error code.  An expert reviewer is advised to examine new registrations for possible duplication with existing error codes.  Use of existing registrations is to be encouraged, but not mandated.</p>
<p id="rfc.section.9.5.p.3">New registrations are advised to provide the following information:</p>
<p></p>

<dl>
<dt>Name:</dt>
<dd style="margin-left: 8">A name for the error code.  Specifying an error code name is optional.</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">The 16-bit error code value.</dd>
<dt>Description:</dt>
<dd style="margin-left: 8">A brief description of the error code semantics, longer if no detailed specification is provided.</dd>
<dt>Specification:</dt>
<dd style="margin-left: 8">An optional reference for a specification that defines the error code.</dd>
</dl>
<p id="rfc.section.9.5.p.5">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Name</th>
<th class="left">Code</th>
<th class="left">Description</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">STOPPING</td>
<td class="left">0x0000</td>
<td class="left">Reserved by QUIC</td>
<td class="left"><a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a></td>
</tr>
<tr>
<td class="left">HTTP_NO_ERROR</td>
<td class="left">0x0001</td>
<td class="left">No error</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_PUSH_REFUSED</td>
<td class="left">0x0002</td>
<td class="left">Client refused pushed content</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_INTERNAL_ERROR</td>
<td class="left">0x0003</td>
<td class="left">Internal error</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_PUSH_ALREADY_IN_CACHE</td>
<td class="left">0x0004</td>
<td class="left">Pushed content already cached</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_REQUEST_CANCELLED</td>
<td class="left">0x0005</td>
<td class="left">Data no longer needed</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_HPACK_DECOMPRESSION_FAILED</td>
<td class="left">0x0006</td>
<td class="left">HPACK cannot continue</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_CONNECT_ERROR</td>
<td class="left">0x0007</td>
<td class="left">TCP reset or error on CONNECT request</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_EXCESSIVE_LOAD</td>
<td class="left">0x0008</td>
<td class="left">Peer generating excessive load</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_VERSION_FALLBACK</td>
<td class="left">0x0009</td>
<td class="left">Retry over HTTP/2</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_WRONG_STREAM</td>
<td class="left">0x000A</td>
<td class="left">A frame was sent on the wrong stream</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_PUSH_LIMIT_EXCEEDED</td>
<td class="left">0x000B</td>
<td class="left">Maximum Push ID exceeded</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_DUPLICATE_PUSH</td>
<td class="left">0x000C</td>
<td class="left">Push ID was fulfilled multiple times</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
<tr>
<td class="left">HTTP_MALFORMED_FRAME</td>
<td class="left">0x01XX</td>
<td class="left">Error in frame formatting or use</td>
<td class="left"><a href="#http-error-codes" class="xref">Section 6.1</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="QPACK">[QPACK]</b></td>
<td class="top">
<a title="Google, Inc">Krasic, C.</a>, <a title="Akamai Technologies">Bishop, M.</a> and <a title="Facebook">A. Frindell</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-qpack">QPACK: Header Compression for HTTP over QUIC</a>", Internet-Draft draft-ietf-quic-qpack, April 2018.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, April 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, "<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7838">[RFC7838]</b></td>
<td class="top">
<a>Nottingham, M.</a>, <a>McManus, P.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7838">HTTP Alternative Services</a>", RFC 7838, DOI 10.17487/RFC7838, April 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="RFC7301">[RFC7301]</b></td>
<td class="top">
<a>Friedl, S.</a>, <a>Popov, A.</a>, <a>Langley, A.</a> and <a>E. Stephan</a>, "<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>", RFC 7301, DOI 10.17487/RFC7301, July 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8126">[RFC8126]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Leiba, B.</a> and <a>T. Narten</a>, "<a href="https://tools.ietf.org/html/rfc8126">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p id="rfc.section.A.p.1">The original authors of this specification were Robbie Shade and Mike Warres.</p>
<p id="rfc.section.A.p.2">A substantial portion of Mike&#8217;s contribution was supported by Microsoft during his employment there.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li></ul>
<h2 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#since-draft-ietf-quic-http-09" id="since-draft-ietf-quic-http-09">Since draft-ietf-quic-http-09</a>
</h2>
<p></p>

<ul>
<li>Selected QCRAM for header compression (#228, #1117)</li>
<li>The server_name TLS extension is now mandatory (#296, #495)</li>
<li>Specified handling of unsupported versions in Alt-Svc (#1093, #1097)</li>
</ul>
<h2 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#since-draft-ietf-quic-http-08" id="since-draft-ietf-quic-http-08">Since draft-ietf-quic-http-08</a>
</h2>
<p></p>

<ul><li>Clarified connection coalescing rules (#940, #1024)</li></ul>
<h2 id="rfc.appendix.B.3">
<a href="#rfc.appendix.B.3">B.3.</a> <a href="#since-draft-ietf-quic-http-07" id="since-draft-ietf-quic-http-07">Since draft-ietf-quic-http-07</a>
</h2>
<p></p>

<ul>
<li>Changes for integer encodings in QUIC (#595,#905)</li>
<li>Use unidirectional streams as appropriate (#515, #240, #281, #886)</li>
<li>Improvement to the description of GOAWAY (#604, #898)</li>
<li>Improve description of server push usage (#947, #950, #957)</li>
</ul>
<h2 id="rfc.appendix.B.4">
<a href="#rfc.appendix.B.4">B.4.</a> <a href="#since-draft-ietf-quic-http-06" id="since-draft-ietf-quic-http-06">Since draft-ietf-quic-http-06</a>
</h2>
<p></p>

<ul><li>Track changes in QUIC error code usage (#485)</li></ul>
<h2 id="rfc.appendix.B.5">
<a href="#rfc.appendix.B.5">B.5.</a> <a href="#since-draft-ietf-quic-http-05" id="since-draft-ietf-quic-http-05">Since draft-ietf-quic-http-05</a>
</h2>
<p></p>

<ul>
<li>Made push ID sequential, add MAX_PUSH_ID, remove SETTINGS_ENABLE_PUSH (#709)</li>
<li>Guidance about keep-alive and QUIC PINGs (#729)</li>
<li>Expanded text on GOAWAY and cancellation (#757)</li>
</ul>
<h2 id="rfc.appendix.B.6">
<a href="#rfc.appendix.B.6">B.6.</a> <a href="#since-draft-ietf-quic-http-04" id="since-draft-ietf-quic-http-04">Since draft-ietf-quic-http-04</a>
</h2>
<p></p>

<ul>
<li>Cite RFC 5234 (#404)</li>
<li>Return to a single stream per request (#245,#557)</li>
<li>Use separate frame type and settings registries from HTTP/2 (#81)</li>
<li>SETTINGS_ENABLE_PUSH instead of SETTINGS_DISABLE_PUSH (#477)</li>
<li>Restored GOAWAY (#696)</li>
<li>Identify server push using Push ID rather than a stream ID (#702,#281)</li>
<li>DATA frames cannot be empty (#700)</li>
</ul>
<h2 id="rfc.appendix.B.7">
<a href="#rfc.appendix.B.7">B.7.</a> <a href="#since-draft-ietf-quic-http-03" id="since-draft-ietf-quic-http-03">Since draft-ietf-quic-http-03</a>
</h2>
<p id="rfc.section.B.7.p.1">None.</p>
<h2 id="rfc.appendix.B.8">
<a href="#rfc.appendix.B.8">B.8.</a> <a href="#since-draft-ietf-quic-http-02" id="since-draft-ietf-quic-http-02">Since draft-ietf-quic-http-02</a>
</h2>
<p></p>

<ul><li>Track changes in transport draft</li></ul>
<h2 id="rfc.appendix.B.9">
<a href="#rfc.appendix.B.9">B.9.</a> <a href="#since-draft-ietf-quic-http-01" id="since-draft-ietf-quic-http-01">Since draft-ietf-quic-http-01</a>
</h2>
<p></p>

<ul>
<li>SETTINGS changes (#181): <ul>
<li>SETTINGS can be sent only once at the start of a connection; no changes thereafter</li>
<li>SETTINGS_ACK removed</li>
<li>Settings can only occur in the SETTINGS frame a single time</li>
<li>Boolean format updated</li>
</ul>
</li>
<li>Alt-Svc parameter changed from &#8220;v&#8221; to &#8220;quic&#8221;; format updated (#229)</li>
<li>Closing the connection control stream or any message control stream is a fatal error (#176)</li>
<li>HPACK Sequence counter can wrap (#173)</li>
<li>0-RTT guidance added</li>
<li>Guide to differences from HTTP/2 and porting HTTP/2 extensions added (#127,#242)</li>
</ul>
<h2 id="rfc.appendix.B.10">
<a href="#rfc.appendix.B.10">B.10.</a> <a href="#since-draft-ietf-quic-http-00" id="since-draft-ietf-quic-http-00">Since draft-ietf-quic-http-00</a>
</h2>
<p></p>

<ul>
<li>Changed &#8220;HTTP/2-over-QUIC&#8221; to &#8220;HTTP/QUIC&#8221; throughout (#11,#29)</li>
<li>Changed from using HTTP/2 framing within Stream 3 to new framing format and two-stream-per-request model (#71,#72,#73)</li>
<li>Adopted SETTINGS format from draft-bishop-httpbis-extended-settings-01</li>
<li>Reworked SETTINGS_ACK to account for indeterminate inter-stream order (#75)</li>
<li>Described CONNECT pseudo-method (#95)</li>
<li>Updated ALPN token and Alt-Svc guidance (#13,#87)</li>
<li>Application-layer-defined error codes (#19,#74)</li>
</ul>
<h2 id="rfc.appendix.B.11">
<a href="#rfc.appendix.B.11">B.11.</a> <a href="#since-draft-shade-quic-http2-mapping-00" id="since-draft-shade-quic-http2-mapping-00">Since draft-shade-quic-http2-mapping-00</a>
</h2>
<p></p>

<ul>
<li>Adopted as base for draft-ietf-quic-http</li>
<li>Updated authors/editors list</li>
</ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></span>

  </address>
</div>

</body>
</html>
