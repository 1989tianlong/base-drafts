<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Notational Conventions"/>
<link href="#rfc.section.3" rel="Chapter" title="3 A QUIC Overview"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Low-Latency Connection Establishment"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Stream Multiplexing"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Rich Signaling for Congestion Control and Loss Recovery"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Stream and Connection Flow Control"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Authenticated and Encrypted Header and Payload"/>
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Connection Migration and Resilience to NAT Rebinding"/>
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Version Negotiation"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Versions"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Packet Types and Formats"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Common Header"/>
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Identifying Packet Types"/>
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Handling Packets from Different Versions"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Regular Packets"/>
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Packet Number Compression and Reconstruction"/>
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Frames and Frame Types"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Version Negotiation Packet"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Public Reset Packet"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Life of a Connection"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Version Negotiation"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Crypto and Transport Handshake"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Transport Parameters and Options"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Proof of Source Address Ownership"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 Crypto Handshake Protocol Features"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 Version Negotiation Validation"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Connection Migration"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Connection Termination"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Frame Types and Formats"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 STREAM Frame"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 ACK Frame"/>
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Ack Block Section"/>
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Timestamp Section"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 STOP_WAITING Frame"/>
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 WINDOW_UPDATE Frame"/>
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 BLOCKED Frame"/>
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 RST_STREAM Frame"/>
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 PADDING Frame"/>
<link href="#rfc.section.7.8" rel="Chapter" title="7.8 PING frame"/>
<link href="#rfc.section.7.9" rel="Chapter" title="7.9 CONNECTION_CLOSE frame"/>
<link href="#rfc.section.7.10" rel="Chapter" title="7.10 GOAWAY Frame"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Packetization and Reliability"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Streams: QUIC&#x2019;s Data Structuring Abstraction"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Life of a Stream"/>
<link href="#rfc.section.9.1.1" rel="Chapter" title="9.1.1 idle"/>
<link href="#rfc.section.9.1.2" rel="Chapter" title="9.1.2 reserved"/>
<link href="#rfc.section.9.1.3" rel="Chapter" title="9.1.3 open"/>
<link href="#rfc.section.9.1.4" rel="Chapter" title="9.1.4 half-closed (local)"/>
<link href="#rfc.section.9.1.5" rel="Chapter" title="9.1.5 half-closed (remote)"/>
<link href="#rfc.section.9.1.6" rel="Chapter" title="9.1.6 closed"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Stream Identifiers"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Stream Concurrency"/>
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Sending and Receiving Data"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Flow Control"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Edge Cases and Other Considerations"/>
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 Mid-stream RST_STREAM"/>
<link href="#rfc.section.10.1.2" rel="Chapter" title="10.1.2 Response to a RST_STREAM"/>
<link href="#rfc.section.10.1.3" rel="Chapter" title="10.1.3 Offset Increment"/>
<link href="#rfc.section.10.1.4" rel="Chapter" title="10.1.4 BLOCKED frames"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Error Codes"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Security and Privacy Considerations"/>
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Spoofed Ack Attack"/>
<link href="#rfc.section.13" rel="Chapter" title="13 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="14 References"/>
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Contributors"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Acknowledgments"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Change Log"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Since draft-ietf-quic-transport-00:"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Since draft-hamilton-quic-transport-protocol-01:"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Iyengar, J., Ed. and M. Thomson, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-transport-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-2-8" />
  <meta name="dct.abstract" content="QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss recovery and congestion control, and the use of TLS 1.3 for key negotiation." />
  <meta name="description" content="QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss recovery and congestion control, and the use of TLS 1.3 for key negotiation." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">QUIC</td>
  <td class="right">J. Iyengar, Ed.</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">M. Thomson, Ed.</td>
</tr>
<tr>
  <td class="left">Expires: August 12, 2017</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">February 8, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QUIC: A UDP-Based Multiplexed and Secure Transport<br />
  <span class="filename">draft-ietf-quic-transport-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience, and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the basis of QUIC is intended to address compatibility issues with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing third parties from changing them.  QUIC encrypts most of its headers, thereby limiting protocol evolution to QUIC endpoints only.  Therefore, middleboxes, in large part, are not required to be updated as new protocol versions are deployed.  This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss recovery and congestion control, and the use of TLS 1.3 for key negotiation.</p>
<h1>
  <a>Note to Readers</a>
</h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/transport">https://github.com/quicwg/base-drafts/labels/transport</a>.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 12, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Conventions and Definitions</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Notational Conventions</a></li>
</ul><li>3.   <a href="#rfc.section.3">A QUIC Overview</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Low-Latency Connection Establishment</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Stream Multiplexing</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Rich Signaling for Congestion Control and Loss Recovery</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Stream and Connection Flow Control</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Authenticated and Encrypted Header and Payload</a></li>
<li>3.6.   <a href="#rfc.section.3.6">Connection Migration and Resilience to NAT Rebinding</a></li>
<li>3.7.   <a href="#rfc.section.3.7">Version Negotiation</a></li>
</ul><li>4.   <a href="#rfc.section.4">Versions</a></li>
<li>5.   <a href="#rfc.section.5">Packet Types and Formats</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Common Header</a></li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Identifying Packet Types</a></li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Handling Packets from Different Versions</a></li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Regular Packets</a></li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Packet Number Compression and Reconstruction</a></li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Frames and Frame Types</a></li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Version Negotiation Packet</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Public Reset Packet</a></li>
</ul><li>6.   <a href="#rfc.section.6">Life of a Connection</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Version Negotiation</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Crypto and Transport Handshake</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Transport Parameters and Options</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">Proof of Source Address Ownership</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">Crypto Handshake Protocol Features</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">Version Negotiation Validation</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Connection Migration</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Connection Termination</a></li>
</ul><li>7.   <a href="#rfc.section.7">Frame Types and Formats</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">STREAM Frame</a></li>
<li>7.2.   <a href="#rfc.section.7.2">ACK Frame</a></li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Ack Block Section</a></li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Timestamp Section</a></li>
</ul><li>7.3.   <a href="#rfc.section.7.3">STOP_WAITING Frame</a></li>
<li>7.4.   <a href="#rfc.section.7.4">WINDOW_UPDATE Frame</a></li>
<li>7.5.   <a href="#rfc.section.7.5">BLOCKED Frame</a></li>
<li>7.6.   <a href="#rfc.section.7.6">RST_STREAM Frame</a></li>
<li>7.7.   <a href="#rfc.section.7.7">PADDING Frame</a></li>
<li>7.8.   <a href="#rfc.section.7.8">PING frame</a></li>
<li>7.9.   <a href="#rfc.section.7.9">CONNECTION_CLOSE frame</a></li>
<li>7.10.   <a href="#rfc.section.7.10">GOAWAY Frame</a></li>
</ul><li>8.   <a href="#rfc.section.8">Packetization and Reliability</a></li>
<li>9.   <a href="#rfc.section.9">Streams: QUIC&#8217;s Data Structuring Abstraction</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Life of a Stream</a></li>
<ul><li>9.1.1.   <a href="#rfc.section.9.1.1">idle</a></li>
<li>9.1.2.   <a href="#rfc.section.9.1.2">reserved</a></li>
<li>9.1.3.   <a href="#rfc.section.9.1.3">open</a></li>
<li>9.1.4.   <a href="#rfc.section.9.1.4">half-closed (local)</a></li>
<li>9.1.5.   <a href="#rfc.section.9.1.5">half-closed (remote)</a></li>
<li>9.1.6.   <a href="#rfc.section.9.1.6">closed</a></li>
</ul><li>9.2.   <a href="#rfc.section.9.2">Stream Identifiers</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Stream Concurrency</a></li>
<li>9.4.   <a href="#rfc.section.9.4">Sending and Receiving Data</a></li>
</ul><li>10.   <a href="#rfc.section.10">Flow Control</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Edge Cases and Other Considerations</a></li>
<ul><li>10.1.1.   <a href="#rfc.section.10.1.1">Mid-stream RST_STREAM</a></li>
<li>10.1.2.   <a href="#rfc.section.10.1.2">Response to a RST_STREAM</a></li>
<li>10.1.3.   <a href="#rfc.section.10.1.3">Offset Increment</a></li>
<li>10.1.4.   <a href="#rfc.section.10.1.4">BLOCKED frames</a></li>
</ul></ul><li>11.   <a href="#rfc.section.11">Error Codes</a></li>
<li>12.   <a href="#rfc.section.12">Security and Privacy Considerations</a></li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Spoofed Ack Attack</a></li>
</ul><li>13.   <a href="#rfc.section.13">IANA Considerations</a></li>
<li>14.   <a href="#rfc.references">References</a></li>
<ul><li>14.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Contributors</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Acknowledgments</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Change Log</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Since draft-ietf-quic-transport-00:</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Since draft-hamilton-quic-transport-protocol-01:</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">QUIC is a multiplexed and secure transport protocol that runs on top of UDP.  QUIC builds on past transport experience and implements mechanisms that make it useful as a modern general-purpose transport protocol.  Using UDP as the substrate, QUIC seeks to be compatible with legacy clients and middleboxes.  QUIC authenticates all of its headers, preventing middleboxes and other third parties from changing them, and encrypts most of its headers, limiting protocol evolution largely to QUIC endpoints only.</p>
<p id="rfc.section.1.p.2">This document describes the core QUIC protocol, including the conceptual design, wire format, and mechanisms of the QUIC protocol for connection establishment, stream multiplexing, stream and connection-level flow control, and data reliability.  Accompanying documents describe QUIC&#8217;s loss detection and congestion control <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>, and the use of TLS 1.3 for key negotiation <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a></h1>
<p id="rfc.section.2.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when they are capitalized, they have the special meaning defined in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.2.p.2">Definitions of terms that are used in this document:</p>
<p/>

<ul>
  <li>Client: The endpoint initiating a QUIC connection.</li>
  <li>Server: The endpoint accepting incoming QUIC connections.</li>
  <li>Endpoint: The client or server end of a connection.</li>
  <li>Stream: A logical, bi-directional channel of ordered bytes within a QUIC connection.</li>
  <li>Connection: A conversation between two QUIC endpoints with a single encryption context that multiplexes streams within it.</li>
  <li>Connection ID: The identifier for a QUIC connection.</li>
  <li>QUIC packet: A well-formed UDP payload that can be parsed by a QUIC receiver.  QUIC packet size in this document refers to the UDP payload size.</li>
</ul>
<h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a></h2>
<p id="rfc.section.2.1.p.1">Packet and frame diagrams use the format described in <a href="#RFC2360">[RFC2360]</a> Section 3.1, with the following additional conventions:</p>
<p/>

<dl>
  <dt>[x]</dt>
  <dd style="margin-left: 8">Indicates that x is optional</dd>
  <dt>{x}</dt>
  <dd style="margin-left: 8">Indicates that x is encrypted</dd>
  <dt>x (A)</dt>
  <dd style="margin-left: 8">Indicates that x is A bits long</dd>
  <dt>x (A/B/C) &#8230;</dt>
  <dd style="margin-left: 8">Indicates that x is one of A, B, or C bits long</dd>
  <dt>x (*) &#8230;</dt>
  <dd style="margin-left: 8">Indicates that x is variable-length</dd>
</dl>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#a-quic-overview" id="a-quic-overview">A QUIC Overview</a></h1>
<p id="rfc.section.3.p.1">This section briefly describes QUIC&#8217;s key mechanisms and benefits.  Key strengths of QUIC include:</p>
<p/>

<ul>
  <li>Low-latency connection establishment</li>
  <li>Multiplexing without head-of-line blocking</li>
  <li>Authenticated and encrypted header and payload</li>
  <li>Rich signaling for congestion control and loss recovery</li>
  <li>Stream and connection flow control</li>
  <li>Connection migration and resilience to NAT rebinding</li>
  <li>Version negotiation</li>
</ul>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#low-latency-connection-establishment" id="low-latency-connection-establishment">Low-Latency Connection Establishment</a></h2>
<p id="rfc.section.3.1.p.1">QUIC relies on a combined crypto and transport handshake for setting up a secure transport connection.  QUIC connections are expected to commonly use 0-RTT handshakes, meaning that for most QUIC connections, data can be sent immediately following the client handshake packet, without waiting for a reply from the server.  QUIC provides a dedicated stream (Stream ID 1) to be used for performing the crypto handshake and QUIC options negotiation.  The format of the QUIC options and parameters used during negotiation are described in this document, but the handshake protocol that runs on Stream ID 1 is described in the accompanying crypto handshake draft <a href="#QUIC-TLS">[QUIC-TLS]</a>.</p>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#stream-multiplexing" id="stream-multiplexing">Stream Multiplexing</a></h2>
<p id="rfc.section.3.2.p.1">When application messages are transported over TCP, independent application messages can suffer from head-of-line blocking.  When an application multiplexes many streams atop TCP&#8217;s single-bytestream abstraction, a loss of a TCP segment results in blocking of all subsequent segments until a retransmission arrives, irrespective of the application streams that are encapsulated in subsequent segments.  QUIC ensures that lost packets carrying data for an individual stream only impact that specific stream.  Data received on other streams can continue to be reassembled and delivered to the application.</p>
<h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#rich-signaling-for-congestion-control-and-loss-recovery" id="rich-signaling-for-congestion-control-and-loss-recovery">Rich Signaling for Congestion Control and Loss Recovery</a></h2>
<p id="rfc.section.3.3.p.1">QUIC&#8217;s packet framing and acknowledgments carry rich information that help both congestion control and loss recovery in fundamental ways.  Each QUIC packet carries a new packet number, including those carrying retransmitted data.  This obviates the need for a separate mechanism to distinguish acks for retransmissions from those for original transmissions, avoiding TCP&#8217;s retransmission ambiguity problem.  QUIC acknowledgments also explicitly encode the delay between the receipt of a packet and its acknowledgment being sent, and together with the monotonically-increasing packet numbers, this allows for precise network roundtrip-time (RTT) calculation.  QUIC&#8217;s ACK frames support up to 256 ack blocks, so QUIC is more resilient to reordering than TCP with SACK support, as well as able to keep more bytes on the wire when there is reordering or loss.</p>
<h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#stream-and-connection-flow-control" id="stream-and-connection-flow-control">Stream and Connection Flow Control</a></h2>
<p id="rfc.section.3.4.p.1">QUIC implements stream- and connection-level flow control, closely following HTTP/2&#8217;s flow control mechanisms.  At a high level, a QUIC receiver advertises the absolute byte offset within each stream up to which the receiver is willing to receive data.  As data is sent, received, and delivered on a particular stream, the receiver sends WINDOW_UPDATE frames that increase the advertised offset limit for that stream, allowing the peer to send more data on that stream.  In addition to this stream-level flow control, QUIC implements connection-level flow control to limit the aggregate buffer that a QUIC receiver is willing to allocate to all streams on a connection.  Connection-level flow control works in the same way as stream-level flow control, but the bytes delivered and highest received offset are all aggregates across all streams.</p>
<h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#authenticated-and-encrypted-header-and-payload" id="authenticated-and-encrypted-header-and-payload">Authenticated and Encrypted Header and Payload</a></h2>
<p id="rfc.section.3.5.p.1">TCP headers appear in plaintext on the wire and are not authenticated, causing a plethora of injection and header manipulation issues for TCP, such as receive-window manipulation and sequence-number overwriting.  While some of these are mechanisms used by middleboxes to improve TCP performance, others are active attacks.  Even &#8220;performance-enhancing&#8221; middleboxes that routinely interpose on the transport state machine end up limiting the evolvability of the transport protocol, as has been observed in the design of MPTCP and in its subsequent deployability issues.</p>
<p id="rfc.section.3.5.p.2">Generally, QUIC packets are always authenticated and the payload is typically fully encrypted.  The parts of the packet header which are not encrypted are still authenticated by the receiver, so as to thwart any packet injection or manipulation by third parties.  Some early handshake packets, such as the Version Negotiation packet, are not encrypted, but information sent in these unencrypted handshake packets is later verified under crypto cover.</p>
<p id="rfc.section.3.5.p.3">PUBLIC_RESET packets that reset a connection are currently not authenticated.</p>
<h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#connection-migration-and-resilience-to-nat-rebinding" id="connection-migration-and-resilience-to-nat-rebinding">Connection Migration and Resilience to NAT Rebinding</a></h2>
<p id="rfc.section.3.6.p.1">QUIC connections are identified by a 64-bit Connection ID, randomly generated by the client.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and port, such as those caused by NAT rebindings or by the client changing network connectivity to a new address.  QUIC provides automatic cryptographic verification of a rebound client, since the client continues to use the same session key for encrypting and decrypting packets.  The consistent connection ID can be used to allow migration of the connection to a new server IP address as well, since the Connection ID remains consistent across changes in the client&#8217;s and the server&#8217;s network addresses.</p>
<h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#benefit-version-negotiation" id="benefit-version-negotiation">Version Negotiation</a></h2>
<p id="rfc.section.3.7.p.1">QUIC version negotiation allows for multiple versions of the protocol to be deployed and used concurrently. Version negotiation is described in <a href="#version-negotiation">Section 6.1</a>.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#versions" id="versions">Versions</a></h1>
<p id="rfc.section.4.p.1">QUIC versions are identified using a 32-bit value.</p>
<p id="rfc.section.4.p.2">The version 0x00000000 is reserved to represent an invalid version.  This version of the specification is identified by the number 0x00000001.</p>
<p id="rfc.section.4.p.3">Versions with the most significant 16 bits of the version number cleared are reserved for use in future IETF consensus documents.</p>
<p id="rfc.section.4.p.4">[[RFC editor: please remove the remainder of this section before publication.]]</p>
<p id="rfc.section.4.p.5">The version number for the final version of this specification (0x00000001), is reserved for the version of the protocol that is published as an RFC.</p>
<p id="rfc.section.4.p.6">Version numbers used to identify IETF drafts are created by adding the draft number to 0xff000000.  For example, draft-ietf-quic-transport-13 would be identified as 0xff00000D.</p>
<p id="rfc.section.4.p.7">Implementors are encouraged to register version numbers of QUIC that they are using for private experimentation on the <a href="https://github.com/quicwg/base-drafts/wiki/QUIC-Versions">github wiki</a>.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#packet-types-and-formats" id="packet-types-and-formats">Packet Types and Formats</a></h1>
<p id="rfc.section.5.p.1">We first describe QUIC&#8217;s packet types and their formats, since some are referenced in subsequent mechanisms.</p>
<p id="rfc.section.5.p.2">All numeric values are encoded in network byte order (that is, big-endian) and all field sizes are in bits.  When discussing individual bits of fields, the least significant bit is referred to as bit 0.  Hexadecimal notation is used for describing the value of fields.</p>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#common-header" id="common-header">Common Header</a></h2>
<p id="rfc.section.5.1.p.1">All QUIC packets begin with a QUIC Common header, as shown below.</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|   Flags (8)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                     [Connection ID (64)]                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Type-Dependent Fields (*)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.5.1.p.2">The fields in the Common Header are the following:</p>
<p/>

<ul>
  <li>Flags:  <ul><li>0x01 = VERSION.  The semantics of this flag depends on whether the packet is sent by the server or the client.  A client MAY set this flag and include exactly one proposed version.  A server may set this flag when the client-proposed version was unsupported, and may then provide a list (0 or more) of acceptable versions as a part of version negotiation (described in <a href="#version-negotiation">Section 6.1</a>.)</li><li>0x02 = PUBLIC_RESET.  Set to indicate that the packet is a Public Reset packet.</li><li>0x04 = KEY_PHASE.  This is used by the QUIC packet protection to identify the correct packet protection keys, see <a href="#QUIC-TLS">[QUIC-TLS]</a>.</li><li>0x08 = CONNECTION_ID.  Indicates the Connection ID is present in the packet.  This must be set in all packets until negotiated to a different value for a given direction.  For instance, if a client indicates that the 5-tuple fully identifies the connection at the client, the connection ID is optional in the server-to-client direction. The negotiation is described in <a href="#optional-transport-parameters">Section 6.2.1.3</a>.</li><li>0x30 = PACKET_NUMBER_SIZE.  These two bits indicate the number of low-order-bytes of the packet number that are present in each packet.      <ul><li>11 indicates that 6 bytes of the packet number are present</li><li>10 indicates that 4 bytes of the packet number are present</li><li>01 indicates that 2 bytes of the packet number are present</li><li>00 indicates that 1 byte of the packet number is present</li></ul></li><li>0x40 = MULTIPATH.  This bit is reserved for multipath use.</li><li>0x80 is currently unused, and must be set to 0.</li></ul></li>
  <li>Connection ID: An unsigned 64-bit random number chosen by the client, used as the identifier of the connection.  Connection ID is tied to a QUIC connection, and remains consistent across client and/or server IP and port changes.</li>
</ul>
<h3 id="rfc.section.5.1.1"><a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#identifying-packet-types" id="identifying-packet-types">Identifying Packet Types</a></h3>
<p id="rfc.section.5.1.1.p.1">While all QUIC packets have the same common header, there are three types of packets: Regular packets, Version Negotiation packets, and Public Reset packets.  The flowchart below shows how a packet is classified into one of these three packet types:</p>
<div id="rfc.figure.1"/>
<div id="packet-types"/>
<pre>
Check the flags in the common header
              |
              |
              V
        +--------------+
        | PUBLIC_RESET |  YES
        | flag set?    |-------&gt; Public Reset packet
        +--------------+
              |
              | NO
              V
        +------------+         +-------------+
        | VERSION    |  YES    | Packet sent |  YES     Version
        | flag set?  |--------&gt;| by server?  |--------&gt; Negotiation
        +------------+         +-------------+          packet
              |                       |
              | NO                    | NO
              V                       V
      Regular packet with       Regular packet with
  no QUIC Version in header    QUIC Version in header
</pre>
<p class="figure">Figure 1: Types of QUIC Packets</p>
<h3 id="rfc.section.5.1.2"><a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#handling-packets-from-different-versions" id="handling-packets-from-different-versions">Handling Packets from Different Versions</a></h3>
<p id="rfc.section.5.1.2.p.1">Version negotiation (<a href="#version-negotiation">Section 6.1</a>) is performed using packets that have the VERSION bit set.  This bit is always set on packets that are sent prior to connection establishment.  When receiving a packet that is not associated with an existing connection, packets without a VERSION bit MUST be discarded.</p>
<p id="rfc.section.5.1.2.p.2">Implementations MUST assume that an unsupported version uses an unknown packet format.</p>
<p id="rfc.section.5.1.2.p.3">Between different versions the following things are guaranteed to remain constant are:</p>
<p/>

<ul>
  <li>the location and size of the Flags field,</li>
  <li>the location and value of the VERSION bit in the Flags field,</li>
  <li>the location and size of the Connection ID field, and</li>
  <li>the Version (or Supported Versions, <a href="#version-negotiation-packet">Section 5.3</a>) field.</li>
</ul>
<p id="rfc.section.5.1.2.p.5">All other values MUST be ignored when processing a packet that contains an unsupported version.</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#regular-packets" id="regular-packets">Regular Packets</a></h2>
<p id="rfc.section.5.2.p.1">Each Regular packet contains additional header fields followed by an encrypted payload, as shown below:</p>
<div id="rfc.figure.2"/>
<div id="regular-packet-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        [Version (32)]                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Packet Number (8/16/32/48)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    {Encrypted Payload (*)}                  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 2: Regular Packet</p>
<p id="rfc.section.5.2.p.2">The fields in a Regular packet past the Common Header are the following:</p>
<p/>

<ul>
  <li>QUIC Version: A 32-bit opaque tag that represents the version of the QUIC protocol.  Only present in the client-to-server direction, and if the VERSION flag is set.  Version Negotiation is described in <a href="#version-negotiation">Section 6.1</a>.</li>
  <li>Packet Number: The lower 8, 16, 32, or 48 bits of the packet number, based on the PACKET_NUMBER_SIZE flag.  Each Regular packet is assigned a packet number by the sender.  The first packet sent by an endpoint MUST have a packet number of 1.</li>
  <li>Encrypted Payload: The remainder of a Regular packet is both authenticated and encrypted once packet protection keys are available.  <a href="#QUIC-TLS">[QUIC-TLS]</a> describes packet protection in detail.  After decryption, the plaintext consists of a sequence of frames, as shown in <a href="#regular-packet-frames">Figure 3</a>.  Frames are described in <a href="#frames">Section 5.2.2</a>.</li>
</ul>
<div id="rfc.figure.3"/>
<div id="regular-packet-frames"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 1 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 2 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame N (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 3: Contents of Encrypted Payload</p>
<h3 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#packet-number-compression-and-reconstruction" id="packet-number-compression-and-reconstruction">Packet Number Compression and Reconstruction</a></h3>
<p id="rfc.section.5.2.1.p.1">The complete packet number is a 64-bit unsigned number and is used as part of a cryptographic nonce for packet encryption.  To reduce the number of bits required to represent the packet number over the wire, at most 48 bits of the packet number are transmitted over the wire.  A QUIC endpoint MUST NOT reuse a complete packet number within the same connection (that is, under the same cryptographic keys).  If the total number of packets transmitted in this connection reaches 2^64 - 1, the sender MUST close the connection by sending a CONNECTION_CLOSE frame with the error code QUIC_SEQUENCE_NUMBER_LIMIT_REACHED (connection termination is described in <a href="#termination">Section 6.4</a>.)  For unambiguous reconstruction of the complete packet number by a receiver from the lower-order bits, a QUIC sender MUST NOT have more than 2^(packet_number_size - 2) in flight at any point in the connection.  In other words,</p>
<p/>

<ul>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 11, it MUST NOT have more than (2^46) packets in flight.</li>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 10, it MUST NOT have more than (2^30) packets in flight.</li>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 01, it MUST NOT have more than (2^14) packets in flight.</li>
  <li>If a sender sets PACKET_NUMBER_SIZE bits to 00, it MUST NOT have more than (2^6) packets in flight.  <br/><br/> DISCUSS: Should the receiver be required to enforce this rule that the sender MUST NOT exceed the inflight limit?  Specifically, should the receiver drop packets that are received outside this window?  <br/><br/> Any truncated packet number received from a peer MUST be reconstructed as the value closest to the next expected packet number from that peer.</li>
</ul>
<p id="rfc.section.5.2.1.p.3">(TODO: Clarify how packet number size can change mid-connection.)</p>
<h3 id="rfc.section.5.2.2"><a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#frames" id="frames">Frames and Frame Types</a></h3>
<p id="rfc.section.5.2.2.p.1">A Regular packet MUST contain at least one frame, and MAY contain multiple frames and multiple frame types.  Frames MUST fit within a single QUIC packet and MUST NOT span a QUIC packet boundary.  Each frame begins with a Frame Type byte, indicating its type, followed by additional type-dependent fields:</p>
<div id="rfc.figure.4"/>
<div id="frame-layout"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type (8)    |           Type-Dependent Fields (*)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 4: Generic Frame Layout</p>
<p id="rfc.section.5.2.2.p.2">The following table lists currently defined frame types.  Note that the Frame Type byte in STREAM and ACK frames is used to carry other frame-specific flags.  For all other frames, the Frame Type byte simply identifies the frame.  These frames are explained in more detail as they are referenced later in the document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left"/>
      <th class="left">Type-field value</th>
      <th class="left">Frame type</th>
      <th class="left">Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left"/>
      <td class="left">0x00</td>
      <td class="left">PADDING</td>
      <td class="left">
        <a href="#frame-padding">Section 7.7</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x01</td>
      <td class="left">RST_STREAM</td>
      <td class="left">
        <a href="#frame-rst-stream">Section 7.6</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x02</td>
      <td class="left">CONNECTION_CLOSE</td>
      <td class="left">
        <a href="#frame-connection-close">Section 7.9</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x03</td>
      <td class="left">GOAWAY</td>
      <td class="left">
        <a href="#frame-goaway">Section 7.10</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x04</td>
      <td class="left">WINDOW_UPDATE</td>
      <td class="left">
        <a href="#frame-window-update">Section 7.4</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x05</td>
      <td class="left">BLOCKED</td>
      <td class="left">
        <a href="#frame-blocked">Section 7.5</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x06</td>
      <td class="left">STOP_WAITING</td>
      <td class="left">
        <a href="#frame-stop-waiting">Section 7.3</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x07</td>
      <td class="left">PING</td>
      <td class="left">
        <a href="#frame-ping">Section 7.8</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x40 - 0x7f</td>
      <td class="left">ACK</td>
      <td class="left">
        <a href="#frame-ack">Section 7.2</a>
      </td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">0x80 - 0xff</td>
      <td class="left">STREAM</td>
      <td class="left">
        <a href="#frame-stream">Section 7.1</a>
      </td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#version-negotiation-packet" id="version-negotiation-packet">Version Negotiation Packet</a></h2>
<p id="rfc.section.5.3.p.1">A Version Negotiation packet is only sent by the server, MUST have the VERSION flag set, and MUST include the full 64-bit Connection ID.  The remainder of the Version Negotiation packet is a list of 32-bit versions which the server supports, as shown below.</p>
<div id="rfc.figure.5"/>
<div id="version-negotiation-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version 1 (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version 2 (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version N (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 5: Version Negotiation Packet</p>
<h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#public-reset-packet" id="public-reset-packet">Public Reset Packet</a></h2>
<p id="rfc.section.5.4.p.1">A Public Reset packet MUST have the PUBLIC_RESET flag set, and MUST include the full 64-bit connection ID.  The content of the Public Reset packet is TBD.</p>
<div id="rfc.figure.6"/>
<div id="public-reset-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Public Reset Fields (*)                  ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 6: Public Reset Packet</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#life-of-a-connection" id="life-of-a-connection">Life of a Connection</a></h1>
<p id="rfc.section.6.p.1">A QUIC connection is a single conversation between two QUIC endpoints.  QUIC&#8217;s connection establishment intertwines version negotiation with the crypto and transport handshakes to reduce connection establishment latency, as described in <a href="#handshake">Section 6.2</a>.  Once established, a connection may migrate to a different IP or port at either endpoint, due to NAT rebinding or mobility, as described in <a href="#migration">Section 6.3</a>.  Finally a connection may be terminated by either endpoint, as described in <a href="#termination">Section 6.4</a>.</p>
<h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#version-negotiation" id="version-negotiation">Version Negotiation</a></h2>
<p id="rfc.section.6.1.p.1">QUIC&#8217;s connection establishment begins with version negotiation, since all communication between the endpoints, including packet and frame formats, relies on the two endpoints agreeing on a version.</p>
<p id="rfc.section.6.1.p.2">A QUIC connection begins with a client sending a handshake packet. The details of the handshake mechanisms are described in <a href="#handshake">Section 6.2</a>, but all of the initial packets sent from the client to the server MUST have the VERSION flag set, and MUST specify the version of the protocol being used.</p>
<p id="rfc.section.6.1.p.3">When the server receives a packet from a client with the VERSION flag set, it compares the client&#8217;s version to the versions it supports.</p>
<p id="rfc.section.6.1.p.4">If the version selected by the client is not acceptable to the server, the server discards the incoming packet and responds with a version negotiation packet (<a href="#version-negotiation-packet">Section 5.3</a>).  This includes the VERSION flag and a list of versions that the server will accept.  A server MUST send a version negotiation packet for every packet that it receives with an unacceptable version.</p>
<p id="rfc.section.6.1.p.5">If the packet contains a version that is acceptable to the server, the server proceeds with the handshake (<a href="#handshake">Section 6.2</a>).  All subsequent packets sent by the server MUST have the VERSION flag unset.  This commits the server to the version that the client selected.</p>
<p id="rfc.section.6.1.p.6">When the client receives a Version Negotiation packet from the server, it should select an acceptable protocol version.  If the server lists an acceptable version, the client selects that version and resends all packets using that version. The resent packets MUST use new packet numbers.  These packets MUST continue to have the VERSION flag set and MUST include the new negotiated protocol version.</p>
<p id="rfc.section.6.1.p.7">The client MUST set the VERSION flag and include its selected version on all packets until it has 1-RTT keys and it has received a packet from the server that does not have the VERSION flag set.  With TLS, this means that unprotected packets and 0-RTT protected packets all include a version field.</p>
<p id="rfc.section.6.1.p.8">A client MUST NOT change the version it uses unless it is in response to a version negotiation packet from the server.  Once a client receives a packet from the server with the VERSION flag unset, it MUST ignore the flag in subsequently received packets.</p>
<p id="rfc.section.6.1.p.9">Version negotiation uses unprotected data. The result of the negotiation MUST be revalidated once the cryptographic handshake has completed (see <a href="#version-validation">Section 6.2.4</a>).</p>
<h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#handshake" id="handshake">Crypto and Transport Handshake</a></h2>
<p id="rfc.section.6.2.p.1">QUIC relies on a combined crypto and transport handshake to minimize connection establishment latency.  QUIC provides a dedicated stream (Stream ID 1) to be used for performing a combined connection and security handshake (streams are described in detail in <a href="#streams">Section 9</a>).  The crypto handshake protocol encapsulates and delivers QUIC&#8217;s transport handshake to the peer on the crypto stream.  The first QUIC packet sent by client to the server MUST carry handshake information as data on Stream ID 1.</p>
<h3 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#transport-parameters-and-options" id="transport-parameters-and-options">Transport Parameters and Options</a></h3>
<p id="rfc.section.6.2.1.p.1">During connection establishment, the handshake must negotiate various transport parameters.  The currently defined transport parameters are described later in the document.</p>
<p id="rfc.section.6.2.1.p.2">The transport component of the handshake is responsible for exchanging and negotiating the following parameters for a QUIC connection.  Not all parameters are negotiated; some parameters are sent in just one direction.  These parameters and options are encoded and handed off to the crypto handshake protocol to be transmitted to the peer.</p>
<h4 id="rfc.section.6.2.1.1"><a href="#rfc.section.6.2.1.1">6.2.1.1.</a> <a href="#encoding" id="encoding">Encoding</a></h4>
<p id="rfc.section.6.2.1.1.p.1">(TODO: Describe format with example)</p>
<p id="rfc.section.6.2.1.1.p.2">QUIC encodes the transport parameters and options as tag-value pairs, all as 7-bit ASCII strings.  QUIC parameter tags are listed below.</p>
<h4 id="rfc.section.6.2.1.2"><a href="#rfc.section.6.2.1.2">6.2.1.2.</a> <a href="#required-transport-parameters" id="required-transport-parameters">Required Transport Parameters</a></h4>
<p/>

<ul>
  <li>SFCW: Stream Flow Control Window.  The stream level flow control byte offset advertised by the sender of this parameter.</li>
  <li>CFCW: Connection Flow Control Window.  The connection level flow control byte offset advertised by the sender of this parameter.</li>
  <li>MSPC: Maximum number of incoming streams per connection.</li>
  <li>ICSL: Idle timeout in seconds.  The maximum value is 600 seconds (10 minutes).</li>
</ul>
<h4 id="rfc.section.6.2.1.3"><a href="#rfc.section.6.2.1.3">6.2.1.3.</a> <a href="#optional-transport-parameters" id="optional-transport-parameters">Optional Transport Parameters</a></h4>
<p/>

<ul>
  <li>TCID: Indicates support for truncated Connection IDs.  If sent by a peer, indicates that connection IDs sent to the peer should be truncated to 0 bytes.  This is expected to commonly be used by an endpoint where the 5-tuple is sufficient to identify a connection.  For instance, if the 5-tuple is unique at the client, the client MAY send a TCID parameter to the server.  When a TCID parameter is received, an endpoint MAY choose to not send the connection ID on subsequent packets.</li>
  <li>COPT: Connection Options are a repeated tag field.  The field contains any connection options being requested by the client or server.  These are typically used for experimentation and will evolve over time.  Example use cases include changing congestion control algorithms and parameters such as initial window.  (TODO: List connection options.)</li>
</ul>
<h3 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#proof-of-source-address-ownership" id="proof-of-source-address-ownership">Proof of Source Address Ownership</a></h3>
<p id="rfc.section.6.2.2.p.1">Transport protocols commonly spend a round trip checking that a client owns the transport address (IP and port) that it claims.  Verifying that a client can receive packets sent to its claimed transport address protects against spoofing of this information by malicious clients.</p>
<p id="rfc.section.6.2.2.p.2">This technique is used primarily to avoid QUIC from being used for traffic amplification attack.  In such an attack, a packet is sent to a server with spoofed source address information that identifies a victim.  If a server generates more or larger packets in response to that packet, the attacker can use the server to send more data toward the victim than it would be able to send on its own.</p>
<p id="rfc.section.6.2.2.p.3">Several methods are used in QUIC to mitigate this attack.  Firstly, the initial handshake packet from a client is padded to a moderately large size (TBD: describe/reference how this size is selected).  This allows a server to send a similar amount of data without validating ownership of an address (TBD: provide limits on what amount of amplification is enough).</p>
<p id="rfc.section.6.2.2.p.4">A server eventually confirms that a client has received its messages when the cryptographic handshake successfully completes.  This might be either because the server wishes to avoid the computational cost of completing the handshake, or it might be that the size of the packets that are sent during the handshake is too large.  This is especially important for 0-RTT, where the server might wish to provide application data traffic - such as a response to a request - in response to the data carried in the early data from the client.</p>
<p id="rfc.section.6.2.2.p.5">To send additional data prior to completing the cryptographic handshake, the server then needs to validate that the client owns the address that it claims.</p>
<p id="rfc.section.6.2.2.p.6">Two tools are provided by TLS to enable validation of client source addresses: the cookie in the HelloRetryRequest message, and the ticket in the NewSessionTicket message.</p>
<p id="rfc.section.6.2.2.p.7">The cookie extension in the TLS HelloRetryRequest message allows a server to perform source address validation during the handshake.  As long as the cookie cannot be successfully guessed by a client, the server can be assured that the client received the HelloRetryRequest.</p>
<p id="rfc.section.6.2.2.p.8">A server can use the HelloRetryRequest cookie in a stateless fashion by encrypting the state it needs to verify ownership of the client address and continue the handshake into the cookie.</p>
<p id="rfc.section.6.2.2.p.9">The ticket in the TLS NewSessionTicket message allows a server to provide a client with a similar sort of token.  When a client resumes a TLS connection - whether or not 0-RTT is attempted - it includes the ticket in the handshake message.  As with the HelloRetryRequest cookie, the server can include the state in the ticket it needs to validate that the client owns the address.</p>
<p id="rfc.section.6.2.2.p.10">A server can send a NewSessionTicket message at any time.  This allows it to update the state that is included in the ticket.  This might be done to refresh the ticket, or in response to changes in the state of a connection.</p>
<h3 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#crypto-handshake-protocol-features" id="crypto-handshake-protocol-features">Crypto Handshake Protocol Features</a></h3>
<p id="rfc.section.6.2.3.p.1">QUIC&#8217;s current crypto handshake mechanism is documented in <a href="#QUICCrypto">[QUICCrypto]</a>.  QUIC does not restrict itself to using a specific handshake protocol, so the details of a specific handshake protocol are out of this document&#8217;s scope.  If not explicitly specified in the application mapping, TLS is assumed to be the default crypto handshake protocol, as described in <a href="#QUIC-TLS">[QUIC-TLS]</a>.  An application that maps to QUIC MAY however specify an alternative crypto handshake protocol to be used.</p>
<p id="rfc.section.6.2.3.p.2">The following list of requirements and recommendations documents properties of the current prototype handshake which should be provided by any handshake protocol.</p>
<p/>

<ul>
  <li>The crypto handshake MUST ensure that the final negotiated key is distinct for every connection between two endpoints.</li>
  <li>Transport Negotiation: The crypto handshake MUST provide a mechanism for the transport component to exchange transport parameters and Source Address Tokens.  To avoid downgrade attacks, the transport parameters sent and received MUST be verified before the handshake completes successfully.</li>
  <li>Connection Establishment in 0-RTT: Since low-latency connection establishment is a critical feature of QUIC, the QUIC handshake protocol SHOULD attempt to achieve 0-RTT connection establishment latency for repeated connections between the same endpoints.</li>
  <li>Source Address Spoofing Defense: Since QUIC handles source address verification, the crypto protocol SHOULD NOT impose a separate source address verification mechanism.</li>
  <li>Server Config Update: A QUIC server may refresh the source-address token (STK) mid-connection, to update the information stored in the STK at the client and to extend the period over which 0-RTT connections can be established by the client.</li>
  <li>Certificate Compression: Early QUIC experience demonstrated that compressing certificates exchanged during a handshake is valuable in reducing latency.  This additionally helps to reduce the amplification attack footprint when a server sends a large set of certificates, which is not uncommon with TLS.  The crypto protocol SHOULD compress certificates and any other information to minimize the number of packets sent during a handshake.</li>
</ul>
<h3 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#version-validation" id="version-validation">Version Negotiation Validation</a></h3>
<p id="rfc.section.6.2.4.p.1">The following information used during the QUIC handshake MUST be cryptographically verified by the crypto handshake protocol:</p>
<p/>

<ul>
  <li>Client&#8217;s originally proposed version in its first packet.</li>
  <li>Server&#8217;s version list in it&#8217;s Version Negotiation packet, if one was sent.</li>
</ul>
<h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#migration" id="migration">Connection Migration</a></h2>
<p id="rfc.section.6.3.p.1">QUIC connections are identified by their 64-bit Connection ID.  QUIC&#8217;s consistent connection ID allows connections to survive changes to the client&#8217;s IP and/or port, such as those caused by client or server migrating to a new network.  QUIC also provides automatic cryptographic verification of a client which has changed its IP address because the client continues to use the same session key for encrypting and decrypting packets.</p>
<p id="rfc.section.6.3.p.2">DISCUSS: Simultaneous migration.  Is this reasonable?</p>
<p id="rfc.section.6.3.p.3">TODO: Perhaps move mitigation techniques from Security Considerations here.</p>
<h2 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#termination" id="termination">Connection Termination</a></h2>
<p id="rfc.section.6.4.p.1">Connections should remain open until they become idle for a pre-negotiated period of time.  A QUIC connection, once established, can be terminated in one of three ways:</p>
<p/>

<ol>
  <li>Explicit Shutdown: An endpoint sends a CONNECTION_CLOSE frame to initiate a connection termination.  An endpoint may send a GOAWAY frame to the peer prior to a CONNECTION_CLOSE to indicate that the connection will soon be terminated.  A GOAWAY frame signals to the peer that any active streams will continue to be processed, but the sender of the GOAWAY will not initiate any additional streams and will not accept any new incoming streams.  On termination of the active streams, a CONNECTION_CLOSE may be sent.  If an endpoint sends a CONNECTION_CLOSE frame while unterminated streams are active (no FIN bit or RST_STREAM frames have been sent or received for one or more streams), then the peer must assume that the streams were incomplete and were abnormally terminated.</li>
  <li>Implicit Shutdown: The default idle timeout for a QUIC connection is 30 seconds, and is a required parameter (ICSL) in connection negotiation.  The maximum is 10 minutes.  If there is no network activity for the duration of the idle timeout, the connection is closed.  By default a CONNECTION_CLOSE frame will be sent.  A silent close option can be enabled when it is expensive to send an explicit close, such as mobile networks that must wake up the radio.</li>
  <li>Abrupt Shutdown: An endpoint may send a Public Reset packet at any time during the connection to abruptly terminate an active connection.  A Public Reset packet SHOULD only be used as a final recourse.  Commonly, a public reset is expected to be sent when a packet on an established connection is received by an endpoint that is unable decrypt the packet.  For instance, if a server reboots mid-connection and loses any cryptographic state associated with open connections, and then receives a packet on an open connection, it should send a Public Reset packet in return.  (TODO: articulate rules around when a public reset should be sent.)</li>
</ol>
<p id="rfc.section.6.4.p.3">TODO: Connections that are terminated are added to a TIME_WAIT list at the server, so as to absorb any straggler packets in the network.  Discuss TIME_WAIT list.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#frame-types-and-formats" id="frame-types-and-formats">Frame Types and Formats</a></h1>
<p id="rfc.section.7.p.1">As described in <a href="#packetization">Section 8</a>, Regular packets contain one or more frames.  We now describe the various QUIC frame types that can be present in a Regular packet. The use of these frames and various frame header bits are described in subsequent sections.</p>
<h2 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#frame-stream" id="frame-stream">STREAM Frame</a></h2>
<p id="rfc.section.7.1.p.1">STREAM frames implicitly create a stream and carry stream data. The type byte for a STREAM frame contains embedded flags, and is formatted as <samp>1FDOOOSS</samp>.  These bits are parsed as follows:</p>
<p/>

<ul>
  <li>The leftmost bit must be set to 1, indicating that this is a STREAM frame.</li>
  <li><samp>F</samp> is the FIN bit, which is used for stream termination.</li>
  <li>The <samp>D</samp> bit indicates whether a Data Length field is present in the STREAM header.  When set to 0, this field indicates that the Stream Data field extends to the end of the packet.  When set to 1, this field indicates that Data Length field contains the length (in bytes) of the Stream Data field.  The option to omit the length should only be used when the packet is a &#8220;full-sized&#8221; packet, to avoid the risk of corruption via padding.</li>
  <li>The <samp>OOO</samp> bits encode the length of the Offset header field as 0, 16, 24, 32, 40, 48, 56, or 64 bits long.</li>
  <li>The <samp>SS</samp> bits encode the length of the Stream ID header field as 8, 16, 24, or 32 bits.  (DISCUSS: Consider making this 8, 16, 32, 64.)</li>
</ul>
<p id="rfc.section.7.1.p.3">A STREAM frame is shown below.</p>
<div id="rfc.figure.7"/>
<div id="stream-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Stream ID (8/16/24/32)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Offset (0/16/24/32/40/48/56/64)              ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      [Data Length (16)]                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream Data (*)                      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 7: STREAM Frame Format</p>
<p id="rfc.section.7.1.p.4">The STREAM frame contains the following fields:</p>
<p/>

<ul>
  <li>Stream ID: A variable-sized unsigned ID unique to this stream.</li>
  <li>Offset: A variable-sized unsigned number specifying the byte offset in the stream for the data in this STREAM frame.  The first byte in the stream has an offset of 0.</li>
  <li>Data Length: An optional 16-bit unsigned number specifying the length of the Stream Data field in this STREAM frame.</li>
  <li>Stream Data: The bytes from the designated stream to be delivered.</li>
</ul>
<p id="rfc.section.7.1.p.6">A STREAM frame MUST have either non-zero data length or the FIN bit set.</p>
<p id="rfc.section.7.1.p.7">Stream multiplexing is achieved by interleaving STREAM frames from multiple streams into one or more QUIC packets.  A single QUIC packet MAY bundle STREAM frames from multiple streams.</p>
<p id="rfc.section.7.1.p.8">Implementation note: One of the benefits of QUIC is avoidance of head-of-line blocking across multiple streams.  When a packet loss occurs, only streams with data in that packet are blocked waiting for a retransmission to be received, while other streams can continue making progress.  Note that when data from multiple streams is bundled into a single QUIC packet, loss of that packet blocks all those streams from making progress.  An implementation is therefore advised to bundle as few streams as necessary in outgoing packets without losing transmission efficiency to underfilled packets.</p>
<h2 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#frame-ack" id="frame-ack">ACK Frame</a></h2>
<p id="rfc.section.7.2.p.1">Receivers send ACK frames to inform senders which packets they have received, as well as which packets are considered missing.  The ACK frame contains between 1 and 256 ack blocks.  Ack blocks are ranges of acknowledged packets.</p>
<p id="rfc.section.7.2.p.2">To limit the ACK blocks to the ones that haven&#8217;t yet been received by the sender, the sender periodically sends STOP_WAITING frames that signal the receiver to stop acking packets below a specified sequence number, raising the Least Unacked packet number at the receiver.  A sender of an ACK frame thus reports only those ACK blocks between the received Least Unacked and the reported Largest Acked packet numbers.  The endpoint SHOULD raise the Least Unacked communicated via future STOP_WAITING frames to the most recently received Largest Acked.</p>
<p id="rfc.section.7.2.p.3">Unlike TCP SACKs, QUIC ACK blocks are irrevocable.  Once a packet is acked, even if it does not appear in a future ACK frame, it is assumed to be acked.</p>
<p id="rfc.section.7.2.p.4">A sender MAY intentionally skip packet numbers to introduce entropy into the connection, to avoid opportunistic ack attacks.  The sender MUST close the connection if an unsent packet number is acked.  The format of the ACK frame is efficient at expressing blocks of missing packets; skipping packet numbers between 1 and 255 effectively provides up to 8 bits of efficient entropy on demand, which should be adequate protection against most opportunistic ack attacks.</p>
<p id="rfc.section.7.2.p.5">The type byte for a ACK frame contains embedded flags, and is formatted as <samp>01NULLMM</samp>.  These bits are parsed as follows:</p>
<p/>

<ul>
  <li>The first two bits must be set to 01 indicating that this is an ACK frame.</li>
  <li>The <samp>N</samp> bit indicates whether the frame has more than 1 ack range (i.e., whether the Ack Block Section contains a Num Blocks field).</li>
  <li>The <samp>U</samp> bit is unused and MUST be set to zero.</li>
  <li>The two <samp>LL</samp> bits encode the length of the Largest Acked field as 1, 2, 4, or 6 bytes long.</li>
  <li>The two <samp>MM</samp> bits encode the length of the Ack Block Length fields as 1, 2, 4, or 6 bytes long.</li>
</ul>
<p id="rfc.section.7.2.p.7">An ACK frame is shown below.</p>
<div id="rfc.figure.8"/>
<div id="ack-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Largest Acked (8/16/32/48)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Ack Delay (16)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Num Blocks(8)]|             Ack Block Section (*)           ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   NumTS (8)   |             Timestamp Section (*)           ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 8: ACK Frame Format</p>
<p id="rfc.section.7.2.p.8">The fields in the ACK frame are as follows:</p>
<p/>

<ul>
  <li>Largest Acked: A variable-sized unsigned value representing the largest packet number the peer is acking in this packet (typically the largest that the peer has seen thus far.)</li>
  <li>Ack Delay: Time from when the largest acked packet, as indicated in the Largest Acked field, was received by this peer to when this ack was sent.</li>
  <li>Num Blocks (opt): An optional 8-bit unsigned value specifying the number of additional ack blocks (besides the required First Ack Block) in this ACK frame.  Only present if the &#8216;N&#8217; flag bit is 1.</li>
  <li>Ack Block Section: Contains one or more blocks of packet numbers which have been successfully received.  See <a href="#ack-block-section">Section 7.2.1</a>.</li>
  <li>Num Timestamps: An unsigned 8-bit number specifying the total number of &lt;packet number, timestamp&gt; pairs in the Timestamp Section.</li>
  <li>Timestamp Section: Contains zero or more timestamps reporting transit delay of received packets.  See <a href="#timestamp-section">Section 7.2.2</a>.</li>
</ul>
<h3 id="rfc.section.7.2.1"><a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#ack-block-section" id="ack-block-section">Ack Block Section</a></h3>
<p id="rfc.section.7.2.1.p.1">The Ack Block Section contains between one and 256 blocks of packet numbers which have been successfully received. If the Num Blocks field is absent, only the First Ack Block length is present in this section. Otherwise, the Num Blocks field indicates how many additional blocks follow the First Ack Block Length field.</p>
<div id="rfc.figure.9"/>
<div id="ack-block-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              First Ack Block Length (8/16/32/48)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap 1 (8)]  |       [Ack Block 1 Length (8/16/32/48)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap 2 (8)]  |       [Ack Block 2 Length (8/16/32/48)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                             ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap N (8)]  |       [Ack Block N Length (8/16/32/48)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 9: Ack Block Section</p>
<p id="rfc.section.7.2.1.p.2">The fields in the Ack Block Section are:</p>
<p/>

<ul>
  <li>First Ack Block Length: An unsigned packet number delta that indicates the number of contiguous additional packets being acked starting at the Largest Acked.</li>
  <li>Gap To Next Block (opt, repeated): An unsigned number specifying the number of contiguous missing packets from the end of the previous ack block to the start of the next.</li>
  <li>Ack Block Length (opt, repeated): An unsigned packet number delta that indicates the number of contiguous packets being acked starting after the end of the previous gap.  Along with the previous field, this field is repeated &#8220;Num Blocks&#8221; times.</li>
</ul>
<h3 id="rfc.section.7.2.2"><a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#timestamp-section" id="timestamp-section">Timestamp Section</a></h3>
<p id="rfc.section.7.2.2.p.1">The Timestamp Section contains between zero and 255 measurements of packet receive times relative to the beginning of the connection.</p>
<div id="rfc.figure.10"/>
<div id="timestamp-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
| [Delta LA (8)]|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    [First Timestamp (32)]                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA 1(8)]| [Time Since Previous 1 (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA 2(8)]| [Time Since Previous 2 (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA N(8)]| [Time Since Previous N (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 10: Timestamp Section</p>
<p id="rfc.section.7.2.2.p.2">The fields in the Timestamp Section are:</p>
<p/>

<ul>
  <li>Delta Largest Acked (opt): An optional 8-bit unsigned packet number delta specifying the delta between the largest acked and the first packet whose timestamp is being reported.  In other words, this first packet number may be computed as (Largest Acked - Delta Largest Acked.)</li>
  <li>First Timestamp (opt): An optional 32-bit unsigned value specifying the time delta in microseconds, from the beginning of the connection to the arrival of the packet indicated by Delta Largest Acked.</li>
  <li>Delta Largest Acked 1..N (opt, repeated): (Same as above.)</li>
  <li>Time Since Previous Timestamp 1..N(opt, repeated): An optional 16-bit unsigned value specifying time delta from the previous reported timestamp.  It is encoded in the same format as the Ack Delay.  Along with the previous field, this field is repeated &#8220;Num Timestamps&#8221; times.</li>
</ul>
<h4 id="rfc.section.7.2.2.1"><a href="#rfc.section.7.2.2.1">7.2.2.1.</a> <a href="#time-format" id="time-format">Time Format</a></h4>
<p id="rfc.section.7.2.2.1.p.1">DISCUSS_AND_REPLACE: Perhaps make this format simpler.</p>
<p id="rfc.section.7.2.2.1.p.2">The time format used in the ACK frame above is a 16-bit unsigned float with 11 explicit bits of mantissa and 5 bits of explicit exponent, specifying time in microseconds.  The bit format is loosely modeled after IEEE 754.  For example, 1 microsecond is represented as 0x1, which has an exponent of zero, presented in the 5 high order bits, and mantissa of 1, presented in the 11 low order bits.  When the explicit exponent is greater than zero, an implicit high-order 12th bit of 1 is assumed in the mantissa.  For example, a floating value of 0x800 has an explicit exponent of 1, as well as an explicit mantissa of 0, but then has an effective mantissa of 4096 (12th bit is assumed to be 1).  Additionally, the actual exponent is one-less than the explicit exponent, and the value represents 4096 microseconds.  Any values larger than the representable range are clamped to 0xFFFF.</p>
<h2 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#frame-stop-waiting" id="frame-stop-waiting">STOP_WAITING Frame</a></h2>
<p id="rfc.section.7.3.p.1">The STOP_WAITING frame (type=0x06) is sent to inform the peer that it should not continue to wait for packets with packet numbers lower than a specified value.  The packet number is encoded in 1, 2, 4 or 6 bytes, using the same coding length as is specified for the packet number for the enclosing packet&#8217;s header (specified in the QUIC Frame packet&#8217;s Flags field.) The frame is as follows:</p>
<div id="rfc.figure.11"/>
<div id="stop-waiting-format"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               Least Unacked Delta (8/16/32/48)              ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p class="figure">Figure 11: STOP_WAITING Frame Format</p>
<p id="rfc.section.7.3.p.2">The STOP_WAITING frame contains a single field:</p>
<p/>

<ul>
  <li>Least Unacked Delta: A variable-length packet number delta with the same length as the packet header&#8217;s packet number.  Subtract it from the complete packet number of the enclosing packet to determine the least unacked packet number.  The resulting least unacked packet number is the earliest packet for which the sender is still awaiting an ack.  If the receiver is missing any packets earlier than this packet, the receiver SHOULD consider those packets to be irrecoverably lost and MUST NOT report those packets as missing in subsequent acks.</li>
</ul>
<h2 id="rfc.section.7.4"><a href="#rfc.section.7.4">7.4.</a> <a href="#frame-window-update" id="frame-window-update">WINDOW_UPDATE Frame</a></h2>
<p id="rfc.section.7.4.p.1">The WINDOW_UPDATE frame (type=0x04) informs the peer of an increase in an endpoint&#8217;s flow control receive window. The Stream ID can be zero, indicating this WINDOW_UPDATE applies to the connection level flow control window, or non-zero, indicating that the specified stream should increase its flow control window. The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        Byte Offset (64)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.7.4.p.2">The fields in the WINDOW_UPDATE frame are as follows:</p>
<p/>

<ul>
  <li>Stream ID: ID of the stream whose flow control windows is being updated, or 0 to specify the connection-level flow control window.</li>
  <li>Byte offset: A 64-bit unsigned integer indicating the absolute byte offset of data which can be sent on the given stream.  In the case of connection-level flow control, the cumulative offset which can be sent on all streams that contribute to connection-level flow control.</li>
</ul>
<h2 id="rfc.section.7.5"><a href="#rfc.section.7.5">7.5.</a> <a href="#frame-blocked" id="frame-blocked">BLOCKED Frame</a></h2>
<p id="rfc.section.7.5.p.1">A sender sends a BLOCKED frame (type=0x05) when it is ready to send data (and has data to send), but is currently flow control blocked. BLOCKED frames are purely informational frames, but extremely useful for debugging purposes. A receiver of a BLOCKED frame should simply discard it (after possibly printing a helpful log message). The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.7.5.p.2">The BLOCKED frame contains a single field:</p>
<p/>

<ul>
  <li>Stream ID: A 32-bit unsigned number indicating the stream which is flow control blocked.  A non-zero Stream ID field specifies the stream that is flow control blocked.  When zero, the Stream ID field indicates that the connection is flow control blocked.</li>
</ul>
<h2 id="rfc.section.7.6"><a href="#rfc.section.7.6">7.6.</a> <a href="#frame-rst-stream" id="frame-rst-stream">RST_STREAM Frame</a></h2>
<p id="rfc.section.7.6.p.1">An endpoint may use a RST_STREAM frame (type=0x01) to abruptly terminate a stream.  The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Final Offset (64)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.7.6.p.2">The fields are:</p>
<p/>

<ul>
  <li>Error code: A 32-bit error code which indicates why the stream is being closed.</li>
  <li>Stream ID: The 32-bit Stream ID of the stream being terminated.</li>
  <li>Final offset: A 64-bit unsigned integer indicating the absolute byte offset of the end of data written on this stream by the RST_STREAM sender.</li>
</ul>
<h2 id="rfc.section.7.7"><a href="#rfc.section.7.7">7.7.</a> <a href="#frame-padding" id="frame-padding">PADDING Frame</a></h2>
<p id="rfc.section.7.7.p.1">The PADDING frame (type=0x00) pads a packet with 0x00 bytes. When this frame is encountered, the rest of the packet is expected to be padding bytes. The frame contains 0x00 bytes and extends to the end of the QUIC packet. A PADDING frame has no additional fields.</p>
<h2 id="rfc.section.7.8"><a href="#rfc.section.7.8">7.8.</a> <a href="#frame-ping" id="frame-ping">PING frame</a></h2>
<p id="rfc.section.7.8.p.1">Endpoints can use PING frames (type=0x07) to verify that their peers are still alive or to check reachability to the peer. The PING frame contains no additional fields. The receiver of a PING frame simply needs to ACK the packet containing this frame. The PING frame SHOULD be used to keep a connection alive when a stream is open. The default is to send a PING frame after 15 seconds of quiescence. A PING frame has no additional fields.</p>
<h2 id="rfc.section.7.9"><a href="#rfc.section.7.9">7.9.</a> <a href="#frame-connection-close" id="frame-connection-close">CONNECTION_CLOSE frame</a></h2>
<p id="rfc.section.7.9.p.1">An endpoint sends a CONNECTION_CLOSE frame (type=0x02) to notify its peer that the connection is being closed.  If there are open streams that haven&#8217;t been explicitly closed, they are implicitly closed when the connection is closed.  (Ideally, a GOAWAY frame would be sent with enough time that all streams are torn down.)  The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Reason Phrase Length (16)   |      [Reason Phrase (*)]    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.7.9.p.2">The fields of a CONNECTION_CLOSE frame are as follows:</p>
<p/>

<ul>
  <li>Error Code: A 32-bit error code which indicates the reason for closing this connection.</li>
  <li>Reason Phrase Length: A 16-bit unsigned number specifying the length of the reason phrase.  This may be zero if the sender chooses to not give details beyond the Error Code.</li>
  <li>Reason Phrase: An optional human-readable explanation for why the connection was closed.</li>
</ul>
<h2 id="rfc.section.7.10"><a href="#rfc.section.7.10">7.10.</a> <a href="#frame-goaway" id="frame-goaway">GOAWAY Frame</a></h2>
<p id="rfc.section.7.10.p.1">An endpoint may use a GOAWAY frame (type=0x03) to notify its peer that the connection should stop being used, and will likely be closed in the future. The endpoints will continue using any active streams, but the sender of the GOAWAY will not initiate any additional streams, and will not accept any new streams.  The frame is as follows:</p>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Last Good Stream ID (32)                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Reason Phrase Length (16)   |      [Reason Phrase (*)]    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
<p id="rfc.section.7.10.p.2">The fields of a GOAWAY frame are as follows:</p>
<p/>

<ul>
  <li>Error Code: A 32-bit field error code which indicates the reason for closing this connection.</li>
  <li>Last Good Stream ID: The last Stream ID which was accepted by the sender of the GOAWAY message.  If no streams were replied to, this value must be set to 0.</li>
  <li>Reason Phrase Length: A 16-bit unsigned number specifying the length of the reason phrase.  This may be zero if the sender chooses to not give details beyond the error code.</li>
  <li>Reason Phrase: An optional human-readable explanation for why the connection was closed.</li>
</ul>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#packetization" id="packetization">Packetization and Reliability</a></h1>
<p id="rfc.section.8.p.1">The maximum packet size for QUIC is the maximum size of the encrypted payload of the resulting UDP datagram.  All QUIC packets SHOULD be sized to fit within the path&#8217;s MTU to avoid IP fragmentation.  The recommended default maximum packet size is 1350 bytes for IPv6 and 1370 bytes for IPv4.  To optimize better, endpoints MAY use PLPMTUD <a href="#RFC4821">[RFC4821]</a> for detecting the path&#8217;s MTU and setting the maximum packet size appropriately.</p>
<p id="rfc.section.8.p.2">A sender bundles one or more frames in a Regular QUIC packet.  A sender MAY bundle any set of frames in a packet.  All QUIC packets MUST contain a packet number and MAY contain one or more frames (<a href="#frames">Section 5.2.2</a>).  Packet numbers MUST be unique within a connection and MUST NOT be reused within the same connection.  Packet numbers MUST be assigned to packets in a strictly monotonically increasing order.  The initial packet number used, at both the client and the server, MUST be 0.  That is, the first packet in both directions of the connection MUST have a packet number of 0.</p>
<p id="rfc.section.8.p.3">A sender SHOULD minimize per-packet bandwidth and computational costs by bundling as many frames as possible within a QUIC packet.  A sender MAY wait for a short period of time to bundle multiple frames before sending a packet that is not maximally packed, to avoid sending out large numbers of small packets.  An implementation may use heuristics about expected application sending behavior to determine whether and for how long to wait.  This waiting period is an implementation decision, and an implementation should be careful to delay conservatively, since any delay is likely to increase application-visible latency.</p>
<p id="rfc.section.8.p.4">Regular QUIC packets are &#8220;containers&#8221; of frames; a packet is never retransmitted whole, but frames in a lost packet may be rebundled and transmitted in a subsequent packet as necessary.</p>
<p id="rfc.section.8.p.5">A packet may contain frames and/or application data, only some of which may require reliability.  When a packet is detected as lost, the sender re-sends any frames as necessary:</p>
<p/>

<ul>
  <li>All application data sent in STREAM frames MUST be retransmitted, with one exception.  When an endpoint sends a RST_STREAM frame, data outstanding on that stream SHOULD NOT be retransmitted, since subsequent data on this stream is expected to not be delivered by the receiver.</li>
  <li>ACK, STOP_WAITING, and PADDING frames MUST NOT be retransmitted.  New frames of these types may however be bundled with any outgoing packet.</li>
  <li>All other frames MUST be retransmitted.</li>
</ul>
<p id="rfc.section.8.p.7">Upon detecting losses, a sender MUST take appropriate congestion control action.  The details of loss detection and congestion control are described in <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>.</p>
<p id="rfc.section.8.p.8">A receiver acknowledges receipt of a received packet by sending one or more ACK frames containing the packet number of the received packet.  To avoid perpetual acking between endpoints, a receiver MUST NOT generate an ack in response to every packet containing only ACK frames.  However, since it is possible that an endpoint might only send packets containing ACK frames (or other non-retransmittable frames), the receiving peer MAY send an ACK frame after a reasonable number (currently 20) of such packets have been received.</p>
<p id="rfc.section.8.p.9">Strategies and implications of the frequency of generating acknowledgments are discussed in more detail in <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#streams" id="streams">Streams: QUIC&#8217;s Data Structuring Abstraction</a></h1>
<p id="rfc.section.9.p.1">Streams in QUIC provide a lightweight, ordered, and bidirectional byte-stream abstraction modeled closely on HTTP/2 streams <a href="#RFC7540">[RFC7540]</a></p>
<p id="rfc.section.9.p.2">Streams can be created either by the client or the server, can concurrently send data interleaved with other streams, and can be cancelled.</p>
<p id="rfc.section.9.p.3">Data that is received on a stream is delivered in order within that stream, but there is no particular delivery order across streams.  Transmit ordering among streams is left to the implementation.</p>
<p id="rfc.section.9.p.4">The creation and destruction of streams are expected to have minimal bandwidth and computational cost.  A single STREAM frame may create, carry data for, and terminate a stream, or a stream may last the entire duration of a connection.</p>
<p id="rfc.section.9.p.5">Streams are individually flow controlled, allowing an endpoint to limit memory commitment and to apply back pressure.</p>
<p id="rfc.section.9.p.6">An alternative view of QUIC streams is as an elastic &#8220;message&#8221; abstraction, similar to the way ephemeral streams are used in SST <a href="#SST">[SST]</a>, which may be a more appealing description for some applications.</p>
<h2 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#life-of-a-stream" id="life-of-a-stream">Life of a Stream</a></h2>
<p id="rfc.section.9.1.p.1">The semantics of QUIC streams is based on HTTP/2 streams, and the lifecycle of a QUIC stream therefore closely follows that of an HTTP/2 stream <a href="#RFC7540">[RFC7540]</a>, with some differences to accommodate the possibility of out-of-order delivery due to the use of multiple streams in QUIC.  The lifecycle of a QUIC stream is shown in the following figure and described below.</p>
<div id="rfc.figure.12"/>
<div id="stream-lifecycle"/>
<pre>
                        app     +--------+
                 reserve_stream |        |
                 ,--------------|  idle  |
                /               |        |
               /                +--------+
              V                      |
        +----------+ send data/      |
        |          | recv data       | send data/
    ,---| reserved |------------.    | recv data
    |   |          |             \   |
    |   +----------+              v  v
    |               recv FIN/   +--------+ send FIN/
    |            app read_close |        | app write_close
    |                 ,---------|  open  |-----------.
    |                /          |        |            \
    |               v           +--------+             v
    |        +----------+            |             +----------+
    |        |   half   |            |             |   half   |
    |        |  closed  |            | send RST/   |  closed  |
    |        | (remote) |            | recv RST    | (local)  |
    |        +----------+            |             +----------+
    |            |                   |                    |
    |            | send FIN/         |          recv FIN/ |
    |            | app write_close/  |    app read_close/ |
    |            | send RST/         v          send RST/ |
    |            | recv RST     +--------+      recv RST  |
    | send RST/  `-------------&gt;|        |&lt;---------------'
    | recv RST                  | closed |
    `--------------------------&gt;|        |
                                +--------+

       send:   endpoint sends this frame
       recv:   endpoint receives this frame

       data: application data in a STREAM frame
       FIN: FIN flag in a STREAM frame
       RST: RST_STREAM frame

       app: application API signals to QUIC
       reserve_stream: causes a StreamID to be reserved for later use
       read_close: causes stream to be half-closed without receiving a FIN
       write_close: causes stream to be half-closed without sending a FIN
</pre>
<p class="figure">Figure 12: Lifecycle of a stream</p>
<p id="rfc.section.9.1.p.2">Note that this diagram shows stream state transitions and the frames and flags that affect those transitions only.  For the purpose of state transitions, the FIN flag is processed as a separate event to the frame that bears it; a STREAM frame with the FIN flag set can cause two state transitions.  When the FIN bit is sent on an empty STREAM frame, the offset in the STREAM frame MUST be one greater than the last data byte sent on this stream.</p>
<p id="rfc.section.9.1.p.3">Both endpoints have a subjective view of the state of a stream that could be different when frames are in transit.  Endpoints do not coordinate the creation of streams; they are created unilaterally by either endpoint.  The negative consequences of a mismatch in states are limited to the &#8220;closed&#8221; state after sending RST_STREAM, where frames might be received for some time after closing.</p>
<p id="rfc.section.9.1.p.4">Streams have the following states:</p>
<h3 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a> <a href="#idle" id="idle">idle</a></h3>
<p id="rfc.section.9.1.1.p.1">All streams start in the &#8220;idle&#8221; state.</p>
<p id="rfc.section.9.1.1.p.2">The following transitions are valid from this state:</p>
<p id="rfc.section.9.1.1.p.3">Sending or receiving a STREAM frame causes the stream to become &#8220;open&#8221;.  The stream identifier is selected as described in <a href="#stream-identifiers">Section 9.2</a>.  The same STREAM frame can also cause a stream to immediately become &#8220;half-closed&#8221;.</p>
<p id="rfc.section.9.1.1.p.4">An application can reserve an idle stream for later use.  The stream state for the reserved stream transitions to &#8220;reserved&#8221;.</p>
<p id="rfc.section.9.1.1.p.5">Receiving any frame other than STREAM or RST_STREAM on a stream in this state MUST be treated as a connection error (<a href="#error-handling">Section 11</a>) of type YYYY.</p>
<h3 id="rfc.section.9.1.2"><a href="#rfc.section.9.1.2">9.1.2.</a> <a href="#reserved" id="reserved">reserved</a></h3>
<p id="rfc.section.9.1.2.p.1">A stream in this state has been reserved for later use by the application.  In this state only the following transitions are possible:</p>
<p/>

<ul>
  <li>Sending or receiving a STREAM frame causes the stream to become &#8220;open&#8221;.</li>
  <li>Sending or receiving a RST_STREAM frame causes the stream to become &#8220;closed&#8221;.</li>
</ul>
<h3 id="rfc.section.9.1.3"><a href="#rfc.section.9.1.3">9.1.3.</a> <a href="#open" id="open">open</a></h3>
<p id="rfc.section.9.1.3.p.1">A stream in the &#8220;open&#8221; state may be used by both peers to send frames of any type.  In this state, a sending peer must observe the flow-control limit advertised by its receiving peer (<a href="#flow-control">Section 10</a>).</p>
<p id="rfc.section.9.1.3.p.2">From this state, either endpoint can send a frame with the FIN flag set, which causes the stream to transition into one of the &#8220;half-closed&#8221; states.  An endpoint sending an FIN flag causes the stream state to become &#8220;half-closed (local)&#8221;.  An endpoint receiving a FIN flag causes the stream state to become &#8220;half-closed (remote)&#8221;; the receiving endpoint MUST NOT process the FIN flag until all preceding data on the stream has been received.</p>
<p id="rfc.section.9.1.3.p.3">Either endpoint can send a RST_STREAM frame from this state, causing it to transition immediately to &#8220;closed&#8221;.</p>
<h3 id="rfc.section.9.1.4"><a href="#rfc.section.9.1.4">9.1.4.</a> <a href="#half-closed-local" id="half-closed-local">half-closed (local)</a></h3>
<p id="rfc.section.9.1.4.p.1">A stream that is in the &#8220;half-closed (local)&#8221; state MUST NOT be used for sending STREAM frames; WINDOW_UPDATE and RST_STREAM MAY be sent in this state.</p>
<p id="rfc.section.9.1.4.p.2">A stream transitions from this state to &#8220;closed&#8221; when a frame that contains an FIN flag is received or when either peer sends a RST_STREAM frame.</p>
<p id="rfc.section.9.1.4.p.3">An endpoint that closes a stream MUST NOT send data beyond the final offset that it has chosen, see <a href="#state-closed">Section 9.1.6</a> for details.</p>
<p id="rfc.section.9.1.4.p.4">An endpoint can receive any type of frame in this state.  Providing flow-control credit using WINDOW_UPDATE frames is necessary to continue receiving flow-controlled frames.  In this state, a receiver MAY ignore WINDOW_UPDATE frames for this stream, which might arrive for a short period after a frame bearing the FIN flag is sent.</p>
<h3 id="rfc.section.9.1.5"><a href="#rfc.section.9.1.5">9.1.5.</a> <a href="#half-closed-remote" id="half-closed-remote">half-closed (remote)</a></h3>
<p id="rfc.section.9.1.5.p.1">A stream that is &#8220;half-closed (remote)&#8221; is no longer being used by the peer to send any data.  In this state, a sender is no longer obligated to maintain a receiver stream-level flow-control window.</p>
<p id="rfc.section.9.1.5.p.2">A stream that is in the &#8220;half-closed (remote)&#8221; state will have a final offset for received data, see <a href="#state-closed">Section 9.1.6</a> for details.</p>
<p id="rfc.section.9.1.5.p.3">A stream in this state can be used by the endpoint to send frames of any type.  In this state, the endpoint continues to observe advertised stream-level and connection-level flow-control limits (<a href="#flow-control">Section 10</a>).</p>
<p id="rfc.section.9.1.5.p.4">A stream can transition from this state to &#8220;closed&#8221; by sending a frame that contains a FIN flag or when either peer sends a RST_STREAM frame.</p>
<h3 id="rfc.section.9.1.6"><a href="#rfc.section.9.1.6">9.1.6.</a> <a href="#state-closed" id="state-closed">closed</a></h3>
<p id="rfc.section.9.1.6.p.1">The &#8220;closed&#8221; state is the terminal state.</p>
<p id="rfc.section.9.1.6.p.2">An endpoint will learn the final offset of the data it receives on a stream when it enters the &#8220;half-closed (remote)&#8221; or &#8220;closed&#8221; state.  The final offset is carried explicitly in the RST_STREAM frame; otherwise, the final offset is the offset of the end of the data carried in STREAM frame marked with a FIN flag.</p>
<p id="rfc.section.9.1.6.p.3">An endpoint MUST NOT send data on a stream at or beyond the final offset.</p>
<p id="rfc.section.9.1.6.p.4">Once a final offset for a stream is known, it cannot change.  If a RST_STREAM or STREAM frame causes the final offset to change for a stream, an endpoint SHOULD respond with a QUIC_STREAM_DATA_AFTER_TERMINATION error (see <a href="#error-handling">Section 11</a>).  A receiver SHOULD treat receipt of data at or beyond the final offset as a QUIC_STREAM_DATA_AFTER_TERMINATION error.  Generating these errors is not mandatory, but only because requiring that an endpoint generate these errors also means that the endpoint needs to maintain the final offset state for closed streams, which could mean a significant state commitment.</p>
<p id="rfc.section.9.1.6.p.5">An endpoint that receives a RST_STREAM frame (and which has not sent a FIN or a RST_STREAM) MUST immediately respond with a RST_STREAM frame, and MUST NOT send any more data on the stream.  This endpoint may continue receiving frames for the stream on which a RST_STREAM is received.</p>
<p id="rfc.section.9.1.6.p.6">If this state is reached as a result of sending a RST_STREAM frame, the peer that receives the RST_STREAM frame might have already sent &#8211; or enqueued for sending &#8211; frames on the stream that cannot be withdrawn.  An endpoint MUST ignore frames that it receives on closed streams after it has sent a RST_STREAM frame. An endpoint MAY choose to limit the period over which it ignores frames and treat frames that arrive after this time as being in error.</p>
<p id="rfc.section.9.1.6.p.7">STREAM frames received after sending RST_STREAM are counted toward the connection and stream flow-control windows.  Even though these frames might be ignored, because they are sent before their sender receives the RST_STREAM, the sender will consider the frames to count against its flow-control windows.</p>
<p id="rfc.section.9.1.6.p.8">In the absence of more specific guidance elsewhere in this document, implementations SHOULD treat the receipt of a frame that is not expressly permitted in the description of a state as a connection error (<a href="#error-handling">Section 11</a>). Frames of unknown types are ignored.</p>
<p id="rfc.section.9.1.6.p.9">(TODO: QUIC_STREAM_NO_ERROR is a special case.  Write it up.)</p>
<h2 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#stream-identifiers" id="stream-identifiers">Stream Identifiers</a></h2>
<p id="rfc.section.9.2.p.1">Streams are identified by an unsigned 32-bit integer, referred to as the StreamID.  To avoid StreamID collision, clients MUST initiate streams usinge odd-numbered StreamIDs; streams initiated by the server MUST use even-numbered StreamIDs.</p>
<p id="rfc.section.9.2.p.2">A StreamID of zero (0x0) is reserved and used for connection-level flow control frames (<a href="#flow-control">Section 10</a>); the StreamID of zero cannot be used to establish a new stream.</p>
<p id="rfc.section.9.2.p.3">StreamID 1 (0x1) is reserved for the crypto handshake.  StreamID 1 MUST NOT be used for application data, and MUST be the first client-initiated stream.</p>
<p id="rfc.section.9.2.p.4">Streams MUST be created or reserved in sequential order, but MAY be used in arbitrary order.  A QUIC endpoint MUST NOT reuse a StreamID on a given connection.</p>
<h2 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> <a href="#stream-concurrency" id="stream-concurrency">Stream Concurrency</a></h2>
<p id="rfc.section.9.3.p.1">An endpoint can limit the number of concurrently active incoming streams by setting the MSPC parameter (see <a href="#required-transport-parameters">Section 6.2.1.2</a>) in the transport parameters. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum number of concurrent streams the server can initiate, and servers specify the maximum number of concurrent streams the client can initiate.</p>
<p id="rfc.section.9.3.p.2">Streams that are in the &#8220;open&#8221; state or in either of the &#8220;half-closed&#8221; states count toward the maximum number of streams that an endpoint is permitted to open.  Streams in any of these three states count toward the limit advertised in the MSPC setting.</p>
<p id="rfc.section.9.3.p.3">Endpoints MUST NOT exceed the limit set by their peer.  An endpoint that receives a STREAM frame that causes its advertised concurrent stream limit to be exceeded MUST treat this as a stream error of type QUIC_TOO_MANY_OPEN_STREAMS (<a href="#error-handling">Section 11</a>).</p>
<h2 id="rfc.section.9.4"><a href="#rfc.section.9.4">9.4.</a> <a href="#sending-and-receiving-data" id="sending-and-receiving-data">Sending and Receiving Data</a></h2>
<p id="rfc.section.9.4.p.1">Once a stream is created, endpoints may use the stream to send and receive data.  Each endpoint may send a series of STREAM frames encapsulating data on a stream until the stream is terminated in that direction.  Streams are an ordered byte-stream abstraction, and they have no other structure within them.  STREAM frame boundaries are not expected to be preserved in retransmissions from the sender or during delivery to the application at the receiver.</p>
<p id="rfc.section.9.4.p.2">When new data is to be sent on a stream, a sender MUST set the encapsulating STREAM frame&#8217;s offset field to the stream offset of the first byte of this new data.  The first byte of data that is sent on a stream has the stream offset 0.  A receiver MUST ensure that received stream data is delivered to the application as an ordered byte-stream.  Data received out of order MUST be buffered for later delivery, as long as it is not in violation of the receiver&#8217;s flow control limits.</p>
<p id="rfc.section.9.4.p.3">The crypto handshake stream, Stream 1, MUST NOT be subject to congestion control or connection-level flow control, but MUST be subject to stream-level flow control. An endpoint MUST NOT send data on any other stream without consulting the congestion controller and the flow controller.</p>
<p id="rfc.section.9.4.p.4">Flow control is described in detail in <a href="#flow-control">Section 10</a>, and congestion control is described in the companion document <a href="#QUIC-RECOVERY">[QUIC-RECOVERY]</a>.</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#flow-control" id="flow-control">Flow Control</a></h1>
<p id="rfc.section.10.p.1">It is necessary to limit the amount of data that a sender may have outstanding at any time, so as to prevent a fast sender from overwhelming a slow receiver, or to prevent a malicious sender from consuming significant resources at a receiver.  This section describes QUIC&#8217;s flow-control mechanisms.</p>
<p id="rfc.section.10.p.2">QUIC employs a credit-based flow-control scheme similar to HTTP/2&#8217;s flow control <a href="#RFC7540">[RFC7540]</a>.  A receiver advertises the number of octets it is prepared to receive on a given stream and for the entire connection.  This leads to two levels of flow control in QUIC: (i) Connection flow control, which prevents senders from exceeding a receiver&#8217;s buffer capacity for the connection, and (ii) Stream flow control, which prevents a single stream from consuming the entire receive buffer for a connection.</p>
<p id="rfc.section.10.p.3">A receiver sends WINDOW_UPDATE frames to the sender to advertise additional credit by sending the absolute byte offset in the stream or in the connection which it is willing to receive.</p>
<p id="rfc.section.10.p.4">The initial flow control credit is 65536 bytes for both the stream and connection flow controllers.</p>
<p id="rfc.section.10.p.5">A receiver MAY advertise a larger offset at any point in the connection by sending a WINDOW_UPDATE frame.  A receiver MUST NOT renege on an advertisement; that is, once a receiver advertises an offset via a WINDOW_UPDATE frame, it MUST NOT subsequently advertise a smaller offset.  A sender may receive WINDOW_UPDATE frames out of order; a sender MUST therefore ignore any WINDOW_UPDATE that does not move the window forward.</p>
<p id="rfc.section.10.p.6">A receiver MUST close the connection with a QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error (<a href="#error-handling">Section 11</a>) if the peer violates the advertised stream or connection flow control windows.</p>
<p id="rfc.section.10.p.7">A sender MUST send BLOCKED frames to indicate it has data to write but is blocked by lack of connection or stream flow control credit.  BLOCKED frames are expected to be sent infrequently in common cases, but they are considered useful for debugging and monitoring purposes.</p>
<p id="rfc.section.10.p.8">A receiver advertises credit for a stream by sending a WINDOW_UPDATE frame with the StreamID set appropriately. A receiver may use the current offset of data consumed to determine the flow control offset to be advertised.  A receiver MAY send copies of a WINDOW_UPDATE frame in multiple packets in order to make sure that the sender receives it before running out of flow control credit, even if one of the packets is lost.</p>
<p id="rfc.section.10.p.9">Connection flow control is a limit to the total bytes of stream data sent in STREAM frames on all streams contributing to connection flow control.  A receiver advertises credit for a connection by sending a WINDOW_UPDATE frame with the StreamID set to zero (0x00).  A receiver maintains a cumulative sum of bytes received on all streams contributing to connection-level flow control, to check for flow control violations. A receiver may maintain a cumulative sum of bytes consumed on all contributing streams to determine the connection-level flow control offset to be advertised.</p>
<h2 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#edge-cases-and-other-considerations" id="edge-cases-and-other-considerations">Edge Cases and Other Considerations</a></h2>
<p id="rfc.section.10.1.p.1">There are some edge cases which must be considered when dealing with stream and connection level flow control.  Given enough time, both endpoints must agree on flow control state.  If one end believes it can send more than the other end is willing to receive, the connection will be torn down when too much data arrives.  Conversely if a sender believes it is blocked, while endpoint B expects more data can be received, then the connection can be in a deadlock, with the sender waiting for a WINDOW_UPDATE which will never come.</p>
<h3 id="rfc.section.10.1.1"><a href="#rfc.section.10.1.1">10.1.1.</a> <a href="#mid-stream-rststream" id="mid-stream-rststream">Mid-stream RST_STREAM</a></h3>
<p id="rfc.section.10.1.1.p.1">On receipt of a RST_STREAM frame, an endpoint will tear down state for the matching stream and ignore further data arriving on that stream.  This could result in the endpoints getting out of sync, since the RST_STREAM frame may have arrived out of order and there may be further bytes in flight.  The data sender would have counted the data against its connection level flow control budget, but a receiver that has not received these bytes would not know to include them as well.  The receiver must learn the number of bytes that were sent on the stream to make the same adjustment in its connection flow controller.</p>
<p id="rfc.section.10.1.1.p.2">To avoid this de-synchronization, a RST_STREAM sender MUST include the final byte offset sent on the stream in the RST_STREAM frame.  On receiving a RST_STREAM frame, a receiver definitively knows how many bytes were sent on that stream before the RST_STREAM frame, and the receiver MUST use the final offset to account for all bytes sent on the stream in its connection level flow controller.</p>
<h3 id="rfc.section.10.1.2"><a href="#rfc.section.10.1.2">10.1.2.</a> <a href="#response-to-a-rststream" id="response-to-a-rststream">Response to a RST_STREAM</a></h3>
<p id="rfc.section.10.1.2.p.1">Since streams are bidirectional, a sender of a RST_STREAM needs to know how many bytes the peer has sent on the stream.  If an endpoint receives a RST_STREAM frame and has sent neither a FIN nor a RST_STREAM, it MUST send a RST_STREAM in response, bearing the offset of the last byte sent on this stream as the final offset.</p>
<h3 id="rfc.section.10.1.3"><a href="#rfc.section.10.1.3">10.1.3.</a> <a href="#offset-increment" id="offset-increment">Offset Increment</a></h3>
<p id="rfc.section.10.1.3.p.1">This document leaves when and how many bytes to advertise in a WINDOW_UPDATE to the implementation, but offers a few considerations.  WINDOW_UPDATE frames constitute overhead, and therefore, sending a WINDOW_UPDATE with small offset increments is undesirable.  At the same time, sending WINDOW_UPDATES with large offset increments requires the sender to commit to that amount of buffer.  Implementations must find the correct tradeoff between these sides to determine how large an offset increment to send in a WINDOW_UPDATE.</p>
<p id="rfc.section.10.1.3.p.2">A receiver MAY use an autotuning mechanism to tune the size of the offset increment to advertise based on a roundtrip time estimate and the rate at which the receiving application consumes data, similar to common TCP implementations.</p>
<h3 id="rfc.section.10.1.4"><a href="#rfc.section.10.1.4">10.1.4.</a> <a href="#blocked-frames" id="blocked-frames">BLOCKED frames</a></h3>
<p id="rfc.section.10.1.4.p.1">If a sender does not receive a WINDOW_UPDATE frame when it has run out of flow control credit, the sender will be blocked and MUST send a BLOCKED frame.  A BLOCKED frame is expected to be useful for debugging at the receiver.  A receiver SHOULD NOT wait for a BLOCKED frame before sending a WINDOW_UPDATE, since doing so will cause at least one roundtrip of quiescence.  For smooth operation of the congestion controller, it is generally considered best to not let the sender go into quiescence if avoidable.  To avoid blocking a sender, and to reasonably account for the possibiity of loss, a receiver should send a WINDOW_UPDATE frame at least two roundtrips before it expects the sender to get blocked.</p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> <a href="#error-handling" id="error-handling">Error Codes</a></h1>
<p id="rfc.section.11.p.1">Error codes are 32 bits long, with the first two bits indicating the source of the error code:</p>
<p/>

<dl>
  <dt>0x00000000-0x3FFFFFFF:</dt>
  <dd style="margin-left: 8">Application-specific error codes.  Defined by each application-layer protocol.</dd>
  <dt>0x40000000-0x7FFFFFFF:</dt>
  <dd style="margin-left: 8">Reserved for host-local error codes.  These codes MUST NOT be sent to a peer, but MAY be used in API return codes and logs.</dd>
  <dt>0x80000000-0xBFFFFFFF:</dt>
  <dd style="margin-left: 8">QUIC transport error codes, including packet protection errors.  Applicable to all uses of QUIC.</dd>
  <dt>0xC0000000-0xFFFFFFFF:</dt>
  <dd style="margin-left: 8">Cryptographic error codes.  Defined by the crypto handshake protocol in use.</dd>
</dl>
<p id="rfc.section.11.p.3">This section lists the defined QUIC transport error codes that may be used in a CONNECTION_CLOSE or RST_STREAM frame. Error codes share a common code space.  Some error codes apply only to either streams or the entire connection and have no defined semantics in the other context.</p>
<p/>

<dl>
  <dt>QUIC_INTERNAL_ERROR (0x80000001):</dt>
  <dd style="margin-left: 8">Connection has reached an invalid state.</dd>
  <dt>QUIC_STREAM_DATA_AFTER_TERMINATION (0x80000002):</dt>
  <dd style="margin-left: 8">There were data frames after the a fin or reset.</dd>
  <dt>QUIC_INVALID_PACKET_HEADER (0x80000003):</dt>
  <dd style="margin-left: 8">Control frame is malformed.</dd>
  <dt>QUIC_INVALID_FRAME_DATA (0x80000004):</dt>
  <dd style="margin-left: 8">Frame data is malformed.</dd>
  <dt>QUIC_MISSING_PAYLOAD (0x80000030):</dt>
  <dd style="margin-left: 8">The packet contained no payload.</dd>
  <dt>QUIC_INVALID_STREAM_DATA (0x8000002E):</dt>
  <dd style="margin-left: 8">STREAM frame data is malformed.</dd>
  <dt>QUIC_OVERLAPPING_STREAM_DATA (0x80000057):</dt>
  <dd style="margin-left: 8">STREAM frame data overlaps with buffered data.</dd>
  <dt>QUIC_UNENCRYPTED_STREAM_DATA (0x8000003D):</dt>
  <dd style="margin-left: 8">Received STREAM frame data is not encrypted.</dd>
  <dt>QUIC_MAYBE_CORRUPTED_MEMORY (0x80000059):</dt>
  <dd style="margin-left: 8">Received a frame which is likely the result of memory corruption.</dd>
  <dt>QUIC_INVALID_RST_STREAM_DATA (0x80000006):</dt>
  <dd style="margin-left: 8">RST_STREAM frame data is malformed.</dd>
  <dt>QUIC_INVALID_CONNECTION_CLOSE_DATA (0x80000007):</dt>
  <dd style="margin-left: 8">CONNECTION_CLOSE frame data is malformed.</dd>
  <dt>QUIC_INVALID_GOAWAY_DATA (0x80000008):</dt>
  <dd style="margin-left: 8">GOAWAY frame data is malformed.</dd>
  <dt>QUIC_INVALID_WINDOW_UPDATE_DATA (0x80000039):</dt>
  <dd style="margin-left: 8">WINDOW_UPDATE frame data is malformed.</dd>
  <dt>QUIC_INVALID_BLOCKED_DATA (0x8000003A):</dt>
  <dd style="margin-left: 8">BLOCKED frame data is malformed.</dd>
  <dt>QUIC_INVALID_STOP_WAITING_DATA (0x8000003C):</dt>
  <dd style="margin-left: 8">STOP_WAITING frame data is malformed.</dd>
  <dt>QUIC_INVALID_PATH_CLOSE_DATA (0x8000004E):</dt>
  <dd style="margin-left: 8">PATH_CLOSE frame data is malformed.</dd>
  <dt>QUIC_INVALID_ACK_DATA (0x80000009):</dt>
  <dd style="margin-left: 8">ACK frame data is malformed.</dd>
  <dt>QUIC_INVALID_VERSION_NEGOTIATION_PACKET (0x8000000A):</dt>
  <dd style="margin-left: 8">Version negotiation packet is malformed.</dd>
  <dt>QUIC_INVALID_PUBLIC_RST_PACKET (0x8000000b):</dt>
  <dd style="margin-left: 8">Public RST packet is malformed.</dd>
  <dt>QUIC_DECRYPTION_FAILURE (0x8000000c):</dt>
  <dd style="margin-left: 8">There was an error decrypting.</dd>
  <dt>QUIC_ENCRYPTION_FAILURE (0x8000000d):</dt>
  <dd style="margin-left: 8">There was an error encrypting.</dd>
  <dt>QUIC_PACKET_TOO_LARGE (0x8000000e):</dt>
  <dd style="margin-left: 8">The packet exceeded kMaxPacketSize.</dd>
  <dt>QUIC_PEER_GOING_AWAY (0x80000010):</dt>
  <dd style="margin-left: 8">The peer is going away. May be a client or server.</dd>
  <dt>QUIC_INVALID_STREAM_ID (0x80000011):</dt>
  <dd style="margin-left: 8">A stream ID was invalid.</dd>
  <dt>QUIC_INVALID_PRIORITY (0x80000031):</dt>
  <dd style="margin-left: 8">A priority was invalid.</dd>
  <dt>QUIC_TOO_MANY_OPEN_STREAMS (0x80000012):</dt>
  <dd style="margin-left: 8">Too many streams already open.</dd>
  <dt>QUIC_TOO_MANY_AVAILABLE_STREAMS (0x8000004c):</dt>
  <dd style="margin-left: 8">The peer created too many available streams.</dd>
  <dt>QUIC_PUBLIC_RESET (0x80000013):</dt>
  <dd style="margin-left: 8">Received public reset for this connection.</dd>
  <dt>QUIC_INVALID_VERSION (0x80000014):</dt>
  <dd style="margin-left: 8">Invalid protocol version.</dd>
  <dt>QUIC_INVALID_HEADER_ID (0x80000016):</dt>
  <dd style="margin-left: 8">The Header ID for a stream was too far from the previous.</dd>
  <dt>QUIC_INVALID_NEGOTIATED_VALUE (0x80000017):</dt>
  <dd style="margin-left: 8">Negotiable parameter received during handshake had invalid value.</dd>
  <dt>QUIC_DECOMPRESSION_FAILURE (0x80000018):</dt>
  <dd style="margin-left: 8">There was an error decompressing data.</dd>
  <dt>QUIC_NETWORK_IDLE_TIMEOUT (0x80000019):</dt>
  <dd style="margin-left: 8">The connection timed out due to no network activity.</dd>
  <dt>QUIC_HANDSHAKE_TIMEOUT (0x80000043):</dt>
  <dd style="margin-left: 8">The connection timed out waiting for the handshake to complete.</dd>
  <dt>QUIC_ERROR_MIGRATING_ADDRESS (0x8000001a):</dt>
  <dd style="margin-left: 8">There was an error encountered migrating addresses.</dd>
  <dt>QUIC_ERROR_MIGRATING_PORT (0x80000056):</dt>
  <dd style="margin-left: 8">There was an error encountered migrating port only.</dd>
  <dt>QUIC_EMPTY_STREAM_FRAME_NO_FIN (0x80000032):</dt>
  <dd style="margin-left: 8">We received a STREAM_FRAME with no data and no fin flag set.</dd>
  <dt>QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA (0x8000003b):</dt>
  <dd style="margin-left: 8">The peer received too much data, violating flow control.</dd>
  <dt>QUIC_FLOW_CONTROL_SENT_TOO_MUCH_DATA (0x8000003f):</dt>
  <dd style="margin-left: 8">The peer sent too much data, violating flow control.</dd>
  <dt>QUIC_FLOW_CONTROL_INVALID_WINDOW (0x80000040):</dt>
  <dd style="margin-left: 8">The peer received an invalid flow control window.</dd>
  <dt>QUIC_CONNECTION_IP_POOLED (0x8000003e):</dt>
  <dd style="margin-left: 8">The connection has been IP pooled into an existing connection.</dd>
  <dt>QUIC_TOO_MANY_OUTSTANDING_SENT_PACKETS (0x80000044):</dt>
  <dd style="margin-left: 8">The connection has too many outstanding sent packets.</dd>
  <dt>QUIC_TOO_MANY_OUTSTANDING_RECEIVED_PACKETS (0x80000045):</dt>
  <dd style="margin-left: 8">The connection has too many outstanding received packets.</dd>
  <dt>QUIC_CONNECTION_CANCELLED (0x80000046):</dt>
  <dd style="margin-left: 8">The QUIC connection has been cancelled.</dd>
  <dt>QUIC_BAD_PACKET_LOSS_RATE (0x80000047):</dt>
  <dd style="margin-left: 8">Disabled QUIC because of high packet loss rate.</dd>
  <dt>QUIC_PUBLIC_RESETS_POST_HANDSHAKE (0x80000049):</dt>
  <dd style="margin-left: 8">Disabled QUIC because of too many PUBLIC_RESETs post handshake.</dd>
  <dt>QUIC_TIMEOUTS_WITH_OPEN_STREAMS (0x8000004a):</dt>
  <dd style="margin-left: 8">Disabled QUIC because of too many timeouts with streams open.</dd>
  <dt>QUIC_TOO_MANY_RTOS (0x80000055):</dt>
  <dd style="margin-left: 8">QUIC timed out after too many RTOs.</dd>
  <dt>QUIC_ENCRYPTION_LEVEL_INCORRECT (0x8000002c):</dt>
  <dd style="margin-left: 8">A packet was received with the wrong encryption level (i.e. it should have been encrypted but was not.)</dd>
  <dt>QUIC_VERSION_NEGOTIATION_MISMATCH (0x80000037):</dt>
  <dd style="margin-left: 8">This connection involved a version negotiation which appears to have been tampered with.</dd>
  <dt>QUIC_IP_ADDRESS_CHANGED (0x80000050):</dt>
  <dd style="margin-left: 8">IP address changed causing connection close.</dd>
  <dt>QUIC_TOO_MANY_FRAME_GAPS (0x8000005d):</dt>
  <dd style="margin-left: 8">Stream frames arrived too discontiguously so that stream sequencer buffer maintains too many gaps.</dd>
  <dt>QUIC_TOO_MANY_SESSIONS_ON_SERVER (0x80000060):</dt>
  <dd style="margin-left: 8">Connection closed because server hit max number of sessions allowed.</dd>
</dl>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#security-and-privacy-considerations" id="security-and-privacy-considerations">Security and Privacy Considerations</a></h1>
<h2 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> <a href="#spoofed-ack-attack" id="spoofed-ack-attack">Spoofed Ack Attack</a></h2>
<p id="rfc.section.12.1.p.1">An attacker receives an STK from the server and then releases the IP address on which it received the STK.  The attacker may, in the future, spoof this same address (which now presumably addresses a different endpoint), and initiate a 0-RTT connection with a server on the victim&#8217;s behalf.  The attacker then spoofs ACK frames to the server which cause the server to potentially drown the victim in data.</p>
<p id="rfc.section.12.1.p.2">There are two possible mitigations to this attack.  The simplest one is that a server can unilaterally create a gap in packet-number space.  In the non-attack scenario, the client will send an ack with a larger largest acked.  In the attack scenario, the attacker may ack a packet in the gap.  If the server sees an ack for a packet that was never sent, the connection can be aborted.</p>
<p id="rfc.section.12.1.p.3">The second mitigation is that the server can require that acks for sent packets match the encryption level of the sent packet.  This mitigation is useful if the connection has an ephemeral forward-secure key that is generated and used for every new connection.  If a packet sent is encrypted with a forward-secure key, then any acks that are received for them must also be forward-secure encrypted.  Since the attacker will not have the forward secure key, the attacker will not be able to generate forward-secure encrypted ack packets.</p>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.13.p.1">This document has no IANA actions yet.</p>
<h1 id="rfc.references"><a href="#rfc.references">14.</a> References</h1>
<h2 id="rfc.references.1"><a href="#rfc.references.1">14.1.</a> Normative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="QUIC-RECOVERY">[QUIC-RECOVERY]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Google">I. Swett</a>, "<a>QUIC Loss Detection and Congestion Control</a>"</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-TLS">[QUIC-TLS]</b>
      </td>
      <td class="top"><a title="Mozilla">Thomson, M.</a> and <a title="sn3rd">S. Turner, Ed</a>, "<a>Using Transport Layer Security (TLS) to Secure QUIC</a>"</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4821">[RFC4821]</b>
      </td>
      <td class="top"><a>Mathis, M.</a> and <a>J. Heffner</a>, "<a href="http://tools.ietf.org/html/rfc4821">Packetization Layer Path MTU Discovery</a>", RFC 4821, DOI 10.17487/RFC4821, March 2007.</td>
    </tr>
  </tbody>
</table>
<h2 id="rfc.references.2"><a href="#rfc.references.2">14.2.</a> Informative References</h2>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="EARLY-DESIGN">[EARLY-DESIGN]</b>
      </td>
      <td class="top"><a>Roskind, J.</a>, "<a href="https://goo.gl/dMVtFi">QUIC: Multiplexed Transport Over UDP</a>", December 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-HTTP">[QUIC-HTTP]</b>
      </td>
      <td class="top"><a title="Microsoft">Bishop, M.</a>, "<a>Hypertext Transfer Protocol (HTTP) over QUIC</a>"</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUICCrypto">[QUICCrypto]</b>
      </td>
      <td class="top"><a>Langley, A.</a> and <a>W. Chang</a>, "<a href="http://goo.gl/OuVSxa">QUIC Crypto</a>", May 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2360">[RFC2360]</b>
      </td>
      <td class="top"><a>Scott, G.</a>, "<a href="http://tools.ietf.org/html/rfc2360">Guide for Internet Standards Writers</a>", BCP 22, RFC 2360, DOI 10.17487/RFC2360, June 1998.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SST">[SST]</b>
      </td>
      <td class="top"><a>Ford, B.</a>, "<a>Structured Streams: A New Transport Abstraction</a>", ACM SIGCOMM 2007 , August 2007.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#contributors" id="contributors">Contributors</a></h1>
<p id="rfc.section.A.p.1">The original authors of this specification were Ryan Hamilton, Jana Iyengar, Ian Swett, and Alyssa Wilk.</p>
<p id="rfc.section.A.p.2">The original design and rationale behind this protocol draw significantly from work by Jim Roskind <a href="#EARLY-DESIGN">[EARLY-DESIGN]</a>. In alphabetical order, the contributors to the pre-IETF QUIC project at Google are: Britt Cyr, Jeremy Dorfman, Ryan Hamilton, Jana Iyengar, Fedor Kouranov, Charles Krasic, Jo Kulik, Adam Langley, Jim Roskind, Robbie Shade, Satyam Shekhar, Cherie Shi, Ian Swett, Raman Tenneti, Victor Vasiliev, Antonio Vicente, Patrik Westin, Alyssa Wilk, Dale Worley, Fan Yang, Dan Zhang, Daniel Ziegler.</p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.B.p.1">Special thanks are due to the following for helping shape pre-IETF QUIC and its deployment: Chris Bentzel, Misha Efimov, Roberto Peon, Alistair Riddoch, Siddharth Vijayakrishnan, and Assar Westerlund.</p>
<p id="rfc.section.B.p.2">This document has benefited immensely from various private discussions and public ones on the quic@ietf.org and proto-quic@chromium.org mailing lists. Our thanks to all.</p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#change-log" id="change-log">Change Log</a></h1>
<p/>

<ul class="empty">
  <li><strong>RFC Editor&#8217;s Note:</strong>  Please remove this section prior to publication of a final version of this document.</li>
</ul>
<h2 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> <a href="#since-draft-ietf-quic-transport-00" id="since-draft-ietf-quic-transport-00">Since draft-ietf-quic-transport-00:</a></h2>
<p/>

<ul>
  <li>Replaced DIVERSIFICATION_NONCE flag with KEY_PHASE flag</li>
  <li>Defined versioning</li>
  <li>Reworked description of packet and frame layout</li>
  <li>Error code space is divided into regions for each component</li>
  <li>Use big endian for all numeric values</li>
</ul>
<h2 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> <a href="#since-draft-hamilton-quic-transport-protocol-01" id="since-draft-hamilton-quic-transport-protocol-01">Since draft-hamilton-quic-transport-protocol-01:</a></h2>
<p/>

<ul>
  <li>Adopted as base for draft-ietf-quic-tls.</li>
  <li>Updated authors/editors list.</li>
  <li>Added IANA Considerations section.</li>
  <li>Moved Contributors and Acknowledgments to appendices.</li>
</ul>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jana Iyengar</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Iyengar</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jri@google.com">jri@google.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/quicwg/base-drafts">Fork me on GitHub</a></div></div>
</body>
</html>
